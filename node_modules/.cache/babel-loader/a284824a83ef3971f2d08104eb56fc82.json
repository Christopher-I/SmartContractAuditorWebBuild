{"ast":null,"code":"(function () {\n  function r(e, n, t) {\n    function o(i, f) {\n      if (!n[i]) {\n        if (!e[i]) {\n          var c = \"function\" == typeof require && require;\n          if (!f && c) return c(i, !0);\n          if (u) return u(i, !0);\n          var a = new Error(\"Cannot find module '\" + i + \"'\");\n          throw a.code = \"MODULE_NOT_FOUND\", a;\n        }\n\n        var p = n[i] = {\n          exports: {}\n        };\n        e[i][0].call(p.exports, function (r) {\n          var n = e[i][1][r];\n          return o(n || r);\n        }, p, p.exports, r, e, n, t);\n      }\n\n      return n[i].exports;\n    }\n\n    for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);\n\n    return o;\n  }\n\n  return r;\n})()({\n  1: [function (require, module, exports) {\n    (function (global) {\n      'use strict'; // compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n      // original notice:\n\n      /*!\n       * The buffer module from node.js, for the browser.\n       *\n       * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n       * @license  MIT\n       */\n\n      function compare(a, b) {\n        if (a === b) {\n          return 0;\n        }\n\n        var x = a.length;\n        var y = b.length;\n\n        for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n          if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n          }\n        }\n\n        if (x < y) {\n          return -1;\n        }\n\n        if (y < x) {\n          return 1;\n        }\n\n        return 0;\n      }\n\n      function isBuffer(b) {\n        if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n          return global.Buffer.isBuffer(b);\n        }\n\n        return !!(b != null && b._isBuffer);\n      } // based on node assert, original notice:\n      // http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n      //\n      // THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n      //\n      // Originally from narwhal.js (http://narwhaljs.org)\n      // Copyright (c) 2009 Thomas Robinson <280north.com>\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a copy\n      // of this software and associated documentation files (the 'Software'), to\n      // deal in the Software without restriction, including without limitation the\n      // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n      // sell copies of the Software, and to permit persons to whom the Software is\n      // furnished to do so, subject to the following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included in\n      // all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n      // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n      // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n      // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n      // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n      // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n      var util = require('util/');\n\n      var hasOwn = Object.prototype.hasOwnProperty;\n      var pSlice = Array.prototype.slice;\n\n      var functionsHaveNames = function () {\n        return function foo() {}.name === 'foo';\n      }();\n\n      function pToString(obj) {\n        return Object.prototype.toString.call(obj);\n      }\n\n      function isView(arrbuf) {\n        if (isBuffer(arrbuf)) {\n          return false;\n        }\n\n        if (typeof global.ArrayBuffer !== 'function') {\n          return false;\n        }\n\n        if (typeof ArrayBuffer.isView === 'function') {\n          return ArrayBuffer.isView(arrbuf);\n        }\n\n        if (!arrbuf) {\n          return false;\n        }\n\n        if (arrbuf instanceof DataView) {\n          return true;\n        }\n\n        if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n          return true;\n        }\n\n        return false;\n      } // 1. The assert module provides functions that throw\n      // AssertionError's when particular conditions are not met. The\n      // assert module must conform to the following interface.\n\n\n      var assert = module.exports = ok; // 2. The AssertionError is defined in assert.\n      // new assert.AssertionError({ message: message,\n      //                             actual: actual,\n      //                             expected: expected })\n\n      var regex = /\\s*function\\s+([^\\(\\s]*)\\s*/; // based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\n\n      function getName(func) {\n        if (!util.isFunction(func)) {\n          return;\n        }\n\n        if (functionsHaveNames) {\n          return func.name;\n        }\n\n        var str = func.toString();\n        var match = str.match(regex);\n        return match && match[1];\n      }\n\n      assert.AssertionError = function AssertionError(options) {\n        this.name = 'AssertionError';\n        this.actual = options.actual;\n        this.expected = options.expected;\n        this.operator = options.operator;\n\n        if (options.message) {\n          this.message = options.message;\n          this.generatedMessage = false;\n        } else {\n          this.message = getMessage(this);\n          this.generatedMessage = true;\n        }\n\n        var stackStartFunction = options.stackStartFunction || fail;\n\n        if (Error.captureStackTrace) {\n          Error.captureStackTrace(this, stackStartFunction);\n        } else {\n          // non v8 browsers so we can have a stacktrace\n          var err = new Error();\n\n          if (err.stack) {\n            var out = err.stack; // try to strip useless frames\n\n            var fn_name = getName(stackStartFunction);\n            var idx = out.indexOf('\\n' + fn_name);\n\n            if (idx >= 0) {\n              // once we have located the function frame\n              // we need to strip out everything before it (and its line)\n              var next_line = out.indexOf('\\n', idx + 1);\n              out = out.substring(next_line + 1);\n            }\n\n            this.stack = out;\n          }\n        }\n      }; // assert.AssertionError instanceof Error\n\n\n      util.inherits(assert.AssertionError, Error);\n\n      function truncate(s, n) {\n        if (typeof s === 'string') {\n          return s.length < n ? s : s.slice(0, n);\n        } else {\n          return s;\n        }\n      }\n\n      function inspect(something) {\n        if (functionsHaveNames || !util.isFunction(something)) {\n          return util.inspect(something);\n        }\n\n        var rawname = getName(something);\n        var name = rawname ? ': ' + rawname : '';\n        return '[Function' + name + ']';\n      }\n\n      function getMessage(self) {\n        return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);\n      } // At present only the three keys mentioned above are used and\n      // understood by the spec. Implementations or sub modules can pass\n      // other keys to the AssertionError's constructor - they will be\n      // ignored.\n      // 3. All of the following functions must throw an AssertionError\n      // when a corresponding condition is not met, with a message that\n      // may be undefined if not provided.  All assertion methods provide\n      // both the actual and expected values to the assertion error for\n      // display purposes.\n\n\n      function fail(actual, expected, message, operator, stackStartFunction) {\n        throw new assert.AssertionError({\n          message: message,\n          actual: actual,\n          expected: expected,\n          operator: operator,\n          stackStartFunction: stackStartFunction\n        });\n      } // EXTENSION! allows for well behaved errors defined elsewhere.\n\n\n      assert.fail = fail; // 4. Pure assertion tests whether a value is truthy, as determined\n      // by !!guard.\n      // assert.ok(guard, message_opt);\n      // This statement is equivalent to assert.equal(true, !!guard,\n      // message_opt);. To test strictly for the value true, use\n      // assert.strictEqual(true, guard, message_opt);.\n\n      function ok(value, message) {\n        if (!value) fail(value, true, message, '==', assert.ok);\n      }\n\n      assert.ok = ok; // 5. The equality assertion tests shallow, coercive equality with\n      // ==.\n      // assert.equal(actual, expected, message_opt);\n\n      assert.equal = function equal(actual, expected, message) {\n        if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n      }; // 6. The non-equality assertion tests for whether two objects are not equal\n      // with != assert.notEqual(actual, expected, message_opt);\n\n\n      assert.notEqual = function notEqual(actual, expected, message) {\n        if (actual == expected) {\n          fail(actual, expected, message, '!=', assert.notEqual);\n        }\n      }; // 7. The equivalence assertion tests a deep equality relation.\n      // assert.deepEqual(actual, expected, message_opt);\n\n\n      assert.deepEqual = function deepEqual(actual, expected, message) {\n        if (!_deepEqual(actual, expected, false)) {\n          fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n        }\n      };\n\n      assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n        if (!_deepEqual(actual, expected, true)) {\n          fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n        }\n      };\n\n      function _deepEqual(actual, expected, strict, memos) {\n        // 7.1. All identical values are equivalent, as determined by ===.\n        if (actual === expected) {\n          return true;\n        } else if (isBuffer(actual) && isBuffer(expected)) {\n          return compare(actual, expected) === 0; // 7.2. If the expected value is a Date object, the actual value is\n          // equivalent if it is also a Date object that refers to the same time.\n        } else if (util.isDate(actual) && util.isDate(expected)) {\n          return actual.getTime() === expected.getTime(); // 7.3 If the expected value is a RegExp object, the actual value is\n          // equivalent if it is also a RegExp object with the same source and\n          // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n        } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n          return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase; // 7.4. Other pairs that do not both pass typeof value == 'object',\n          // equivalence is determined by ==.\n        } else if ((actual === null || typeof actual !== 'object') && (expected === null || typeof expected !== 'object')) {\n          return strict ? actual === expected : actual == expected; // If both values are instances of typed arrays, wrap their underlying\n          // ArrayBuffers in a Buffer each to increase performance\n          // This optimization requires the arrays to have the same type as checked by\n          // Object.prototype.toString (aka pToString). Never perform binary\n          // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n          // bit patterns are not identical.\n        } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {\n          return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0; // 7.5 For all other Object pairs, including Array objects, equivalence is\n          // determined by having the same number of owned properties (as verified\n          // with Object.prototype.hasOwnProperty.call), the same set of keys\n          // (although not necessarily the same order), equivalent values for every\n          // corresponding key, and an identical 'prototype' property. Note: this\n          // accounts for both named and indexed properties on Arrays.\n        } else if (isBuffer(actual) !== isBuffer(expected)) {\n          return false;\n        } else {\n          memos = memos || {\n            actual: [],\n            expected: []\n          };\n          var actualIndex = memos.actual.indexOf(actual);\n\n          if (actualIndex !== -1) {\n            if (actualIndex === memos.expected.indexOf(expected)) {\n              return true;\n            }\n          }\n\n          memos.actual.push(actual);\n          memos.expected.push(expected);\n          return objEquiv(actual, expected, strict, memos);\n        }\n      }\n\n      function isArguments(object) {\n        return Object.prototype.toString.call(object) == '[object Arguments]';\n      }\n\n      function objEquiv(a, b, strict, actualVisitedObjects) {\n        if (a === null || a === undefined || b === null || b === undefined) return false; // if one is a primitive, the other must be same\n\n        if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;\n        if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;\n        var aIsArgs = isArguments(a);\n        var bIsArgs = isArguments(b);\n        if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;\n\n        if (aIsArgs) {\n          a = pSlice.call(a);\n          b = pSlice.call(b);\n          return _deepEqual(a, b, strict);\n        }\n\n        var ka = objectKeys(a);\n        var kb = objectKeys(b);\n        var key, i; // having the same number of owned properties (keys incorporates\n        // hasOwnProperty)\n\n        if (ka.length !== kb.length) return false; //the same set of keys (although not necessarily the same order),\n\n        ka.sort();\n        kb.sort(); //~~~cheap key test\n\n        for (i = ka.length - 1; i >= 0; i--) {\n          if (ka[i] !== kb[i]) return false;\n        } //equivalent values for every corresponding key, and\n        //~~~possibly expensive deep test\n\n\n        for (i = ka.length - 1; i >= 0; i--) {\n          key = ka[i];\n          if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;\n        }\n\n        return true;\n      } // 8. The non-equivalence assertion tests for any deep inequality.\n      // assert.notDeepEqual(actual, expected, message_opt);\n\n\n      assert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n        if (_deepEqual(actual, expected, false)) {\n          fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n        }\n      };\n\n      assert.notDeepStrictEqual = notDeepStrictEqual;\n\n      function notDeepStrictEqual(actual, expected, message) {\n        if (_deepEqual(actual, expected, true)) {\n          fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n        }\n      } // 9. The strict equality assertion tests strict equality, as determined by ===.\n      // assert.strictEqual(actual, expected, message_opt);\n\n\n      assert.strictEqual = function strictEqual(actual, expected, message) {\n        if (actual !== expected) {\n          fail(actual, expected, message, '===', assert.strictEqual);\n        }\n      }; // 10. The strict non-equality assertion tests for strict inequality, as\n      // determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\n\n      assert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n        if (actual === expected) {\n          fail(actual, expected, message, '!==', assert.notStrictEqual);\n        }\n      };\n\n      function expectedException(actual, expected) {\n        if (!actual || !expected) {\n          return false;\n        }\n\n        if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n          return expected.test(actual);\n        }\n\n        try {\n          if (actual instanceof expected) {\n            return true;\n          }\n        } catch (e) {// Ignore.  The instanceof check doesn't work for arrow functions.\n        }\n\n        if (Error.isPrototypeOf(expected)) {\n          return false;\n        }\n\n        return expected.call({}, actual) === true;\n      }\n\n      function _tryBlock(block) {\n        var error;\n\n        try {\n          block();\n        } catch (e) {\n          error = e;\n        }\n\n        return error;\n      }\n\n      function _throws(shouldThrow, block, expected, message) {\n        var actual;\n\n        if (typeof block !== 'function') {\n          throw new TypeError('\"block\" argument must be a function');\n        }\n\n        if (typeof expected === 'string') {\n          message = expected;\n          expected = null;\n        }\n\n        actual = _tryBlock(block);\n        message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');\n\n        if (shouldThrow && !actual) {\n          fail(actual, expected, 'Missing expected exception' + message);\n        }\n\n        var userProvidedMessage = typeof message === 'string';\n        var isUnwantedException = !shouldThrow && util.isError(actual);\n        var isUnexpectedException = !shouldThrow && actual && !expected;\n\n        if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {\n          fail(actual, expected, 'Got unwanted exception' + message);\n        }\n\n        if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {\n          throw actual;\n        }\n      } // 11. Expected to throw an error:\n      // assert.throws(block, Error_opt, message_opt);\n\n\n      assert.throws = function (block,\n      /*optional*/\n      error,\n      /*optional*/\n      message) {\n        _throws(true, block, error, message);\n      }; // EXTENSION! This is annoying to write outside this module.\n\n\n      assert.doesNotThrow = function (block,\n      /*optional*/\n      error,\n      /*optional*/\n      message) {\n        _throws(false, block, error, message);\n      };\n\n      assert.ifError = function (err) {\n        if (err) throw err;\n      };\n\n      var objectKeys = Object.keys || function (obj) {\n        var keys = [];\n\n        for (var key in obj) {\n          if (hasOwn.call(obj, key)) keys.push(key);\n        }\n\n        return keys;\n      };\n    }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n  }, {\n    \"util/\": 54\n  }],\n  2: [function (require, module, exports) {\n    'use strict';\n\n    exports.byteLength = byteLength;\n    exports.toByteArray = toByteArray;\n    exports.fromByteArray = fromByteArray;\n    var lookup = [];\n    var revLookup = [];\n    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n    for (var i = 0, len = code.length; i < len; ++i) {\n      lookup[i] = code[i];\n      revLookup[code.charCodeAt(i)] = i;\n    } // Support decoding URL-safe base64 strings, as Node.js does.\n    // See: https://en.wikipedia.org/wiki/Base64#URL_applications\n\n\n    revLookup['-'.charCodeAt(0)] = 62;\n    revLookup['_'.charCodeAt(0)] = 63;\n\n    function placeHoldersCount(b64) {\n      var len = b64.length;\n\n      if (len % 4 > 0) {\n        throw new Error('Invalid string. Length must be a multiple of 4');\n      } // the number of equal signs (place holders)\n      // if there are two placeholders, than the two characters before it\n      // represent one byte\n      // if there is only one, then the three characters before it represent 2 bytes\n      // this is just a cheap hack to not do indexOf twice\n\n\n      return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n    }\n\n    function byteLength(b64) {\n      // base64 is 4/3 + up to two characters of the original data\n      return b64.length * 3 / 4 - placeHoldersCount(b64);\n    }\n\n    function toByteArray(b64) {\n      var i, l, tmp, placeHolders, arr;\n      var len = b64.length;\n      placeHolders = placeHoldersCount(b64);\n      arr = new Arr(len * 3 / 4 - placeHolders); // if there are placeholders, only get up to the last complete 4 chars\n\n      l = placeHolders > 0 ? len - 4 : len;\n      var L = 0;\n\n      for (i = 0; i < l; i += 4) {\n        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n        arr[L++] = tmp >> 16 & 0xFF;\n        arr[L++] = tmp >> 8 & 0xFF;\n        arr[L++] = tmp & 0xFF;\n      }\n\n      if (placeHolders === 2) {\n        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n        arr[L++] = tmp & 0xFF;\n      } else if (placeHolders === 1) {\n        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n        arr[L++] = tmp >> 8 & 0xFF;\n        arr[L++] = tmp & 0xFF;\n      }\n\n      return arr;\n    }\n\n    function tripletToBase64(num) {\n      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n    }\n\n    function encodeChunk(uint8, start, end) {\n      var tmp;\n      var output = [];\n\n      for (var i = start; i < end; i += 3) {\n        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n        output.push(tripletToBase64(tmp));\n      }\n\n      return output.join('');\n    }\n\n    function fromByteArray(uint8) {\n      var tmp;\n      var len = uint8.length;\n      var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\n      var output = '';\n      var parts = [];\n      var maxChunkLength = 16383; // must be multiple of 3\n      // go through the array every three bytes, we'll deal with trailing stuff later\n\n      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n      } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n      if (extraBytes === 1) {\n        tmp = uint8[len - 1];\n        output += lookup[tmp >> 2];\n        output += lookup[tmp << 4 & 0x3F];\n        output += '==';\n      } else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n        output += lookup[tmp >> 10];\n        output += lookup[tmp >> 4 & 0x3F];\n        output += lookup[tmp << 2 & 0x3F];\n        output += '=';\n      }\n\n      parts.push(output);\n      return parts.join('');\n    }\n  }, {}],\n  3: [function (require, module, exports) {}, {}],\n  4: [function (require, module, exports) {\n    arguments[4][3][0].apply(exports, arguments);\n  }, {\n    \"dup\": 3\n  }],\n  5: [function (require, module, exports) {\n    // Copyright Joyent, Inc. and other Node contributors.\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a\n    // copy of this software and associated documentation files (the\n    // \"Software\"), to deal in the Software without restriction, including\n    // without limitation the rights to use, copy, modify, merge, publish,\n    // distribute, sublicense, and/or sell copies of the Software, and to permit\n    // persons to whom the Software is furnished to do so, subject to the\n    // following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included\n    // in all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n    // USE OR OTHER DEALINGS IN THE SOFTWARE.\n    var Buffer = require('buffer').Buffer;\n\n    var isBufferEncoding = Buffer.isEncoding || function (encoding) {\n      switch (encoding && encoding.toLowerCase()) {\n        case 'hex':\n        case 'utf8':\n        case 'utf-8':\n        case 'ascii':\n        case 'binary':\n        case 'base64':\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n        case 'raw':\n          return true;\n\n        default:\n          return false;\n      }\n    };\n\n    function assertEncoding(encoding) {\n      if (encoding && !isBufferEncoding(encoding)) {\n        throw new Error('Unknown encoding: ' + encoding);\n      }\n    } // StringDecoder provides an interface for efficiently splitting a series of\n    // buffers into a series of JS strings without breaking apart multi-byte\n    // characters. CESU-8 is handled as part of the UTF-8 encoding.\n    //\n    // @TODO Handling all encodings inside a single object makes it very difficult\n    // to reason about this code, so it should be split up in the future.\n    // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n    // points as used by CESU-8.\n\n\n    var StringDecoder = exports.StringDecoder = function (encoding) {\n      this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n      assertEncoding(encoding);\n\n      switch (this.encoding) {\n        case 'utf8':\n          // CESU-8 represents each of Surrogate Pair by 3-bytes\n          this.surrogateSize = 3;\n          break;\n\n        case 'ucs2':\n        case 'utf16le':\n          // UTF-16 represents each of Surrogate Pair by 2-bytes\n          this.surrogateSize = 2;\n          this.detectIncompleteChar = utf16DetectIncompleteChar;\n          break;\n\n        case 'base64':\n          // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n          this.surrogateSize = 3;\n          this.detectIncompleteChar = base64DetectIncompleteChar;\n          break;\n\n        default:\n          this.write = passThroughWrite;\n          return;\n      } // Enough space to store all bytes of a single character. UTF-8 needs 4\n      // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n\n\n      this.charBuffer = new Buffer(6); // Number of bytes received for the current incomplete multi-byte character.\n\n      this.charReceived = 0; // Number of bytes expected for the current incomplete multi-byte character.\n\n      this.charLength = 0;\n    }; // write decodes the given buffer and returns it as JS string that is\n    // guaranteed to not contain any partial multi-byte characters. Any partial\n    // character found at the end of the buffer is buffered up, and will be\n    // returned when calling write again with the remaining bytes.\n    //\n    // Note: Converting a Buffer containing an orphan surrogate to a String\n    // currently works, but converting a String to a Buffer (via `new Buffer`, or\n    // Buffer#write) will replace incomplete surrogates with the unicode\n    // replacement character. See https://codereview.chromium.org/121173009/ .\n\n\n    StringDecoder.prototype.write = function (buffer) {\n      var charStr = ''; // if our last write ended with an incomplete multibyte character\n\n      while (this.charLength) {\n        // determine how many remaining bytes this buffer has to offer for this char\n        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length; // add the new bytes to the char buffer\n\n        buffer.copy(this.charBuffer, this.charReceived, 0, available);\n        this.charReceived += available;\n\n        if (this.charReceived < this.charLength) {\n          // still not enough chars in this buffer? wait for more ...\n          return '';\n        } // remove bytes belonging to the current character from the buffer\n\n\n        buffer = buffer.slice(available, buffer.length); // get the character that was split\n\n        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding); // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n\n        var charCode = charStr.charCodeAt(charStr.length - 1);\n\n        if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n          this.charLength += this.surrogateSize;\n          charStr = '';\n          continue;\n        }\n\n        this.charReceived = this.charLength = 0; // if there are no more bytes in this buffer, just emit our char\n\n        if (buffer.length === 0) {\n          return charStr;\n        }\n\n        break;\n      } // determine and set charLength / charReceived\n\n\n      this.detectIncompleteChar(buffer);\n      var end = buffer.length;\n\n      if (this.charLength) {\n        // buffer the incomplete character bytes we got\n        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n        end -= this.charReceived;\n      }\n\n      charStr += buffer.toString(this.encoding, 0, end);\n      var end = charStr.length - 1;\n      var charCode = charStr.charCodeAt(end); // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n\n      if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n        var size = this.surrogateSize;\n        this.charLength += size;\n        this.charReceived += size;\n        this.charBuffer.copy(this.charBuffer, size, 0, size);\n        buffer.copy(this.charBuffer, 0, 0, size);\n        return charStr.substring(0, end);\n      } // or just emit the charStr\n\n\n      return charStr;\n    }; // detectIncompleteChar determines if there is an incomplete UTF-8 character at\n    // the end of the given buffer. If so, it sets this.charLength to the byte\n    // length that character, and sets this.charReceived to the number of bytes\n    // that are available for this character.\n\n\n    StringDecoder.prototype.detectIncompleteChar = function (buffer) {\n      // determine how many bytes we have to check at the end of this buffer\n      var i = buffer.length >= 3 ? 3 : buffer.length; // Figure out if one of the last i bytes of our buffer announces an\n      // incomplete char.\n\n      for (; i > 0; i--) {\n        var c = buffer[buffer.length - i]; // See http://en.wikipedia.org/wiki/UTF-8#Description\n        // 110XXXXX\n\n        if (i == 1 && c >> 5 == 0x06) {\n          this.charLength = 2;\n          break;\n        } // 1110XXXX\n\n\n        if (i <= 2 && c >> 4 == 0x0E) {\n          this.charLength = 3;\n          break;\n        } // 11110XXX\n\n\n        if (i <= 3 && c >> 3 == 0x1E) {\n          this.charLength = 4;\n          break;\n        }\n      }\n\n      this.charReceived = i;\n    };\n\n    StringDecoder.prototype.end = function (buffer) {\n      var res = '';\n      if (buffer && buffer.length) res = this.write(buffer);\n\n      if (this.charReceived) {\n        var cr = this.charReceived;\n        var buf = this.charBuffer;\n        var enc = this.encoding;\n        res += buf.slice(0, cr).toString(enc);\n      }\n\n      return res;\n    };\n\n    function passThroughWrite(buffer) {\n      return buffer.toString(this.encoding);\n    }\n\n    function utf16DetectIncompleteChar(buffer) {\n      this.charReceived = buffer.length % 2;\n      this.charLength = this.charReceived ? 2 : 0;\n    }\n\n    function base64DetectIncompleteChar(buffer) {\n      this.charReceived = buffer.length % 3;\n      this.charLength = this.charReceived ? 3 : 0;\n    }\n  }, {\n    \"buffer\": 6\n  }],\n  6: [function (require, module, exports) {\n    (function (global) {\n      /*!\n       * The buffer module from node.js, for the browser.\n       *\n       * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n       * @license  MIT\n       */\n\n      /* eslint-disable no-proto */\n      'use strict';\n\n      var base64 = require('base64-js');\n\n      var ieee754 = require('ieee754');\n\n      var isArray = require('isarray');\n\n      exports.Buffer = Buffer;\n      exports.SlowBuffer = SlowBuffer;\n      exports.INSPECT_MAX_BYTES = 50;\n      /**\n       * If `Buffer.TYPED_ARRAY_SUPPORT`:\n       *   === true    Use Uint8Array implementation (fastest)\n       *   === false   Use Object implementation (most compatible, even IE6)\n       *\n       * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n       * Opera 11.6+, iOS 4.2+.\n       *\n       * Due to various browser bugs, sometimes the Object implementation will be used even\n       * when the browser supports typed arrays.\n       *\n       * Note:\n       *\n       *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n       *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n       *\n       *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n       *\n       *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n       *     incorrect length in some situations.\n      \n       * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n       * get the Object implementation, which is slower but behaves correctly.\n       */\n\n      Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();\n      /*\n       * Export kMaxLength after typed array support is determined.\n       */\n\n      exports.kMaxLength = kMaxLength();\n\n      function typedArraySupport() {\n        try {\n          var arr = new Uint8Array(1);\n          arr.__proto__ = {\n            __proto__: Uint8Array.prototype,\n            foo: function () {\n              return 42;\n            }\n          };\n          return arr.foo() === 42 && // typed array instances can be augmented\n          typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n          arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`\n        } catch (e) {\n          return false;\n        }\n      }\n\n      function kMaxLength() {\n        return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;\n      }\n\n      function createBuffer(that, length) {\n        if (kMaxLength() < length) {\n          throw new RangeError('Invalid typed array length');\n        }\n\n        if (Buffer.TYPED_ARRAY_SUPPORT) {\n          // Return an augmented `Uint8Array` instance, for best performance\n          that = new Uint8Array(length);\n          that.__proto__ = Buffer.prototype;\n        } else {\n          // Fallback: Return an object instance of the Buffer class\n          if (that === null) {\n            that = new Buffer(length);\n          }\n\n          that.length = length;\n        }\n\n        return that;\n      }\n      /**\n       * The Buffer constructor returns instances of `Uint8Array` that have their\n       * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n       * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n       * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n       * returns a single octet.\n       *\n       * The `Uint8Array` prototype remains unmodified.\n       */\n\n\n      function Buffer(arg, encodingOrOffset, length) {\n        if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n          return new Buffer(arg, encodingOrOffset, length);\n        } // Common case.\n\n\n        if (typeof arg === 'number') {\n          if (typeof encodingOrOffset === 'string') {\n            throw new Error('If encoding is specified then the first argument must be a string');\n          }\n\n          return allocUnsafe(this, arg);\n        }\n\n        return from(this, arg, encodingOrOffset, length);\n      }\n\n      Buffer.poolSize = 8192; // not used by this implementation\n      // TODO: Legacy, not needed anymore. Remove in next major version.\n\n      Buffer._augment = function (arr) {\n        arr.__proto__ = Buffer.prototype;\n        return arr;\n      };\n\n      function from(that, value, encodingOrOffset, length) {\n        if (typeof value === 'number') {\n          throw new TypeError('\"value\" argument must not be a number');\n        }\n\n        if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n          return fromArrayBuffer(that, value, encodingOrOffset, length);\n        }\n\n        if (typeof value === 'string') {\n          return fromString(that, value, encodingOrOffset);\n        }\n\n        return fromObject(that, value);\n      }\n      /**\n       * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n       * if value is a number.\n       * Buffer.from(str[, encoding])\n       * Buffer.from(array)\n       * Buffer.from(buffer)\n       * Buffer.from(arrayBuffer[, byteOffset[, length]])\n       **/\n\n\n      Buffer.from = function (value, encodingOrOffset, length) {\n        return from(null, value, encodingOrOffset, length);\n      };\n\n      if (Buffer.TYPED_ARRAY_SUPPORT) {\n        Buffer.prototype.__proto__ = Uint8Array.prototype;\n        Buffer.__proto__ = Uint8Array;\n\n        if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {\n          // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n          Object.defineProperty(Buffer, Symbol.species, {\n            value: null,\n            configurable: true\n          });\n        }\n      }\n\n      function assertSize(size) {\n        if (typeof size !== 'number') {\n          throw new TypeError('\"size\" argument must be a number');\n        } else if (size < 0) {\n          throw new RangeError('\"size\" argument must not be negative');\n        }\n      }\n\n      function alloc(that, size, fill, encoding) {\n        assertSize(size);\n\n        if (size <= 0) {\n          return createBuffer(that, size);\n        }\n\n        if (fill !== undefined) {\n          // Only pay attention to encoding if it's a string. This\n          // prevents accidentally sending in a number that would\n          // be interpretted as a start offset.\n          return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n        }\n\n        return createBuffer(that, size);\n      }\n      /**\n       * Creates a new filled Buffer instance.\n       * alloc(size[, fill[, encoding]])\n       **/\n\n\n      Buffer.alloc = function (size, fill, encoding) {\n        return alloc(null, size, fill, encoding);\n      };\n\n      function allocUnsafe(that, size) {\n        assertSize(size);\n        that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n\n        if (!Buffer.TYPED_ARRAY_SUPPORT) {\n          for (var i = 0; i < size; ++i) {\n            that[i] = 0;\n          }\n        }\n\n        return that;\n      }\n      /**\n       * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n       * */\n\n\n      Buffer.allocUnsafe = function (size) {\n        return allocUnsafe(null, size);\n      };\n      /**\n       * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n       */\n\n\n      Buffer.allocUnsafeSlow = function (size) {\n        return allocUnsafe(null, size);\n      };\n\n      function fromString(that, string, encoding) {\n        if (typeof encoding !== 'string' || encoding === '') {\n          encoding = 'utf8';\n        }\n\n        if (!Buffer.isEncoding(encoding)) {\n          throw new TypeError('\"encoding\" must be a valid string encoding');\n        }\n\n        var length = byteLength(string, encoding) | 0;\n        that = createBuffer(that, length);\n        var actual = that.write(string, encoding);\n\n        if (actual !== length) {\n          // Writing a hex string, for example, that contains invalid characters will\n          // cause everything after the first invalid character to be ignored. (e.g.\n          // 'abxxcd' will be treated as 'ab')\n          that = that.slice(0, actual);\n        }\n\n        return that;\n      }\n\n      function fromArrayLike(that, array) {\n        var length = array.length < 0 ? 0 : checked(array.length) | 0;\n        that = createBuffer(that, length);\n\n        for (var i = 0; i < length; i += 1) {\n          that[i] = array[i] & 255;\n        }\n\n        return that;\n      }\n\n      function fromArrayBuffer(that, array, byteOffset, length) {\n        array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n        if (byteOffset < 0 || array.byteLength < byteOffset) {\n          throw new RangeError('\\'offset\\' is out of bounds');\n        }\n\n        if (array.byteLength < byteOffset + (length || 0)) {\n          throw new RangeError('\\'length\\' is out of bounds');\n        }\n\n        if (byteOffset === undefined && length === undefined) {\n          array = new Uint8Array(array);\n        } else if (length === undefined) {\n          array = new Uint8Array(array, byteOffset);\n        } else {\n          array = new Uint8Array(array, byteOffset, length);\n        }\n\n        if (Buffer.TYPED_ARRAY_SUPPORT) {\n          // Return an augmented `Uint8Array` instance, for best performance\n          that = array;\n          that.__proto__ = Buffer.prototype;\n        } else {\n          // Fallback: Return an object instance of the Buffer class\n          that = fromArrayLike(that, array);\n        }\n\n        return that;\n      }\n\n      function fromObject(that, obj) {\n        if (Buffer.isBuffer(obj)) {\n          var len = checked(obj.length) | 0;\n          that = createBuffer(that, len);\n\n          if (that.length === 0) {\n            return that;\n          }\n\n          obj.copy(that, 0, 0, len);\n          return that;\n        }\n\n        if (obj) {\n          if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {\n            if (typeof obj.length !== 'number' || isnan(obj.length)) {\n              return createBuffer(that, 0);\n            }\n\n            return fromArrayLike(that, obj);\n          }\n\n          if (obj.type === 'Buffer' && isArray(obj.data)) {\n            return fromArrayLike(that, obj.data);\n          }\n        }\n\n        throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n      }\n\n      function checked(length) {\n        // Note: cannot use `length < kMaxLength()` here because that fails when\n        // length is NaN (which is otherwise coerced to zero.)\n        if (length >= kMaxLength()) {\n          throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');\n        }\n\n        return length | 0;\n      }\n\n      function SlowBuffer(length) {\n        if (+length != length) {\n          // eslint-disable-line eqeqeq\n          length = 0;\n        }\n\n        return Buffer.alloc(+length);\n      }\n\n      Buffer.isBuffer = function isBuffer(b) {\n        return !!(b != null && b._isBuffer);\n      };\n\n      Buffer.compare = function compare(a, b) {\n        if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n          throw new TypeError('Arguments must be Buffers');\n        }\n\n        if (a === b) return 0;\n        var x = a.length;\n        var y = b.length;\n\n        for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n          if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n          }\n        }\n\n        if (x < y) return -1;\n        if (y < x) return 1;\n        return 0;\n      };\n\n      Buffer.isEncoding = function isEncoding(encoding) {\n        switch (String(encoding).toLowerCase()) {\n          case 'hex':\n          case 'utf8':\n          case 'utf-8':\n          case 'ascii':\n          case 'latin1':\n          case 'binary':\n          case 'base64':\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            return true;\n\n          default:\n            return false;\n        }\n      };\n\n      Buffer.concat = function concat(list, length) {\n        if (!isArray(list)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n\n        if (list.length === 0) {\n          return Buffer.alloc(0);\n        }\n\n        var i;\n\n        if (length === undefined) {\n          length = 0;\n\n          for (i = 0; i < list.length; ++i) {\n            length += list[i].length;\n          }\n        }\n\n        var buffer = Buffer.allocUnsafe(length);\n        var pos = 0;\n\n        for (i = 0; i < list.length; ++i) {\n          var buf = list[i];\n\n          if (!Buffer.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          }\n\n          buf.copy(buffer, pos);\n          pos += buf.length;\n        }\n\n        return buffer;\n      };\n\n      function byteLength(string, encoding) {\n        if (Buffer.isBuffer(string)) {\n          return string.length;\n        }\n\n        if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n          return string.byteLength;\n        }\n\n        if (typeof string !== 'string') {\n          string = '' + string;\n        }\n\n        var len = string.length;\n        if (len === 0) return 0; // Use a for loop to avoid recursion\n\n        var loweredCase = false;\n\n        for (;;) {\n          switch (encoding) {\n            case 'ascii':\n            case 'latin1':\n            case 'binary':\n              return len;\n\n            case 'utf8':\n            case 'utf-8':\n            case undefined:\n              return utf8ToBytes(string).length;\n\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n              return len * 2;\n\n            case 'hex':\n              return len >>> 1;\n\n            case 'base64':\n              return base64ToBytes(string).length;\n\n            default:\n              if (loweredCase) return utf8ToBytes(string).length; // assume utf8\n\n              encoding = ('' + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      }\n\n      Buffer.byteLength = byteLength;\n\n      function slowToString(encoding, start, end) {\n        var loweredCase = false; // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n        // property of a typed array.\n        // This behaves neither like String nor Uint8Array in that we set start/end\n        // to their upper/lower bounds if the value passed is out of range.\n        // undefined is handled specially as per ECMA-262 6th Edition,\n        // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\n        if (start === undefined || start < 0) {\n          start = 0;\n        } // Return early if start > this.length. Done here to prevent potential uint32\n        // coercion fail below.\n\n\n        if (start > this.length) {\n          return '';\n        }\n\n        if (end === undefined || end > this.length) {\n          end = this.length;\n        }\n\n        if (end <= 0) {\n          return '';\n        } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\n\n        end >>>= 0;\n        start >>>= 0;\n\n        if (end <= start) {\n          return '';\n        }\n\n        if (!encoding) encoding = 'utf8';\n\n        while (true) {\n          switch (encoding) {\n            case 'hex':\n              return hexSlice(this, start, end);\n\n            case 'utf8':\n            case 'utf-8':\n              return utf8Slice(this, start, end);\n\n            case 'ascii':\n              return asciiSlice(this, start, end);\n\n            case 'latin1':\n            case 'binary':\n              return latin1Slice(this, start, end);\n\n            case 'base64':\n              return base64Slice(this, start, end);\n\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n              return utf16leSlice(this, start, end);\n\n            default:\n              if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n              encoding = (encoding + '').toLowerCase();\n              loweredCase = true;\n          }\n        }\n      } // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n      // Buffer instances.\n\n\n      Buffer.prototype._isBuffer = true;\n\n      function swap(b, n, m) {\n        var i = b[n];\n        b[n] = b[m];\n        b[m] = i;\n      }\n\n      Buffer.prototype.swap16 = function swap16() {\n        var len = this.length;\n\n        if (len % 2 !== 0) {\n          throw new RangeError('Buffer size must be a multiple of 16-bits');\n        }\n\n        for (var i = 0; i < len; i += 2) {\n          swap(this, i, i + 1);\n        }\n\n        return this;\n      };\n\n      Buffer.prototype.swap32 = function swap32() {\n        var len = this.length;\n\n        if (len % 4 !== 0) {\n          throw new RangeError('Buffer size must be a multiple of 32-bits');\n        }\n\n        for (var i = 0; i < len; i += 4) {\n          swap(this, i, i + 3);\n          swap(this, i + 1, i + 2);\n        }\n\n        return this;\n      };\n\n      Buffer.prototype.swap64 = function swap64() {\n        var len = this.length;\n\n        if (len % 8 !== 0) {\n          throw new RangeError('Buffer size must be a multiple of 64-bits');\n        }\n\n        for (var i = 0; i < len; i += 8) {\n          swap(this, i, i + 7);\n          swap(this, i + 1, i + 6);\n          swap(this, i + 2, i + 5);\n          swap(this, i + 3, i + 4);\n        }\n\n        return this;\n      };\n\n      Buffer.prototype.toString = function toString() {\n        var length = this.length | 0;\n        if (length === 0) return '';\n        if (arguments.length === 0) return utf8Slice(this, 0, length);\n        return slowToString.apply(this, arguments);\n      };\n\n      Buffer.prototype.equals = function equals(b) {\n        if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n        if (this === b) return true;\n        return Buffer.compare(this, b) === 0;\n      };\n\n      Buffer.prototype.inspect = function inspect() {\n        var str = '';\n        var max = exports.INSPECT_MAX_BYTES;\n\n        if (this.length > 0) {\n          str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n          if (this.length > max) str += ' ... ';\n        }\n\n        return '<Buffer ' + str + '>';\n      };\n\n      Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n        if (!Buffer.isBuffer(target)) {\n          throw new TypeError('Argument must be a Buffer');\n        }\n\n        if (start === undefined) {\n          start = 0;\n        }\n\n        if (end === undefined) {\n          end = target ? target.length : 0;\n        }\n\n        if (thisStart === undefined) {\n          thisStart = 0;\n        }\n\n        if (thisEnd === undefined) {\n          thisEnd = this.length;\n        }\n\n        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n          throw new RangeError('out of range index');\n        }\n\n        if (thisStart >= thisEnd && start >= end) {\n          return 0;\n        }\n\n        if (thisStart >= thisEnd) {\n          return -1;\n        }\n\n        if (start >= end) {\n          return 1;\n        }\n\n        start >>>= 0;\n        end >>>= 0;\n        thisStart >>>= 0;\n        thisEnd >>>= 0;\n        if (this === target) return 0;\n        var x = thisEnd - thisStart;\n        var y = end - start;\n        var len = Math.min(x, y);\n        var thisCopy = this.slice(thisStart, thisEnd);\n        var targetCopy = target.slice(start, end);\n\n        for (var i = 0; i < len; ++i) {\n          if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n          }\n        }\n\n        if (x < y) return -1;\n        if (y < x) return 1;\n        return 0;\n      }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n      // OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n      //\n      // Arguments:\n      // - buffer - a Buffer to search\n      // - val - a string, Buffer, or number\n      // - byteOffset - an index into `buffer`; will be clamped to an int32\n      // - encoding - an optional encoding, relevant is val is a string\n      // - dir - true for indexOf, false for lastIndexOf\n\n\n      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n        // Empty buffer means no match\n        if (buffer.length === 0) return -1; // Normalize byteOffset\n\n        if (typeof byteOffset === 'string') {\n          encoding = byteOffset;\n          byteOffset = 0;\n        } else if (byteOffset > 0x7fffffff) {\n          byteOffset = 0x7fffffff;\n        } else if (byteOffset < -0x80000000) {\n          byteOffset = -0x80000000;\n        }\n\n        byteOffset = +byteOffset; // Coerce to Number.\n\n        if (isNaN(byteOffset)) {\n          // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n          byteOffset = dir ? 0 : buffer.length - 1;\n        } // Normalize byteOffset: negative offsets start from the end of the buffer\n\n\n        if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\n        if (byteOffset >= buffer.length) {\n          if (dir) return -1;else byteOffset = buffer.length - 1;\n        } else if (byteOffset < 0) {\n          if (dir) byteOffset = 0;else return -1;\n        } // Normalize val\n\n\n        if (typeof val === 'string') {\n          val = Buffer.from(val, encoding);\n        } // Finally, search either indexOf (if dir is true) or lastIndexOf\n\n\n        if (Buffer.isBuffer(val)) {\n          // Special case: looking for empty string/buffer always fails\n          if (val.length === 0) {\n            return -1;\n          }\n\n          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n        } else if (typeof val === 'number') {\n          val = val & 0xFF; // Search for a byte value [0-255]\n\n          if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {\n            if (dir) {\n              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n          }\n\n          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n        }\n\n        throw new TypeError('val must be string, number or Buffer');\n      }\n\n      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n        var indexSize = 1;\n        var arrLength = arr.length;\n        var valLength = val.length;\n\n        if (encoding !== undefined) {\n          encoding = String(encoding).toLowerCase();\n\n          if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n            if (arr.length < 2 || val.length < 2) {\n              return -1;\n            }\n\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n          }\n        }\n\n        function read(buf, i) {\n          if (indexSize === 1) {\n            return buf[i];\n          } else {\n            return buf.readUInt16BE(i * indexSize);\n          }\n        }\n\n        var i;\n\n        if (dir) {\n          var foundIndex = -1;\n\n          for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n              if (foundIndex === -1) foundIndex = i;\n              if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n            } else {\n              if (foundIndex !== -1) i -= i - foundIndex;\n              foundIndex = -1;\n            }\n          }\n        } else {\n          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\n          for (i = byteOffset; i >= 0; i--) {\n            var found = true;\n\n            for (var j = 0; j < valLength; j++) {\n              if (read(arr, i + j) !== read(val, j)) {\n                found = false;\n                break;\n              }\n            }\n\n            if (found) return i;\n          }\n        }\n\n        return -1;\n      }\n\n      Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n        return this.indexOf(val, byteOffset, encoding) !== -1;\n      };\n\n      Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n      };\n\n      Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n      };\n\n      function hexWrite(buf, string, offset, length) {\n        offset = Number(offset) || 0;\n        var remaining = buf.length - offset;\n\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n\n          if (length > remaining) {\n            length = remaining;\n          }\n        } // must be an even number of digits\n\n\n        var strLen = string.length;\n        if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');\n\n        if (length > strLen / 2) {\n          length = strLen / 2;\n        }\n\n        for (var i = 0; i < length; ++i) {\n          var parsed = parseInt(string.substr(i * 2, 2), 16);\n          if (isNaN(parsed)) return i;\n          buf[offset + i] = parsed;\n        }\n\n        return i;\n      }\n\n      function utf8Write(buf, string, offset, length) {\n        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n      }\n\n      function asciiWrite(buf, string, offset, length) {\n        return blitBuffer(asciiToBytes(string), buf, offset, length);\n      }\n\n      function latin1Write(buf, string, offset, length) {\n        return asciiWrite(buf, string, offset, length);\n      }\n\n      function base64Write(buf, string, offset, length) {\n        return blitBuffer(base64ToBytes(string), buf, offset, length);\n      }\n\n      function ucs2Write(buf, string, offset, length) {\n        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n      }\n\n      Buffer.prototype.write = function write(string, offset, length, encoding) {\n        // Buffer#write(string)\n        if (offset === undefined) {\n          encoding = 'utf8';\n          length = this.length;\n          offset = 0; // Buffer#write(string, encoding)\n        } else if (length === undefined && typeof offset === 'string') {\n          encoding = offset;\n          length = this.length;\n          offset = 0; // Buffer#write(string, offset[, length][, encoding])\n        } else if (isFinite(offset)) {\n          offset = offset | 0;\n\n          if (isFinite(length)) {\n            length = length | 0;\n            if (encoding === undefined) encoding = 'utf8';\n          } else {\n            encoding = length;\n            length = undefined;\n          } // legacy write(string, encoding, offset, length) - remove in v0.13\n\n        } else {\n          throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n        }\n\n        var remaining = this.length - offset;\n        if (length === undefined || length > remaining) length = remaining;\n\n        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n          throw new RangeError('Attempt to write outside buffer bounds');\n        }\n\n        if (!encoding) encoding = 'utf8';\n        var loweredCase = false;\n\n        for (;;) {\n          switch (encoding) {\n            case 'hex':\n              return hexWrite(this, string, offset, length);\n\n            case 'utf8':\n            case 'utf-8':\n              return utf8Write(this, string, offset, length);\n\n            case 'ascii':\n              return asciiWrite(this, string, offset, length);\n\n            case 'latin1':\n            case 'binary':\n              return latin1Write(this, string, offset, length);\n\n            case 'base64':\n              // Warning: maxLength not taken into account in base64Write\n              return base64Write(this, string, offset, length);\n\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n              return ucs2Write(this, string, offset, length);\n\n            default:\n              if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n              encoding = ('' + encoding).toLowerCase();\n              loweredCase = true;\n          }\n        }\n      };\n\n      Buffer.prototype.toJSON = function toJSON() {\n        return {\n          type: 'Buffer',\n          data: Array.prototype.slice.call(this._arr || this, 0)\n        };\n      };\n\n      function base64Slice(buf, start, end) {\n        if (start === 0 && end === buf.length) {\n          return base64.fromByteArray(buf);\n        } else {\n          return base64.fromByteArray(buf.slice(start, end));\n        }\n      }\n\n      function utf8Slice(buf, start, end) {\n        end = Math.min(buf.length, end);\n        var res = [];\n        var i = start;\n\n        while (i < end) {\n          var firstByte = buf[i];\n          var codePoint = null;\n          var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n\n          if (i + bytesPerSequence <= end) {\n            var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n            switch (bytesPerSequence) {\n              case 1:\n                if (firstByte < 0x80) {\n                  codePoint = firstByte;\n                }\n\n                break;\n\n              case 2:\n                secondByte = buf[i + 1];\n\n                if ((secondByte & 0xC0) === 0x80) {\n                  tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n\n                  if (tempCodePoint > 0x7F) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n\n                break;\n\n              case 3:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n\n                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                  tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n\n                  if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n\n                break;\n\n              case 4:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                fourthByte = buf[i + 3];\n\n                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                  tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n\n                  if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n\n            }\n          }\n\n          if (codePoint === null) {\n            // we did not generate a valid codePoint so insert a\n            // replacement char (U+FFFD) and advance only 1 byte\n            codePoint = 0xFFFD;\n            bytesPerSequence = 1;\n          } else if (codePoint > 0xFFFF) {\n            // encode to utf16 (surrogate pair dance)\n            codePoint -= 0x10000;\n            res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n            codePoint = 0xDC00 | codePoint & 0x3FF;\n          }\n\n          res.push(codePoint);\n          i += bytesPerSequence;\n        }\n\n        return decodeCodePointsArray(res);\n      } // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n      // the lowest limit is Chrome, with 0x10000 args.\n      // We go 1 magnitude less, for safety\n\n\n      var MAX_ARGUMENTS_LENGTH = 0x1000;\n\n      function decodeCodePointsArray(codePoints) {\n        var len = codePoints.length;\n\n        if (len <= MAX_ARGUMENTS_LENGTH) {\n          return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n        } // Decode in chunks to avoid \"call stack size exceeded\".\n\n\n        var res = '';\n        var i = 0;\n\n        while (i < len) {\n          res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n        }\n\n        return res;\n      }\n\n      function asciiSlice(buf, start, end) {\n        var ret = '';\n        end = Math.min(buf.length, end);\n\n        for (var i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i] & 0x7F);\n        }\n\n        return ret;\n      }\n\n      function latin1Slice(buf, start, end) {\n        var ret = '';\n        end = Math.min(buf.length, end);\n\n        for (var i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i]);\n        }\n\n        return ret;\n      }\n\n      function hexSlice(buf, start, end) {\n        var len = buf.length;\n        if (!start || start < 0) start = 0;\n        if (!end || end < 0 || end > len) end = len;\n        var out = '';\n\n        for (var i = start; i < end; ++i) {\n          out += toHex(buf[i]);\n        }\n\n        return out;\n      }\n\n      function utf16leSlice(buf, start, end) {\n        var bytes = buf.slice(start, end);\n        var res = '';\n\n        for (var i = 0; i < bytes.length; i += 2) {\n          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n        }\n\n        return res;\n      }\n\n      Buffer.prototype.slice = function slice(start, end) {\n        var len = this.length;\n        start = ~~start;\n        end = end === undefined ? len : ~~end;\n\n        if (start < 0) {\n          start += len;\n          if (start < 0) start = 0;\n        } else if (start > len) {\n          start = len;\n        }\n\n        if (end < 0) {\n          end += len;\n          if (end < 0) end = 0;\n        } else if (end > len) {\n          end = len;\n        }\n\n        if (end < start) end = start;\n        var newBuf;\n\n        if (Buffer.TYPED_ARRAY_SUPPORT) {\n          newBuf = this.subarray(start, end);\n          newBuf.__proto__ = Buffer.prototype;\n        } else {\n          var sliceLen = end - start;\n          newBuf = new Buffer(sliceLen, undefined);\n\n          for (var i = 0; i < sliceLen; ++i) {\n            newBuf[i] = this[i + start];\n          }\n        }\n\n        return newBuf;\n      };\n      /*\n       * Need to make sure that buffer isn't trying to write out of bounds.\n       */\n\n\n      function checkOffset(offset, ext, length) {\n        if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n        if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n      }\n\n      Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n        offset = offset | 0;\n        byteLength = byteLength | 0;\n        if (!noAssert) checkOffset(offset, byteLength, this.length);\n        var val = this[offset];\n        var mul = 1;\n        var i = 0;\n\n        while (++i < byteLength && (mul *= 0x100)) {\n          val += this[offset + i] * mul;\n        }\n\n        return val;\n      };\n\n      Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n        offset = offset | 0;\n        byteLength = byteLength | 0;\n\n        if (!noAssert) {\n          checkOffset(offset, byteLength, this.length);\n        }\n\n        var val = this[offset + --byteLength];\n        var mul = 1;\n\n        while (byteLength > 0 && (mul *= 0x100)) {\n          val += this[offset + --byteLength] * mul;\n        }\n\n        return val;\n      };\n\n      Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n        if (!noAssert) checkOffset(offset, 1, this.length);\n        return this[offset];\n      };\n\n      Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n        if (!noAssert) checkOffset(offset, 2, this.length);\n        return this[offset] | this[offset + 1] << 8;\n      };\n\n      Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n        if (!noAssert) checkOffset(offset, 2, this.length);\n        return this[offset] << 8 | this[offset + 1];\n      };\n\n      Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n        if (!noAssert) checkOffset(offset, 4, this.length);\n        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n      };\n\n      Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n        if (!noAssert) checkOffset(offset, 4, this.length);\n        return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n      };\n\n      Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n        offset = offset | 0;\n        byteLength = byteLength | 0;\n        if (!noAssert) checkOffset(offset, byteLength, this.length);\n        var val = this[offset];\n        var mul = 1;\n        var i = 0;\n\n        while (++i < byteLength && (mul *= 0x100)) {\n          val += this[offset + i] * mul;\n        }\n\n        mul *= 0x80;\n        if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n        return val;\n      };\n\n      Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n        offset = offset | 0;\n        byteLength = byteLength | 0;\n        if (!noAssert) checkOffset(offset, byteLength, this.length);\n        var i = byteLength;\n        var mul = 1;\n        var val = this[offset + --i];\n\n        while (i > 0 && (mul *= 0x100)) {\n          val += this[offset + --i] * mul;\n        }\n\n        mul *= 0x80;\n        if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n        return val;\n      };\n\n      Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n        if (!noAssert) checkOffset(offset, 1, this.length);\n        if (!(this[offset] & 0x80)) return this[offset];\n        return (0xff - this[offset] + 1) * -1;\n      };\n\n      Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n        if (!noAssert) checkOffset(offset, 2, this.length);\n        var val = this[offset] | this[offset + 1] << 8;\n        return val & 0x8000 ? val | 0xFFFF0000 : val;\n      };\n\n      Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n        if (!noAssert) checkOffset(offset, 2, this.length);\n        var val = this[offset + 1] | this[offset] << 8;\n        return val & 0x8000 ? val | 0xFFFF0000 : val;\n      };\n\n      Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n        if (!noAssert) checkOffset(offset, 4, this.length);\n        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n      };\n\n      Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n        if (!noAssert) checkOffset(offset, 4, this.length);\n        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n      };\n\n      Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n        if (!noAssert) checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, true, 23, 4);\n      };\n\n      Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n        if (!noAssert) checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, false, 23, 4);\n      };\n\n      Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n        if (!noAssert) checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, true, 52, 8);\n      };\n\n      Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n        if (!noAssert) checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, false, 52, 8);\n      };\n\n      function checkInt(buf, value, offset, ext, max, min) {\n        if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n        if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n        if (offset + ext > buf.length) throw new RangeError('Index out of range');\n      }\n\n      Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n        value = +value;\n        offset = offset | 0;\n        byteLength = byteLength | 0;\n\n        if (!noAssert) {\n          var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n          checkInt(this, value, offset, byteLength, maxBytes, 0);\n        }\n\n        var mul = 1;\n        var i = 0;\n        this[offset] = value & 0xFF;\n\n        while (++i < byteLength && (mul *= 0x100)) {\n          this[offset + i] = value / mul & 0xFF;\n        }\n\n        return offset + byteLength;\n      };\n\n      Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n        value = +value;\n        offset = offset | 0;\n        byteLength = byteLength | 0;\n\n        if (!noAssert) {\n          var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n          checkInt(this, value, offset, byteLength, maxBytes, 0);\n        }\n\n        var i = byteLength - 1;\n        var mul = 1;\n        this[offset + i] = value & 0xFF;\n\n        while (--i >= 0 && (mul *= 0x100)) {\n          this[offset + i] = value / mul & 0xFF;\n        }\n\n        return offset + byteLength;\n      };\n\n      Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset | 0;\n        if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n        if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n        this[offset] = value & 0xff;\n        return offset + 1;\n      };\n\n      function objectWriteUInt16(buf, value, offset, littleEndian) {\n        if (value < 0) value = 0xffff + value + 1;\n\n        for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n          buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;\n        }\n      }\n\n      Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset | 0;\n        if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\n        if (Buffer.TYPED_ARRAY_SUPPORT) {\n          this[offset] = value & 0xff;\n          this[offset + 1] = value >>> 8;\n        } else {\n          objectWriteUInt16(this, value, offset, true);\n        }\n\n        return offset + 2;\n      };\n\n      Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset | 0;\n        if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\n        if (Buffer.TYPED_ARRAY_SUPPORT) {\n          this[offset] = value >>> 8;\n          this[offset + 1] = value & 0xff;\n        } else {\n          objectWriteUInt16(this, value, offset, false);\n        }\n\n        return offset + 2;\n      };\n\n      function objectWriteUInt32(buf, value, offset, littleEndian) {\n        if (value < 0) value = 0xffffffff + value + 1;\n\n        for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n          buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n        }\n      }\n\n      Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset | 0;\n        if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\n        if (Buffer.TYPED_ARRAY_SUPPORT) {\n          this[offset + 3] = value >>> 24;\n          this[offset + 2] = value >>> 16;\n          this[offset + 1] = value >>> 8;\n          this[offset] = value & 0xff;\n        } else {\n          objectWriteUInt32(this, value, offset, true);\n        }\n\n        return offset + 4;\n      };\n\n      Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset | 0;\n        if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\n        if (Buffer.TYPED_ARRAY_SUPPORT) {\n          this[offset] = value >>> 24;\n          this[offset + 1] = value >>> 16;\n          this[offset + 2] = value >>> 8;\n          this[offset + 3] = value & 0xff;\n        } else {\n          objectWriteUInt32(this, value, offset, false);\n        }\n\n        return offset + 4;\n      };\n\n      Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n        value = +value;\n        offset = offset | 0;\n\n        if (!noAssert) {\n          var limit = Math.pow(2, 8 * byteLength - 1);\n          checkInt(this, value, offset, byteLength, limit - 1, -limit);\n        }\n\n        var i = 0;\n        var mul = 1;\n        var sub = 0;\n        this[offset] = value & 0xFF;\n\n        while (++i < byteLength && (mul *= 0x100)) {\n          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n          }\n\n          this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n        }\n\n        return offset + byteLength;\n      };\n\n      Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n        value = +value;\n        offset = offset | 0;\n\n        if (!noAssert) {\n          var limit = Math.pow(2, 8 * byteLength - 1);\n          checkInt(this, value, offset, byteLength, limit - 1, -limit);\n        }\n\n        var i = byteLength - 1;\n        var mul = 1;\n        var sub = 0;\n        this[offset + i] = value & 0xFF;\n\n        while (--i >= 0 && (mul *= 0x100)) {\n          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n          }\n\n          this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n        }\n\n        return offset + byteLength;\n      };\n\n      Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset | 0;\n        if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n        if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n        if (value < 0) value = 0xff + value + 1;\n        this[offset] = value & 0xff;\n        return offset + 1;\n      };\n\n      Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset | 0;\n        if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\n        if (Buffer.TYPED_ARRAY_SUPPORT) {\n          this[offset] = value & 0xff;\n          this[offset + 1] = value >>> 8;\n        } else {\n          objectWriteUInt16(this, value, offset, true);\n        }\n\n        return offset + 2;\n      };\n\n      Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset | 0;\n        if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\n        if (Buffer.TYPED_ARRAY_SUPPORT) {\n          this[offset] = value >>> 8;\n          this[offset + 1] = value & 0xff;\n        } else {\n          objectWriteUInt16(this, value, offset, false);\n        }\n\n        return offset + 2;\n      };\n\n      Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset | 0;\n        if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n\n        if (Buffer.TYPED_ARRAY_SUPPORT) {\n          this[offset] = value & 0xff;\n          this[offset + 1] = value >>> 8;\n          this[offset + 2] = value >>> 16;\n          this[offset + 3] = value >>> 24;\n        } else {\n          objectWriteUInt32(this, value, offset, true);\n        }\n\n        return offset + 4;\n      };\n\n      Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset | 0;\n        if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n        if (value < 0) value = 0xffffffff + value + 1;\n\n        if (Buffer.TYPED_ARRAY_SUPPORT) {\n          this[offset] = value >>> 24;\n          this[offset + 1] = value >>> 16;\n          this[offset + 2] = value >>> 8;\n          this[offset + 3] = value & 0xff;\n        } else {\n          objectWriteUInt32(this, value, offset, false);\n        }\n\n        return offset + 4;\n      };\n\n      function checkIEEE754(buf, value, offset, ext, max, min) {\n        if (offset + ext > buf.length) throw new RangeError('Index out of range');\n        if (offset < 0) throw new RangeError('Index out of range');\n      }\n\n      function writeFloat(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n        }\n\n        ieee754.write(buf, value, offset, littleEndian, 23, 4);\n        return offset + 4;\n      }\n\n      Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, false, noAssert);\n      };\n\n      function writeDouble(buf, value, offset, littleEndian, noAssert) {\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n        }\n\n        ieee754.write(buf, value, offset, littleEndian, 52, 8);\n        return offset + 8;\n      }\n\n      Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, false, noAssert);\n      }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\n\n      Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n        if (!start) start = 0;\n        if (!end && end !== 0) end = this.length;\n        if (targetStart >= target.length) targetStart = target.length;\n        if (!targetStart) targetStart = 0;\n        if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done\n\n        if (end === start) return 0;\n        if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions\n\n        if (targetStart < 0) {\n          throw new RangeError('targetStart out of bounds');\n        }\n\n        if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');\n        if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?\n\n        if (end > this.length) end = this.length;\n\n        if (target.length - targetStart < end - start) {\n          end = target.length - targetStart + start;\n        }\n\n        var len = end - start;\n        var i;\n\n        if (this === target && start < targetStart && targetStart < end) {\n          // descending copy from end\n          for (i = len - 1; i >= 0; --i) {\n            target[i + targetStart] = this[i + start];\n          }\n        } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n          // ascending copy from start\n          for (i = 0; i < len; ++i) {\n            target[i + targetStart] = this[i + start];\n          }\n        } else {\n          Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n        }\n\n        return len;\n      }; // Usage:\n      //    buffer.fill(number[, offset[, end]])\n      //    buffer.fill(buffer[, offset[, end]])\n      //    buffer.fill(string[, offset[, end]][, encoding])\n\n\n      Buffer.prototype.fill = function fill(val, start, end, encoding) {\n        // Handle string cases:\n        if (typeof val === 'string') {\n          if (typeof start === 'string') {\n            encoding = start;\n            start = 0;\n            end = this.length;\n          } else if (typeof end === 'string') {\n            encoding = end;\n            end = this.length;\n          }\n\n          if (val.length === 1) {\n            var code = val.charCodeAt(0);\n\n            if (code < 256) {\n              val = code;\n            }\n          }\n\n          if (encoding !== undefined && typeof encoding !== 'string') {\n            throw new TypeError('encoding must be a string');\n          }\n\n          if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n            throw new TypeError('Unknown encoding: ' + encoding);\n          }\n        } else if (typeof val === 'number') {\n          val = val & 255;\n        } // Invalid ranges are not set to a default, so can range check early.\n\n\n        if (start < 0 || this.length < start || this.length < end) {\n          throw new RangeError('Out of range index');\n        }\n\n        if (end <= start) {\n          return this;\n        }\n\n        start = start >>> 0;\n        end = end === undefined ? this.length : end >>> 0;\n        if (!val) val = 0;\n        var i;\n\n        if (typeof val === 'number') {\n          for (i = start; i < end; ++i) {\n            this[i] = val;\n          }\n        } else {\n          var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());\n          var len = bytes.length;\n\n          for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len];\n          }\n        }\n\n        return this;\n      }; // HELPER FUNCTIONS\n      // ================\n\n\n      var INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\n      function base64clean(str) {\n        // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n        str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''\n\n        if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\n        while (str.length % 4 !== 0) {\n          str = str + '=';\n        }\n\n        return str;\n      }\n\n      function stringtrim(str) {\n        if (str.trim) return str.trim();\n        return str.replace(/^\\s+|\\s+$/g, '');\n      }\n\n      function toHex(n) {\n        if (n < 16) return '0' + n.toString(16);\n        return n.toString(16);\n      }\n\n      function utf8ToBytes(string, units) {\n        units = units || Infinity;\n        var codePoint;\n        var length = string.length;\n        var leadSurrogate = null;\n        var bytes = [];\n\n        for (var i = 0; i < length; ++i) {\n          codePoint = string.charCodeAt(i); // is surrogate component\n\n          if (codePoint > 0xD7FF && codePoint < 0xE000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n              // no lead yet\n              if (codePoint > 0xDBFF) {\n                // unexpected trail\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                continue;\n              } else if (i + 1 === length) {\n                // unpaired lead\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                continue;\n              } // valid lead\n\n\n              leadSurrogate = codePoint;\n              continue;\n            } // 2 leads in a row\n\n\n            if (codePoint < 0xDC00) {\n              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n              leadSurrogate = codePoint;\n              continue;\n            } // valid surrogate pair\n\n\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n          } else if (leadSurrogate) {\n            // valid bmp char, but last char was a lead\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          }\n\n          leadSurrogate = null; // encode utf8\n\n          if (codePoint < 0x80) {\n            if ((units -= 1) < 0) break;\n            bytes.push(codePoint);\n          } else if (codePoint < 0x800) {\n            if ((units -= 2) < 0) break;\n            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n          } else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0) break;\n            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n          } else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0) break;\n            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n          } else {\n            throw new Error('Invalid code point');\n          }\n        }\n\n        return bytes;\n      }\n\n      function asciiToBytes(str) {\n        var byteArray = [];\n\n        for (var i = 0; i < str.length; ++i) {\n          // Node's code seems to be doing this and not & 0x7F..\n          byteArray.push(str.charCodeAt(i) & 0xFF);\n        }\n\n        return byteArray;\n      }\n\n      function utf16leToBytes(str, units) {\n        var c, hi, lo;\n        var byteArray = [];\n\n        for (var i = 0; i < str.length; ++i) {\n          if ((units -= 2) < 0) break;\n          c = str.charCodeAt(i);\n          hi = c >> 8;\n          lo = c % 256;\n          byteArray.push(lo);\n          byteArray.push(hi);\n        }\n\n        return byteArray;\n      }\n\n      function base64ToBytes(str) {\n        return base64.toByteArray(base64clean(str));\n      }\n\n      function blitBuffer(src, dst, offset, length) {\n        for (var i = 0; i < length; ++i) {\n          if (i + offset >= dst.length || i >= src.length) break;\n          dst[i + offset] = src[i];\n        }\n\n        return i;\n      }\n\n      function isnan(val) {\n        return val !== val; // eslint-disable-line no-self-compare\n      }\n    }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n  }, {\n    \"base64-js\": 2,\n    \"ieee754\": 12,\n    \"isarray\": 15\n  }],\n  7: [function (require, module, exports) {\n    module.exports = {\n      \"100\": \"Continue\",\n      \"101\": \"Switching Protocols\",\n      \"102\": \"Processing\",\n      \"200\": \"OK\",\n      \"201\": \"Created\",\n      \"202\": \"Accepted\",\n      \"203\": \"Non-Authoritative Information\",\n      \"204\": \"No Content\",\n      \"205\": \"Reset Content\",\n      \"206\": \"Partial Content\",\n      \"207\": \"Multi-Status\",\n      \"208\": \"Already Reported\",\n      \"226\": \"IM Used\",\n      \"300\": \"Multiple Choices\",\n      \"301\": \"Moved Permanently\",\n      \"302\": \"Found\",\n      \"303\": \"See Other\",\n      \"304\": \"Not Modified\",\n      \"305\": \"Use Proxy\",\n      \"307\": \"Temporary Redirect\",\n      \"308\": \"Permanent Redirect\",\n      \"400\": \"Bad Request\",\n      \"401\": \"Unauthorized\",\n      \"402\": \"Payment Required\",\n      \"403\": \"Forbidden\",\n      \"404\": \"Not Found\",\n      \"405\": \"Method Not Allowed\",\n      \"406\": \"Not Acceptable\",\n      \"407\": \"Proxy Authentication Required\",\n      \"408\": \"Request Timeout\",\n      \"409\": \"Conflict\",\n      \"410\": \"Gone\",\n      \"411\": \"Length Required\",\n      \"412\": \"Precondition Failed\",\n      \"413\": \"Payload Too Large\",\n      \"414\": \"URI Too Long\",\n      \"415\": \"Unsupported Media Type\",\n      \"416\": \"Range Not Satisfiable\",\n      \"417\": \"Expectation Failed\",\n      \"418\": \"I'm a teapot\",\n      \"421\": \"Misdirected Request\",\n      \"422\": \"Unprocessable Entity\",\n      \"423\": \"Locked\",\n      \"424\": \"Failed Dependency\",\n      \"425\": \"Unordered Collection\",\n      \"426\": \"Upgrade Required\",\n      \"428\": \"Precondition Required\",\n      \"429\": \"Too Many Requests\",\n      \"431\": \"Request Header Fields Too Large\",\n      \"451\": \"Unavailable For Legal Reasons\",\n      \"500\": \"Internal Server Error\",\n      \"501\": \"Not Implemented\",\n      \"502\": \"Bad Gateway\",\n      \"503\": \"Service Unavailable\",\n      \"504\": \"Gateway Timeout\",\n      \"505\": \"HTTP Version Not Supported\",\n      \"506\": \"Variant Also Negotiates\",\n      \"507\": \"Insufficient Storage\",\n      \"508\": \"Loop Detected\",\n      \"509\": \"Bandwidth Limit Exceeded\",\n      \"510\": \"Not Extended\",\n      \"511\": \"Network Authentication Required\"\n    };\n  }, {}],\n  8: [function (require, module, exports) {\n    (function (Buffer) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      // NOTE: These type checking functions intentionally don't use `instanceof`\n      // because it is fragile and can be easily faked with `Object.create()`.\n      function isArray(arg) {\n        if (Array.isArray) {\n          return Array.isArray(arg);\n        }\n\n        return objectToString(arg) === '[object Array]';\n      }\n\n      exports.isArray = isArray;\n\n      function isBoolean(arg) {\n        return typeof arg === 'boolean';\n      }\n\n      exports.isBoolean = isBoolean;\n\n      function isNull(arg) {\n        return arg === null;\n      }\n\n      exports.isNull = isNull;\n\n      function isNullOrUndefined(arg) {\n        return arg == null;\n      }\n\n      exports.isNullOrUndefined = isNullOrUndefined;\n\n      function isNumber(arg) {\n        return typeof arg === 'number';\n      }\n\n      exports.isNumber = isNumber;\n\n      function isString(arg) {\n        return typeof arg === 'string';\n      }\n\n      exports.isString = isString;\n\n      function isSymbol(arg) {\n        return typeof arg === 'symbol';\n      }\n\n      exports.isSymbol = isSymbol;\n\n      function isUndefined(arg) {\n        return arg === void 0;\n      }\n\n      exports.isUndefined = isUndefined;\n\n      function isRegExp(re) {\n        return objectToString(re) === '[object RegExp]';\n      }\n\n      exports.isRegExp = isRegExp;\n\n      function isObject(arg) {\n        return typeof arg === 'object' && arg !== null;\n      }\n\n      exports.isObject = isObject;\n\n      function isDate(d) {\n        return objectToString(d) === '[object Date]';\n      }\n\n      exports.isDate = isDate;\n\n      function isError(e) {\n        return objectToString(e) === '[object Error]' || e instanceof Error;\n      }\n\n      exports.isError = isError;\n\n      function isFunction(arg) {\n        return typeof arg === 'function';\n      }\n\n      exports.isFunction = isFunction;\n\n      function isPrimitive(arg) {\n        return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol\n        typeof arg === 'undefined';\n      }\n\n      exports.isPrimitive = isPrimitive;\n      exports.isBuffer = Buffer.isBuffer;\n\n      function objectToString(o) {\n        return Object.prototype.toString.call(o);\n      }\n    }).call(this, {\n      \"isBuffer\": require(\"../../is-buffer/index.js\")\n    });\n  }, {\n    \"../../is-buffer/index.js\": 14\n  }],\n  9: [function (require, module, exports) {\n    (function (process, global) {\n      /*!\n       * https://github.com/paulmillr/es6-shim\n       * @license es6-shim Copyright 2013-2016 by Paul Miller (http://paulmillr.com)\n       *   and contributors,  MIT License\n       * es6-shim: v0.35.1\n       * see https://github.com/paulmillr/es6-shim/blob/0.35.1/LICENSE\n       * Details and documentation:\n       * https://github.com/paulmillr/es6-shim/\n       */\n      // UMD (Universal Module Definition)\n      // see https://github.com/umdjs/umd/blob/master/returnExports.js\n      (function (root, factory) {\n        /*global define, module, exports */\n        if (typeof define === 'function' && define.amd) {\n          // AMD. Register as an anonymous module.\n          define(factory);\n        } else if (typeof exports === 'object') {\n          // Node. Does not work with strict CommonJS, but\n          // only CommonJS-like environments that support module.exports,\n          // like Node.\n          module.exports = factory();\n        } else {\n          // Browser globals (root is window)\n          root.returnExports = factory();\n        }\n      })(this, function () {\n        'use strict';\n\n        var _apply = Function.call.bind(Function.apply);\n\n        var _call = Function.call.bind(Function.call);\n\n        var isArray = Array.isArray;\n        var keys = Object.keys;\n\n        var not = function notThunker(func) {\n          return function notThunk() {\n            return !_apply(func, this, arguments);\n          };\n        };\n\n        var throwsError = function (func) {\n          try {\n            func();\n            return false;\n          } catch (e) {\n            return true;\n          }\n        };\n\n        var valueOrFalseIfThrows = function valueOrFalseIfThrows(func) {\n          try {\n            return func();\n          } catch (e) {\n            return false;\n          }\n        };\n\n        var isCallableWithoutNew = not(throwsError);\n\n        var arePropertyDescriptorsSupported = function () {\n          // if Object.defineProperty exists but throws, it's IE 8\n          return !throwsError(function () {\n            Object.defineProperty({}, 'x', {\n              get: function () {}\n            });\n          });\n        };\n\n        var supportsDescriptors = !!Object.defineProperty && arePropertyDescriptorsSupported();\n\n        var functionsHaveNames = function foo() {}.name === 'foo'; // eslint-disable-line no-extra-parens\n\n\n        var _forEach = Function.call.bind(Array.prototype.forEach);\n\n        var _reduce = Function.call.bind(Array.prototype.reduce);\n\n        var _filter = Function.call.bind(Array.prototype.filter);\n\n        var _some = Function.call.bind(Array.prototype.some);\n\n        var defineProperty = function (object, name, value, force) {\n          if (!force && name in object) {\n            return;\n          }\n\n          if (supportsDescriptors) {\n            Object.defineProperty(object, name, {\n              configurable: true,\n              enumerable: false,\n              writable: true,\n              value: value\n            });\n          } else {\n            object[name] = value;\n          }\n        }; // Define configurable, writable and non-enumerable props\n        // if they don’t exist.\n\n\n        var defineProperties = function (object, map, forceOverride) {\n          _forEach(keys(map), function (name) {\n            var method = map[name];\n            defineProperty(object, name, method, !!forceOverride);\n          });\n        };\n\n        var _toString = Function.call.bind(Object.prototype.toString);\n\n        var isCallable = typeof /abc/ === 'function' ? function IsCallableSlow(x) {\n          // Some old browsers (IE, FF) say that typeof /abc/ === 'function'\n          return typeof x === 'function' && _toString(x) === '[object Function]';\n        } : function IsCallableFast(x) {\n          return typeof x === 'function';\n        };\n        var Value = {\n          getter: function (object, name, getter) {\n            if (!supportsDescriptors) {\n              throw new TypeError('getters require true ES5 support');\n            }\n\n            Object.defineProperty(object, name, {\n              configurable: true,\n              enumerable: false,\n              get: getter\n            });\n          },\n          proxy: function (originalObject, key, targetObject) {\n            if (!supportsDescriptors) {\n              throw new TypeError('getters require true ES5 support');\n            }\n\n            var originalDescriptor = Object.getOwnPropertyDescriptor(originalObject, key);\n            Object.defineProperty(targetObject, key, {\n              configurable: originalDescriptor.configurable,\n              enumerable: originalDescriptor.enumerable,\n              get: function getKey() {\n                return originalObject[key];\n              },\n              set: function setKey(value) {\n                originalObject[key] = value;\n              }\n            });\n          },\n          redefine: function (object, property, newValue) {\n            if (supportsDescriptors) {\n              var descriptor = Object.getOwnPropertyDescriptor(object, property);\n              descriptor.value = newValue;\n              Object.defineProperty(object, property, descriptor);\n            } else {\n              object[property] = newValue;\n            }\n          },\n          defineByDescriptor: function (object, property, descriptor) {\n            if (supportsDescriptors) {\n              Object.defineProperty(object, property, descriptor);\n            } else if ('value' in descriptor) {\n              object[property] = descriptor.value;\n            }\n          },\n          preserveToString: function (target, source) {\n            if (source && isCallable(source.toString)) {\n              defineProperty(target, 'toString', source.toString.bind(source), true);\n            }\n          }\n        }; // Simple shim for Object.create on ES3 browsers\n        // (unlike real shim, no attempt to support `prototype === null`)\n\n        var create = Object.create || function (prototype, properties) {\n          var Prototype = function Prototype() {};\n\n          Prototype.prototype = prototype;\n          var object = new Prototype();\n\n          if (typeof properties !== 'undefined') {\n            keys(properties).forEach(function (key) {\n              Value.defineByDescriptor(object, key, properties[key]);\n            });\n          }\n\n          return object;\n        };\n\n        var supportsSubclassing = function (C, f) {\n          if (!Object.setPrototypeOf) {\n            return false;\n            /* skip test on IE < 11 */\n          }\n\n          return valueOrFalseIfThrows(function () {\n            var Sub = function Subclass(arg) {\n              var o = new C(arg);\n              Object.setPrototypeOf(o, Subclass.prototype);\n              return o;\n            };\n\n            Object.setPrototypeOf(Sub, C);\n            Sub.prototype = create(C.prototype, {\n              constructor: {\n                value: Sub\n              }\n            });\n            return f(Sub);\n          });\n        };\n\n        var getGlobal = function () {\n          /* global self, window, global */\n          // the only reliable means to get the global object is\n          // `Function('return this')()`\n          // However, this causes CSP violations in Chrome apps.\n          if (typeof self !== 'undefined') {\n            return self;\n          }\n\n          if (typeof window !== 'undefined') {\n            return window;\n          }\n\n          if (typeof global !== 'undefined') {\n            return global;\n          }\n\n          throw new Error('unable to locate global object');\n        };\n\n        var globals = getGlobal();\n        var globalIsFinite = globals.isFinite;\n\n        var _indexOf = Function.call.bind(String.prototype.indexOf);\n\n        var _arrayIndexOfApply = Function.apply.bind(Array.prototype.indexOf);\n\n        var _concat = Function.call.bind(Array.prototype.concat); // var _sort = Function.call.bind(Array.prototype.sort);\n\n\n        var _strSlice = Function.call.bind(String.prototype.slice);\n\n        var _push = Function.call.bind(Array.prototype.push);\n\n        var _pushApply = Function.apply.bind(Array.prototype.push);\n\n        var _shift = Function.call.bind(Array.prototype.shift);\n\n        var _max = Math.max;\n        var _min = Math.min;\n        var _floor = Math.floor;\n        var _abs = Math.abs;\n        var _exp = Math.exp;\n        var _log = Math.log;\n        var _sqrt = Math.sqrt;\n\n        var _hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);\n\n        var ArrayIterator; // make our implementation private\n\n        var noop = function () {};\n\n        var OrigMap = globals.Map;\n        var origMapDelete = OrigMap && OrigMap.prototype['delete'];\n        var origMapGet = OrigMap && OrigMap.prototype.get;\n        var origMapHas = OrigMap && OrigMap.prototype.has;\n        var origMapSet = OrigMap && OrigMap.prototype.set;\n        var Symbol = globals.Symbol || {};\n        var symbolSpecies = Symbol.species || '@@species';\n\n        var numberIsNaN = Number.isNaN || function isNaN(value) {\n          // NaN !== NaN, but they are identical.\n          // NaNs are the only non-reflexive value, i.e., if x !== x,\n          // then x is NaN.\n          // isNaN is broken: it converts its argument to number, so\n          // isNaN('foo') => true\n          return value !== value;\n        };\n\n        var numberIsFinite = Number.isFinite || function isFinite(value) {\n          return typeof value === 'number' && globalIsFinite(value);\n        };\n\n        var _sign = isCallable(Math.sign) ? Math.sign : function sign(value) {\n          var number = Number(value);\n\n          if (number === 0) {\n            return number;\n          }\n\n          if (numberIsNaN(number)) {\n            return number;\n          }\n\n          return number < 0 ? -1 : 1;\n        }; // taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js\n        // can be replaced with require('is-arguments') if we ever use a build process instead\n\n\n        var isStandardArguments = function isArguments(value) {\n          return _toString(value) === '[object Arguments]';\n        };\n\n        var isLegacyArguments = function isArguments(value) {\n          return value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && _toString(value) !== '[object Array]' && _toString(value.callee) === '[object Function]';\n        };\n\n        var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;\n        var Type = {\n          primitive: function (x) {\n            return x === null || typeof x !== 'function' && typeof x !== 'object';\n          },\n          string: function (x) {\n            return _toString(x) === '[object String]';\n          },\n          regex: function (x) {\n            return _toString(x) === '[object RegExp]';\n          },\n          symbol: function (x) {\n            return typeof globals.Symbol === 'function' && typeof x === 'symbol';\n          }\n        };\n\n        var overrideNative = function overrideNative(object, property, replacement) {\n          var original = object[property];\n          defineProperty(object, property, replacement, true);\n          Value.preserveToString(object[property], original);\n        }; // eslint-disable-next-line no-restricted-properties\n\n\n        var hasSymbols = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' && Type.symbol(Symbol()); // This is a private name in the es6 spec, equal to '[Symbol.iterator]'\n        // we're going to use an arbitrary _-prefixed name to make our shims\n        // work properly with each other, even though we don't have full Iterator\n        // support.  That is, `Array.from(map.keys())` will work, but we don't\n        // pretend to export a \"real\" Iterator interface.\n\n        var $iterator$ = Type.symbol(Symbol.iterator) ? Symbol.iterator : '_es6-shim iterator_'; // Firefox ships a partial implementation using the name @@iterator.\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=907077#c14\n        // So use that name if we detect it.\n\n        if (globals.Set && typeof new globals.Set()['@@iterator'] === 'function') {\n          $iterator$ = '@@iterator';\n        } // Reflect\n\n\n        if (!globals.Reflect) {\n          defineProperty(globals, 'Reflect', {}, true);\n        }\n\n        var Reflect = globals.Reflect;\n        var $String = String;\n        /* global document */\n\n        var domAll = typeof document === 'undefined' || !document ? null : document.all;\n        /* jshint eqnull:true */\n\n        var isNullOrUndefined = domAll == null ? function isNullOrUndefined(x) {\n          /* jshint eqnull:true */\n          return x == null;\n        } : function isNullOrUndefinedAndNotDocumentAll(x) {\n          /* jshint eqnull:true */\n          return x == null && x !== domAll;\n        };\n        var ES = {\n          // http://www.ecma-international.org/ecma-262/6.0/#sec-call\n          Call: function Call(F, V) {\n            var args = arguments.length > 2 ? arguments[2] : [];\n\n            if (!ES.IsCallable(F)) {\n              throw new TypeError(F + ' is not a function');\n            }\n\n            return _apply(F, V, args);\n          },\n          RequireObjectCoercible: function (x, optMessage) {\n            if (isNullOrUndefined(x)) {\n              throw new TypeError(optMessage || 'Cannot call method on ' + x);\n            }\n\n            return x;\n          },\n          // This might miss the \"(non-standard exotic and does not implement\n          // [[Call]])\" case from\n          // http://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator-runtime-semantics-evaluation\n          // but we can't find any evidence these objects exist in practice.\n          // If we find some in the future, you could test `Object(x) === x`,\n          // which is reliable according to\n          // http://www.ecma-international.org/ecma-262/6.0/#sec-toobject\n          // but is not well optimized by runtimes and creates an object\n          // whenever it returns false, and thus is very slow.\n          TypeIsObject: function (x) {\n            if (x === void 0 || x === null || x === true || x === false) {\n              return false;\n            }\n\n            return typeof x === 'function' || typeof x === 'object' || x === domAll;\n          },\n          ToObject: function (o, optMessage) {\n            return Object(ES.RequireObjectCoercible(o, optMessage));\n          },\n          IsCallable: isCallable,\n          IsConstructor: function (x) {\n            // We can't tell callables from constructors in ES5\n            return ES.IsCallable(x);\n          },\n          ToInt32: function (x) {\n            return ES.ToNumber(x) >> 0;\n          },\n          ToUint32: function (x) {\n            return ES.ToNumber(x) >>> 0;\n          },\n          ToNumber: function (value) {\n            if (_toString(value) === '[object Symbol]') {\n              throw new TypeError('Cannot convert a Symbol value to a number');\n            }\n\n            return +value;\n          },\n          ToInteger: function (value) {\n            var number = ES.ToNumber(value);\n\n            if (numberIsNaN(number)) {\n              return 0;\n            }\n\n            if (number === 0 || !numberIsFinite(number)) {\n              return number;\n            }\n\n            return (number > 0 ? 1 : -1) * _floor(_abs(number));\n          },\n          ToLength: function (value) {\n            var len = ES.ToInteger(value);\n\n            if (len <= 0) {\n              return 0;\n            } // includes converting -0 to +0\n\n\n            if (len > Number.MAX_SAFE_INTEGER) {\n              return Number.MAX_SAFE_INTEGER;\n            }\n\n            return len;\n          },\n          SameValue: function (a, b) {\n            if (a === b) {\n              // 0 === -0, but they are not identical.\n              if (a === 0) {\n                return 1 / a === 1 / b;\n              }\n\n              return true;\n            }\n\n            return numberIsNaN(a) && numberIsNaN(b);\n          },\n          SameValueZero: function (a, b) {\n            // same as SameValue except for SameValueZero(+0, -0) == true\n            return a === b || numberIsNaN(a) && numberIsNaN(b);\n          },\n          IsIterable: function (o) {\n            return ES.TypeIsObject(o) && (typeof o[$iterator$] !== 'undefined' || isArguments(o));\n          },\n          GetIterator: function (o) {\n            if (isArguments(o)) {\n              // special case support for `arguments`\n              return new ArrayIterator(o, 'value');\n            }\n\n            var itFn = ES.GetMethod(o, $iterator$);\n\n            if (!ES.IsCallable(itFn)) {\n              // Better diagnostics if itFn is null or undefined\n              throw new TypeError('value is not an iterable');\n            }\n\n            var it = ES.Call(itFn, o);\n\n            if (!ES.TypeIsObject(it)) {\n              throw new TypeError('bad iterator');\n            }\n\n            return it;\n          },\n          GetMethod: function (o, p) {\n            var func = ES.ToObject(o)[p];\n\n            if (isNullOrUndefined(func)) {\n              return void 0;\n            }\n\n            if (!ES.IsCallable(func)) {\n              throw new TypeError('Method not callable: ' + p);\n            }\n\n            return func;\n          },\n          IteratorComplete: function (iterResult) {\n            return !!iterResult.done;\n          },\n          IteratorClose: function (iterator, completionIsThrow) {\n            var returnMethod = ES.GetMethod(iterator, 'return');\n\n            if (returnMethod === void 0) {\n              return;\n            }\n\n            var innerResult, innerException;\n\n            try {\n              innerResult = ES.Call(returnMethod, iterator);\n            } catch (e) {\n              innerException = e;\n            }\n\n            if (completionIsThrow) {\n              return;\n            }\n\n            if (innerException) {\n              throw innerException;\n            }\n\n            if (!ES.TypeIsObject(innerResult)) {\n              throw new TypeError(\"Iterator's return method returned a non-object.\");\n            }\n          },\n          IteratorNext: function (it) {\n            var result = arguments.length > 1 ? it.next(arguments[1]) : it.next();\n\n            if (!ES.TypeIsObject(result)) {\n              throw new TypeError('bad iterator');\n            }\n\n            return result;\n          },\n          IteratorStep: function (it) {\n            var result = ES.IteratorNext(it);\n            var done = ES.IteratorComplete(result);\n            return done ? false : result;\n          },\n          Construct: function (C, args, newTarget, isES6internal) {\n            var target = typeof newTarget === 'undefined' ? C : newTarget;\n\n            if (!isES6internal && Reflect.construct) {\n              // Try to use Reflect.construct if available\n              return Reflect.construct(C, args, target);\n            } // OK, we have to fake it.  This will only work if the\n            // C.[[ConstructorKind]] == \"base\" -- but that's the only\n            // kind we can make in ES5 code anyway.\n            // OrdinaryCreateFromConstructor(target, \"%ObjectPrototype%\")\n\n\n            var proto = target.prototype;\n\n            if (!ES.TypeIsObject(proto)) {\n              proto = Object.prototype;\n            }\n\n            var obj = create(proto); // Call the constructor.\n\n            var result = ES.Call(C, obj, args);\n            return ES.TypeIsObject(result) ? result : obj;\n          },\n          SpeciesConstructor: function (O, defaultConstructor) {\n            var C = O.constructor;\n\n            if (C === void 0) {\n              return defaultConstructor;\n            }\n\n            if (!ES.TypeIsObject(C)) {\n              throw new TypeError('Bad constructor');\n            }\n\n            var S = C[symbolSpecies];\n\n            if (isNullOrUndefined(S)) {\n              return defaultConstructor;\n            }\n\n            if (!ES.IsConstructor(S)) {\n              throw new TypeError('Bad @@species');\n            }\n\n            return S;\n          },\n          CreateHTML: function (string, tag, attribute, value) {\n            var S = ES.ToString(string);\n            var p1 = '<' + tag;\n\n            if (attribute !== '') {\n              var V = ES.ToString(value);\n              var escapedV = V.replace(/\"/g, '&quot;');\n              p1 += ' ' + attribute + '=\"' + escapedV + '\"';\n            }\n\n            var p2 = p1 + '>';\n            var p3 = p2 + S;\n            return p3 + '</' + tag + '>';\n          },\n          IsRegExp: function IsRegExp(argument) {\n            if (!ES.TypeIsObject(argument)) {\n              return false;\n            }\n\n            var isRegExp = argument[Symbol.match];\n\n            if (typeof isRegExp !== 'undefined') {\n              return !!isRegExp;\n            }\n\n            return Type.regex(argument);\n          },\n          ToString: function ToString(string) {\n            return $String(string);\n          }\n        }; // Well-known Symbol shims\n\n        if (supportsDescriptors && hasSymbols) {\n          var defineWellKnownSymbol = function defineWellKnownSymbol(name) {\n            if (Type.symbol(Symbol[name])) {\n              return Symbol[name];\n            } // eslint-disable-next-line no-restricted-properties\n\n\n            var sym = Symbol['for']('Symbol.' + name);\n            Object.defineProperty(Symbol, name, {\n              configurable: false,\n              enumerable: false,\n              writable: false,\n              value: sym\n            });\n            return sym;\n          };\n\n          if (!Type.symbol(Symbol.search)) {\n            var symbolSearch = defineWellKnownSymbol('search');\n            var originalSearch = String.prototype.search;\n            defineProperty(RegExp.prototype, symbolSearch, function search(string) {\n              return ES.Call(originalSearch, string, [this]);\n            });\n\n            var searchShim = function search(regexp) {\n              var O = ES.RequireObjectCoercible(this);\n\n              if (!isNullOrUndefined(regexp)) {\n                var searcher = ES.GetMethod(regexp, symbolSearch);\n\n                if (typeof searcher !== 'undefined') {\n                  return ES.Call(searcher, regexp, [O]);\n                }\n              }\n\n              return ES.Call(originalSearch, O, [ES.ToString(regexp)]);\n            };\n\n            overrideNative(String.prototype, 'search', searchShim);\n          }\n\n          if (!Type.symbol(Symbol.replace)) {\n            var symbolReplace = defineWellKnownSymbol('replace');\n            var originalReplace = String.prototype.replace;\n            defineProperty(RegExp.prototype, symbolReplace, function replace(string, replaceValue) {\n              return ES.Call(originalReplace, string, [this, replaceValue]);\n            });\n\n            var replaceShim = function replace(searchValue, replaceValue) {\n              var O = ES.RequireObjectCoercible(this);\n\n              if (!isNullOrUndefined(searchValue)) {\n                var replacer = ES.GetMethod(searchValue, symbolReplace);\n\n                if (typeof replacer !== 'undefined') {\n                  return ES.Call(replacer, searchValue, [O, replaceValue]);\n                }\n              }\n\n              return ES.Call(originalReplace, O, [ES.ToString(searchValue), replaceValue]);\n            };\n\n            overrideNative(String.prototype, 'replace', replaceShim);\n          }\n\n          if (!Type.symbol(Symbol.split)) {\n            var symbolSplit = defineWellKnownSymbol('split');\n            var originalSplit = String.prototype.split;\n            defineProperty(RegExp.prototype, symbolSplit, function split(string, limit) {\n              return ES.Call(originalSplit, string, [this, limit]);\n            });\n\n            var splitShim = function split(separator, limit) {\n              var O = ES.RequireObjectCoercible(this);\n\n              if (!isNullOrUndefined(separator)) {\n                var splitter = ES.GetMethod(separator, symbolSplit);\n\n                if (typeof splitter !== 'undefined') {\n                  return ES.Call(splitter, separator, [O, limit]);\n                }\n              }\n\n              return ES.Call(originalSplit, O, [ES.ToString(separator), limit]);\n            };\n\n            overrideNative(String.prototype, 'split', splitShim);\n          }\n\n          var symbolMatchExists = Type.symbol(Symbol.match);\n\n          var stringMatchIgnoresSymbolMatch = symbolMatchExists && function () {\n            // Firefox 41, through Nightly 45 has Symbol.match, but String#match ignores it.\n            // Firefox 40 and below have Symbol.match but String#match works fine.\n            var o = {};\n\n            o[Symbol.match] = function () {\n              return 42;\n            };\n\n            return 'a'.match(o) !== 42;\n          }();\n\n          if (!symbolMatchExists || stringMatchIgnoresSymbolMatch) {\n            var symbolMatch = defineWellKnownSymbol('match');\n            var originalMatch = String.prototype.match;\n            defineProperty(RegExp.prototype, symbolMatch, function match(string) {\n              return ES.Call(originalMatch, string, [this]);\n            });\n\n            var matchShim = function match(regexp) {\n              var O = ES.RequireObjectCoercible(this);\n\n              if (!isNullOrUndefined(regexp)) {\n                var matcher = ES.GetMethod(regexp, symbolMatch);\n\n                if (typeof matcher !== 'undefined') {\n                  return ES.Call(matcher, regexp, [O]);\n                }\n              }\n\n              return ES.Call(originalMatch, O, [ES.ToString(regexp)]);\n            };\n\n            overrideNative(String.prototype, 'match', matchShim);\n          }\n        }\n\n        var wrapConstructor = function wrapConstructor(original, replacement, keysToSkip) {\n          Value.preserveToString(replacement, original);\n\n          if (Object.setPrototypeOf) {\n            // sets up proper prototype chain where possible\n            Object.setPrototypeOf(original, replacement);\n          }\n\n          if (supportsDescriptors) {\n            _forEach(Object.getOwnPropertyNames(original), function (key) {\n              if (key in noop || keysToSkip[key]) {\n                return;\n              }\n\n              Value.proxy(original, key, replacement);\n            });\n          } else {\n            _forEach(Object.keys(original), function (key) {\n              if (key in noop || keysToSkip[key]) {\n                return;\n              }\n\n              replacement[key] = original[key];\n            });\n          }\n\n          replacement.prototype = original.prototype;\n          Value.redefine(original.prototype, 'constructor', replacement);\n        };\n\n        var defaultSpeciesGetter = function () {\n          return this;\n        };\n\n        var addDefaultSpecies = function (C) {\n          if (supportsDescriptors && !_hasOwnProperty(C, symbolSpecies)) {\n            Value.getter(C, symbolSpecies, defaultSpeciesGetter);\n          }\n        };\n\n        var addIterator = function (prototype, impl) {\n          var implementation = impl || function iterator() {\n            return this;\n          };\n\n          defineProperty(prototype, $iterator$, implementation);\n\n          if (!prototype[$iterator$] && Type.symbol($iterator$)) {\n            // implementations are buggy when $iterator$ is a Symbol\n            prototype[$iterator$] = implementation;\n          }\n        };\n\n        var createDataProperty = function createDataProperty(object, name, value) {\n          if (supportsDescriptors) {\n            Object.defineProperty(object, name, {\n              configurable: true,\n              enumerable: true,\n              writable: true,\n              value: value\n            });\n          } else {\n            object[name] = value;\n          }\n        };\n\n        var createDataPropertyOrThrow = function createDataPropertyOrThrow(object, name, value) {\n          createDataProperty(object, name, value);\n\n          if (!ES.SameValue(object[name], value)) {\n            throw new TypeError('property is nonconfigurable');\n          }\n        };\n\n        var emulateES6construct = function (o, defaultNewTarget, defaultProto, slots) {\n          // This is an es5 approximation to es6 construct semantics.  in es6,\n          // 'new Foo' invokes Foo.[[Construct]] which (for almost all objects)\n          // just sets the internal variable NewTarget (in es6 syntax `new.target`)\n          // to Foo and then returns Foo().\n          // Many ES6 object then have constructors of the form:\n          // 1. If NewTarget is undefined, throw a TypeError exception\n          // 2. Let xxx by OrdinaryCreateFromConstructor(NewTarget, yyy, zzz)\n          // So we're going to emulate those first two steps.\n          if (!ES.TypeIsObject(o)) {\n            throw new TypeError('Constructor requires `new`: ' + defaultNewTarget.name);\n          }\n\n          var proto = defaultNewTarget.prototype;\n\n          if (!ES.TypeIsObject(proto)) {\n            proto = defaultProto;\n          }\n\n          var obj = create(proto);\n\n          for (var name in slots) {\n            if (_hasOwnProperty(slots, name)) {\n              var value = slots[name];\n              defineProperty(obj, name, value, true);\n            }\n          }\n\n          return obj;\n        }; // Firefox 31 reports this function's length as 0\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1062484\n\n\n        if (String.fromCodePoint && String.fromCodePoint.length !== 1) {\n          var originalFromCodePoint = String.fromCodePoint;\n          overrideNative(String, 'fromCodePoint', function fromCodePoint(codePoints) {\n            return ES.Call(originalFromCodePoint, this, arguments);\n          });\n        }\n\n        var StringShims = {\n          fromCodePoint: function fromCodePoint(codePoints) {\n            var result = [];\n            var next;\n\n            for (var i = 0, length = arguments.length; i < length; i++) {\n              next = Number(arguments[i]);\n\n              if (!ES.SameValue(next, ES.ToInteger(next)) || next < 0 || next > 0x10FFFF) {\n                throw new RangeError('Invalid code point ' + next);\n              }\n\n              if (next < 0x10000) {\n                _push(result, String.fromCharCode(next));\n              } else {\n                next -= 0x10000;\n\n                _push(result, String.fromCharCode((next >> 10) + 0xD800));\n\n                _push(result, String.fromCharCode(next % 0x400 + 0xDC00));\n              }\n            }\n\n            return result.join('');\n          },\n          raw: function raw(callSite) {\n            var cooked = ES.ToObject(callSite, 'bad callSite');\n            var rawString = ES.ToObject(cooked.raw, 'bad raw value');\n            var len = rawString.length;\n            var literalsegments = ES.ToLength(len);\n\n            if (literalsegments <= 0) {\n              return '';\n            }\n\n            var stringElements = [];\n            var nextIndex = 0;\n            var nextKey, next, nextSeg, nextSub;\n\n            while (nextIndex < literalsegments) {\n              nextKey = ES.ToString(nextIndex);\n              nextSeg = ES.ToString(rawString[nextKey]);\n\n              _push(stringElements, nextSeg);\n\n              if (nextIndex + 1 >= literalsegments) {\n                break;\n              }\n\n              next = nextIndex + 1 < arguments.length ? arguments[nextIndex + 1] : '';\n              nextSub = ES.ToString(next);\n\n              _push(stringElements, nextSub);\n\n              nextIndex += 1;\n            }\n\n            return stringElements.join('');\n          }\n        };\n\n        if (String.raw && String.raw({\n          raw: {\n            0: 'x',\n            1: 'y',\n            length: 2\n          }\n        }) !== 'xy') {\n          // IE 11 TP has a broken String.raw implementation\n          overrideNative(String, 'raw', StringShims.raw);\n        }\n\n        defineProperties(String, StringShims); // Fast repeat, uses the `Exponentiation by squaring` algorithm.\n        // Perf: http://jsperf.com/string-repeat2/2\n\n        var stringRepeat = function repeat(s, times) {\n          if (times < 1) {\n            return '';\n          }\n\n          if (times % 2) {\n            return repeat(s, times - 1) + s;\n          }\n\n          var half = repeat(s, times / 2);\n          return half + half;\n        };\n\n        var stringMaxLength = Infinity;\n        var StringPrototypeShims = {\n          repeat: function repeat(times) {\n            var thisStr = ES.ToString(ES.RequireObjectCoercible(this));\n            var numTimes = ES.ToInteger(times);\n\n            if (numTimes < 0 || numTimes >= stringMaxLength) {\n              throw new RangeError('repeat count must be less than infinity and not overflow maximum string size');\n            }\n\n            return stringRepeat(thisStr, numTimes);\n          },\n          startsWith: function startsWith(searchString) {\n            var S = ES.ToString(ES.RequireObjectCoercible(this));\n\n            if (ES.IsRegExp(searchString)) {\n              throw new TypeError('Cannot call method \"startsWith\" with a regex');\n            }\n\n            var searchStr = ES.ToString(searchString);\n            var position;\n\n            if (arguments.length > 1) {\n              position = arguments[1];\n            }\n\n            var start = _max(ES.ToInteger(position), 0);\n\n            return _strSlice(S, start, start + searchStr.length) === searchStr;\n          },\n          endsWith: function endsWith(searchString) {\n            var S = ES.ToString(ES.RequireObjectCoercible(this));\n\n            if (ES.IsRegExp(searchString)) {\n              throw new TypeError('Cannot call method \"endsWith\" with a regex');\n            }\n\n            var searchStr = ES.ToString(searchString);\n            var len = S.length;\n            var endPosition;\n\n            if (arguments.length > 1) {\n              endPosition = arguments[1];\n            }\n\n            var pos = typeof endPosition === 'undefined' ? len : ES.ToInteger(endPosition);\n\n            var end = _min(_max(pos, 0), len);\n\n            return _strSlice(S, end - searchStr.length, end) === searchStr;\n          },\n          includes: function includes(searchString) {\n            if (ES.IsRegExp(searchString)) {\n              throw new TypeError('\"includes\" does not accept a RegExp');\n            }\n\n            var searchStr = ES.ToString(searchString);\n            var position;\n\n            if (arguments.length > 1) {\n              position = arguments[1];\n            } // Somehow this trick makes method 100% compat with the spec.\n\n\n            return _indexOf(this, searchStr, position) !== -1;\n          },\n          codePointAt: function codePointAt(pos) {\n            var thisStr = ES.ToString(ES.RequireObjectCoercible(this));\n            var position = ES.ToInteger(pos);\n            var length = thisStr.length;\n\n            if (position >= 0 && position < length) {\n              var first = thisStr.charCodeAt(position);\n              var isEnd = position + 1 === length;\n\n              if (first < 0xD800 || first > 0xDBFF || isEnd) {\n                return first;\n              }\n\n              var second = thisStr.charCodeAt(position + 1);\n\n              if (second < 0xDC00 || second > 0xDFFF) {\n                return first;\n              }\n\n              return (first - 0xD800) * 1024 + (second - 0xDC00) + 0x10000;\n            }\n          }\n        };\n\n        if (String.prototype.includes && 'a'.includes('a', Infinity) !== false) {\n          overrideNative(String.prototype, 'includes', StringPrototypeShims.includes);\n        }\n\n        if (String.prototype.startsWith && String.prototype.endsWith) {\n          var startsWithRejectsRegex = throwsError(function () {\n            /* throws if spec-compliant */\n            '/a/'.startsWith(/a/);\n          });\n          var startsWithHandlesInfinity = valueOrFalseIfThrows(function () {\n            return 'abc'.startsWith('a', Infinity) === false;\n          });\n\n          if (!startsWithRejectsRegex || !startsWithHandlesInfinity) {\n            // Firefox (< 37?) and IE 11 TP have a noncompliant startsWith implementation\n            overrideNative(String.prototype, 'startsWith', StringPrototypeShims.startsWith);\n            overrideNative(String.prototype, 'endsWith', StringPrototypeShims.endsWith);\n          }\n        }\n\n        if (hasSymbols) {\n          var startsWithSupportsSymbolMatch = valueOrFalseIfThrows(function () {\n            var re = /a/;\n            re[Symbol.match] = false;\n            return '/a/'.startsWith(re);\n          });\n\n          if (!startsWithSupportsSymbolMatch) {\n            overrideNative(String.prototype, 'startsWith', StringPrototypeShims.startsWith);\n          }\n\n          var endsWithSupportsSymbolMatch = valueOrFalseIfThrows(function () {\n            var re = /a/;\n            re[Symbol.match] = false;\n            return '/a/'.endsWith(re);\n          });\n\n          if (!endsWithSupportsSymbolMatch) {\n            overrideNative(String.prototype, 'endsWith', StringPrototypeShims.endsWith);\n          }\n\n          var includesSupportsSymbolMatch = valueOrFalseIfThrows(function () {\n            var re = /a/;\n            re[Symbol.match] = false;\n            return '/a/'.includes(re);\n          });\n\n          if (!includesSupportsSymbolMatch) {\n            overrideNative(String.prototype, 'includes', StringPrototypeShims.includes);\n          }\n        }\n\n        defineProperties(String.prototype, StringPrototypeShims); // whitespace from: http://es5.github.io/#x15.5.4.20\n        // implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324\n\n        var ws = ['\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003', '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028', '\\u2029\\uFEFF'].join('');\n        var trimRegexp = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');\n\n        var trimShim = function trim() {\n          return ES.ToString(ES.RequireObjectCoercible(this)).replace(trimRegexp, '');\n        };\n\n        var nonWS = ['\\u0085', '\\u200b', '\\ufffe'].join('');\n        var nonWSregex = new RegExp('[' + nonWS + ']', 'g');\n        var isBadHexRegex = /^[-+]0x[0-9a-f]+$/i;\n        var hasStringTrimBug = nonWS.trim().length !== nonWS.length;\n        defineProperty(String.prototype, 'trim', trimShim, hasStringTrimBug); // Given an argument x, it will return an IteratorResult object,\n        // with value set to x and done to false.\n        // Given no arguments, it will return an iterator completion object.\n\n        var iteratorResult = function (x) {\n          return {\n            value: x,\n            done: arguments.length === 0\n          };\n        }; // see http://www.ecma-international.org/ecma-262/6.0/#sec-string.prototype-@@iterator\n\n\n        var StringIterator = function (s) {\n          ES.RequireObjectCoercible(s);\n          this._s = ES.ToString(s);\n          this._i = 0;\n        };\n\n        StringIterator.prototype.next = function () {\n          var s = this._s;\n          var i = this._i;\n\n          if (typeof s === 'undefined' || i >= s.length) {\n            this._s = void 0;\n            return iteratorResult();\n          }\n\n          var first = s.charCodeAt(i);\n          var second, len;\n\n          if (first < 0xD800 || first > 0xDBFF || i + 1 === s.length) {\n            len = 1;\n          } else {\n            second = s.charCodeAt(i + 1);\n            len = second < 0xDC00 || second > 0xDFFF ? 1 : 2;\n          }\n\n          this._i = i + len;\n          return iteratorResult(s.substr(i, len));\n        };\n\n        addIterator(StringIterator.prototype);\n        addIterator(String.prototype, function () {\n          return new StringIterator(this);\n        });\n        var ArrayShims = {\n          from: function from(items) {\n            var C = this;\n            var mapFn;\n\n            if (arguments.length > 1) {\n              mapFn = arguments[1];\n            }\n\n            var mapping, T;\n\n            if (typeof mapFn === 'undefined') {\n              mapping = false;\n            } else {\n              if (!ES.IsCallable(mapFn)) {\n                throw new TypeError('Array.from: when provided, the second argument must be a function');\n              }\n\n              if (arguments.length > 2) {\n                T = arguments[2];\n              }\n\n              mapping = true;\n            } // Note that that Arrays will use ArrayIterator:\n            // https://bugs.ecmascript.org/show_bug.cgi?id=2416\n\n\n            var usingIterator = typeof (isArguments(items) || ES.GetMethod(items, $iterator$)) !== 'undefined';\n            var length, result, i;\n\n            if (usingIterator) {\n              result = ES.IsConstructor(C) ? Object(new C()) : [];\n              var iterator = ES.GetIterator(items);\n              var next, nextValue;\n              i = 0;\n\n              while (true) {\n                next = ES.IteratorStep(iterator);\n\n                if (next === false) {\n                  break;\n                }\n\n                nextValue = next.value;\n\n                try {\n                  if (mapping) {\n                    nextValue = typeof T === 'undefined' ? mapFn(nextValue, i) : _call(mapFn, T, nextValue, i);\n                  }\n\n                  result[i] = nextValue;\n                } catch (e) {\n                  ES.IteratorClose(iterator, true);\n                  throw e;\n                }\n\n                i += 1;\n              }\n\n              length = i;\n            } else {\n              var arrayLike = ES.ToObject(items);\n              length = ES.ToLength(arrayLike.length);\n              result = ES.IsConstructor(C) ? Object(new C(length)) : new Array(length);\n              var value;\n\n              for (i = 0; i < length; ++i) {\n                value = arrayLike[i];\n\n                if (mapping) {\n                  value = typeof T === 'undefined' ? mapFn(value, i) : _call(mapFn, T, value, i);\n                }\n\n                createDataPropertyOrThrow(result, i, value);\n              }\n            }\n\n            result.length = length;\n            return result;\n          },\n          of: function of() {\n            var len = arguments.length;\n            var C = this;\n            var A = isArray(C) || !ES.IsCallable(C) ? new Array(len) : ES.Construct(C, [len]);\n\n            for (var k = 0; k < len; ++k) {\n              createDataPropertyOrThrow(A, k, arguments[k]);\n            }\n\n            A.length = len;\n            return A;\n          }\n        };\n        defineProperties(Array, ArrayShims);\n        addDefaultSpecies(Array); // Our ArrayIterator is private; see\n        // https://github.com/paulmillr/es6-shim/issues/252\n\n        ArrayIterator = function (array, kind) {\n          this.i = 0;\n          this.array = array;\n          this.kind = kind;\n        };\n\n        defineProperties(ArrayIterator.prototype, {\n          next: function () {\n            var i = this.i;\n            var array = this.array;\n\n            if (!(this instanceof ArrayIterator)) {\n              throw new TypeError('Not an ArrayIterator');\n            }\n\n            if (typeof array !== 'undefined') {\n              var len = ES.ToLength(array.length);\n\n              for (; i < len; i++) {\n                var kind = this.kind;\n                var retval;\n\n                if (kind === 'key') {\n                  retval = i;\n                } else if (kind === 'value') {\n                  retval = array[i];\n                } else if (kind === 'entry') {\n                  retval = [i, array[i]];\n                }\n\n                this.i = i + 1;\n                return iteratorResult(retval);\n              }\n            }\n\n            this.array = void 0;\n            return iteratorResult();\n          }\n        });\n        addIterator(ArrayIterator.prototype);\n        /*\n          var orderKeys = function orderKeys(a, b) {\n            var aNumeric = String(ES.ToInteger(a)) === a;\n            var bNumeric = String(ES.ToInteger(b)) === b;\n            if (aNumeric && bNumeric) {\n              return b - a;\n            } else if (aNumeric && !bNumeric) {\n              return -1;\n            } else if (!aNumeric && bNumeric) {\n              return 1;\n            } else {\n              return a.localeCompare(b);\n            }\n          };\n        \n          var getAllKeys = function getAllKeys(object) {\n            var ownKeys = [];\n            var keys = [];\n        \n            for (var key in object) {\n              _push(_hasOwnProperty(object, key) ? ownKeys : keys, key);\n            }\n            _sort(ownKeys, orderKeys);\n            _sort(keys, orderKeys);\n        \n            return _concat(ownKeys, keys);\n          };\n          */\n        // note: this is positioned here because it depends on ArrayIterator\n\n        var arrayOfSupportsSubclassing = Array.of === ArrayShims.of || function () {\n          // Detects a bug in Webkit nightly r181886\n          var Foo = function Foo(len) {\n            this.length = len;\n          };\n\n          Foo.prototype = [];\n          var fooArr = Array.of.apply(Foo, [1, 2]);\n          return fooArr instanceof Foo && fooArr.length === 2;\n        }();\n\n        if (!arrayOfSupportsSubclassing) {\n          overrideNative(Array, 'of', ArrayShims.of);\n        }\n\n        var ArrayPrototypeShims = {\n          copyWithin: function copyWithin(target, start) {\n            var o = ES.ToObject(this);\n            var len = ES.ToLength(o.length);\n            var relativeTarget = ES.ToInteger(target);\n            var relativeStart = ES.ToInteger(start);\n            var to = relativeTarget < 0 ? _max(len + relativeTarget, 0) : _min(relativeTarget, len);\n            var from = relativeStart < 0 ? _max(len + relativeStart, 0) : _min(relativeStart, len);\n            var end;\n\n            if (arguments.length > 2) {\n              end = arguments[2];\n            }\n\n            var relativeEnd = typeof end === 'undefined' ? len : ES.ToInteger(end);\n            var finalItem = relativeEnd < 0 ? _max(len + relativeEnd, 0) : _min(relativeEnd, len);\n\n            var count = _min(finalItem - from, len - to);\n\n            var direction = 1;\n\n            if (from < to && to < from + count) {\n              direction = -1;\n              from += count - 1;\n              to += count - 1;\n            }\n\n            while (count > 0) {\n              if (from in o) {\n                o[to] = o[from];\n              } else {\n                delete o[to];\n              }\n\n              from += direction;\n              to += direction;\n              count -= 1;\n            }\n\n            return o;\n          },\n          fill: function fill(value) {\n            var start;\n\n            if (arguments.length > 1) {\n              start = arguments[1];\n            }\n\n            var end;\n\n            if (arguments.length > 2) {\n              end = arguments[2];\n            }\n\n            var O = ES.ToObject(this);\n            var len = ES.ToLength(O.length);\n            start = ES.ToInteger(typeof start === 'undefined' ? 0 : start);\n            end = ES.ToInteger(typeof end === 'undefined' ? len : end);\n            var relativeStart = start < 0 ? _max(len + start, 0) : _min(start, len);\n            var relativeEnd = end < 0 ? len + end : end;\n\n            for (var i = relativeStart; i < len && i < relativeEnd; ++i) {\n              O[i] = value;\n            }\n\n            return O;\n          },\n          find: function find(predicate) {\n            var list = ES.ToObject(this);\n            var length = ES.ToLength(list.length);\n\n            if (!ES.IsCallable(predicate)) {\n              throw new TypeError('Array#find: predicate must be a function');\n            }\n\n            var thisArg = arguments.length > 1 ? arguments[1] : null;\n\n            for (var i = 0, value; i < length; i++) {\n              value = list[i];\n\n              if (thisArg) {\n                if (_call(predicate, thisArg, value, i, list)) {\n                  return value;\n                }\n              } else if (predicate(value, i, list)) {\n                return value;\n              }\n            }\n          },\n          findIndex: function findIndex(predicate) {\n            var list = ES.ToObject(this);\n            var length = ES.ToLength(list.length);\n\n            if (!ES.IsCallable(predicate)) {\n              throw new TypeError('Array#findIndex: predicate must be a function');\n            }\n\n            var thisArg = arguments.length > 1 ? arguments[1] : null;\n\n            for (var i = 0; i < length; i++) {\n              if (thisArg) {\n                if (_call(predicate, thisArg, list[i], i, list)) {\n                  return i;\n                }\n              } else if (predicate(list[i], i, list)) {\n                return i;\n              }\n            }\n\n            return -1;\n          },\n          keys: function keys() {\n            return new ArrayIterator(this, 'key');\n          },\n          values: function values() {\n            return new ArrayIterator(this, 'value');\n          },\n          entries: function entries() {\n            return new ArrayIterator(this, 'entry');\n          }\n        }; // Safari 7.1 defines Array#keys and Array#entries natively,\n        // but the resulting ArrayIterator objects don't have a \"next\" method.\n\n        if (Array.prototype.keys && !ES.IsCallable([1].keys().next)) {\n          delete Array.prototype.keys;\n        }\n\n        if (Array.prototype.entries && !ES.IsCallable([1].entries().next)) {\n          delete Array.prototype.entries;\n        } // Chrome 38 defines Array#keys and Array#entries, and Array#@@iterator, but not Array#values\n\n\n        if (Array.prototype.keys && Array.prototype.entries && !Array.prototype.values && Array.prototype[$iterator$]) {\n          defineProperties(Array.prototype, {\n            values: Array.prototype[$iterator$]\n          });\n\n          if (Type.symbol(Symbol.unscopables)) {\n            Array.prototype[Symbol.unscopables].values = true;\n          }\n        } // Chrome 40 defines Array#values with the incorrect name, although Array#{keys,entries} have the correct name\n\n\n        if (functionsHaveNames && Array.prototype.values && Array.prototype.values.name !== 'values') {\n          var originalArrayPrototypeValues = Array.prototype.values;\n          overrideNative(Array.prototype, 'values', function values() {\n            return ES.Call(originalArrayPrototypeValues, this, arguments);\n          });\n          defineProperty(Array.prototype, $iterator$, Array.prototype.values, true);\n        }\n\n        defineProperties(Array.prototype, ArrayPrototypeShims);\n\n        if (1 / [true].indexOf(true, -0) < 0) {\n          // indexOf when given a position arg of -0 should return +0.\n          // https://github.com/tc39/ecma262/pull/316\n          defineProperty(Array.prototype, 'indexOf', function indexOf(searchElement) {\n            var value = _arrayIndexOfApply(this, arguments);\n\n            if (value === 0 && 1 / value < 0) {\n              return 0;\n            }\n\n            return value;\n          }, true);\n        }\n\n        addIterator(Array.prototype, function () {\n          return this.values();\n        }); // Chrome defines keys/values/entries on Array, but doesn't give us\n        // any way to identify its iterator.  So add our own shimmed field.\n\n        if (Object.getPrototypeOf) {\n          addIterator(Object.getPrototypeOf([].values()));\n        } // note: this is positioned here because it relies on Array#entries\n\n\n        var arrayFromSwallowsNegativeLengths = function () {\n          // Detects a Firefox bug in v32\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=1063993\n          return valueOrFalseIfThrows(function () {\n            return Array.from({\n              length: -1\n            }).length === 0;\n          });\n        }();\n\n        var arrayFromHandlesIterables = function () {\n          // Detects a bug in Webkit nightly r181886\n          var arr = Array.from([0].entries());\n          return arr.length === 1 && isArray(arr[0]) && arr[0][0] === 0 && arr[0][1] === 0;\n        }();\n\n        if (!arrayFromSwallowsNegativeLengths || !arrayFromHandlesIterables) {\n          overrideNative(Array, 'from', ArrayShims.from);\n        }\n\n        var arrayFromHandlesUndefinedMapFunction = function () {\n          // Microsoft Edge v0.11 throws if the mapFn argument is *provided* but undefined,\n          // but the spec doesn't care if it's provided or not - undefined doesn't throw.\n          return valueOrFalseIfThrows(function () {\n            return Array.from([0], void 0);\n          });\n        }();\n\n        if (!arrayFromHandlesUndefinedMapFunction) {\n          var origArrayFrom = Array.from;\n          overrideNative(Array, 'from', function from(items) {\n            if (arguments.length > 1 && typeof arguments[1] !== 'undefined') {\n              return ES.Call(origArrayFrom, this, arguments);\n            } else {\n              return _call(origArrayFrom, this, items);\n            }\n          });\n        }\n\n        var int32sAsOne = -(Math.pow(2, 32) - 1);\n\n        var toLengthsCorrectly = function (method, reversed) {\n          var obj = {\n            length: int32sAsOne\n          };\n          obj[reversed ? (obj.length >>> 0) - 1 : 0] = true;\n          return valueOrFalseIfThrows(function () {\n            _call(method, obj, function () {\n              // note: in nonconforming browsers, this will be called\n              // -1 >>> 0 times, which is 4294967295, so the throw matters.\n              throw new RangeError('should not reach here');\n            }, []);\n\n            return true;\n          });\n        };\n\n        if (!toLengthsCorrectly(Array.prototype.forEach)) {\n          var originalForEach = Array.prototype.forEach;\n          overrideNative(Array.prototype, 'forEach', function forEach(callbackFn) {\n            return ES.Call(originalForEach, this.length >= 0 ? this : [], arguments);\n          }, true);\n        }\n\n        if (!toLengthsCorrectly(Array.prototype.map)) {\n          var originalMap = Array.prototype.map;\n          overrideNative(Array.prototype, 'map', function map(callbackFn) {\n            return ES.Call(originalMap, this.length >= 0 ? this : [], arguments);\n          }, true);\n        }\n\n        if (!toLengthsCorrectly(Array.prototype.filter)) {\n          var originalFilter = Array.prototype.filter;\n          overrideNative(Array.prototype, 'filter', function filter(callbackFn) {\n            return ES.Call(originalFilter, this.length >= 0 ? this : [], arguments);\n          }, true);\n        }\n\n        if (!toLengthsCorrectly(Array.prototype.some)) {\n          var originalSome = Array.prototype.some;\n          overrideNative(Array.prototype, 'some', function some(callbackFn) {\n            return ES.Call(originalSome, this.length >= 0 ? this : [], arguments);\n          }, true);\n        }\n\n        if (!toLengthsCorrectly(Array.prototype.every)) {\n          var originalEvery = Array.prototype.every;\n          overrideNative(Array.prototype, 'every', function every(callbackFn) {\n            return ES.Call(originalEvery, this.length >= 0 ? this : [], arguments);\n          }, true);\n        }\n\n        if (!toLengthsCorrectly(Array.prototype.reduce)) {\n          var originalReduce = Array.prototype.reduce;\n          overrideNative(Array.prototype, 'reduce', function reduce(callbackFn) {\n            return ES.Call(originalReduce, this.length >= 0 ? this : [], arguments);\n          }, true);\n        }\n\n        if (!toLengthsCorrectly(Array.prototype.reduceRight, true)) {\n          var originalReduceRight = Array.prototype.reduceRight;\n          overrideNative(Array.prototype, 'reduceRight', function reduceRight(callbackFn) {\n            return ES.Call(originalReduceRight, this.length >= 0 ? this : [], arguments);\n          }, true);\n        }\n\n        var lacksOctalSupport = Number('0o10') !== 8;\n        var lacksBinarySupport = Number('0b10') !== 2;\n\n        var trimsNonWhitespace = _some(nonWS, function (c) {\n          return Number(c + 0 + c) === 0;\n        });\n\n        if (lacksOctalSupport || lacksBinarySupport || trimsNonWhitespace) {\n          var OrigNumber = Number;\n          var binaryRegex = /^0b[01]+$/i;\n          var octalRegex = /^0o[0-7]+$/i; // Note that in IE 8, RegExp.prototype.test doesn't seem to exist: ie, \"test\" is an own property of regexes. wtf.\n\n          var isBinary = binaryRegex.test.bind(binaryRegex);\n          var isOctal = octalRegex.test.bind(octalRegex);\n\n          var toPrimitive = function (O) {\n            // need to replace this with `es-to-primitive/es6`\n            var result;\n\n            if (typeof O.valueOf === 'function') {\n              result = O.valueOf();\n\n              if (Type.primitive(result)) {\n                return result;\n              }\n            }\n\n            if (typeof O.toString === 'function') {\n              result = O.toString();\n\n              if (Type.primitive(result)) {\n                return result;\n              }\n            }\n\n            throw new TypeError('No default value');\n          };\n\n          var hasNonWS = nonWSregex.test.bind(nonWSregex);\n          var isBadHex = isBadHexRegex.test.bind(isBadHexRegex);\n\n          var NumberShim = function () {\n            // this is wrapped in an IIFE because of IE 6-8's wacky scoping issues with named function expressions.\n            var NumberShim = function Number(value) {\n              var primValue;\n\n              if (arguments.length > 0) {\n                primValue = Type.primitive(value) ? value : toPrimitive(value, 'number');\n              } else {\n                primValue = 0;\n              }\n\n              if (typeof primValue === 'string') {\n                primValue = ES.Call(trimShim, primValue);\n\n                if (isBinary(primValue)) {\n                  primValue = parseInt(_strSlice(primValue, 2), 2);\n                } else if (isOctal(primValue)) {\n                  primValue = parseInt(_strSlice(primValue, 2), 8);\n                } else if (hasNonWS(primValue) || isBadHex(primValue)) {\n                  primValue = NaN;\n                }\n              }\n\n              var receiver = this;\n              var valueOfSucceeds = valueOrFalseIfThrows(function () {\n                OrigNumber.prototype.valueOf.call(receiver);\n                return true;\n              });\n\n              if (receiver instanceof NumberShim && !valueOfSucceeds) {\n                return new OrigNumber(primValue);\n              }\n              /* jshint newcap: false */\n\n\n              return OrigNumber(primValue);\n              /* jshint newcap: true */\n            };\n\n            return NumberShim;\n          }();\n\n          wrapConstructor(OrigNumber, NumberShim, {}); // this is necessary for ES3 browsers, where these properties are non-enumerable.\n\n          defineProperties(NumberShim, {\n            NaN: OrigNumber.NaN,\n            MAX_VALUE: OrigNumber.MAX_VALUE,\n            MIN_VALUE: OrigNumber.MIN_VALUE,\n            NEGATIVE_INFINITY: OrigNumber.NEGATIVE_INFINITY,\n            POSITIVE_INFINITY: OrigNumber.POSITIVE_INFINITY\n          });\n          /* globals Number: true */\n\n          /* eslint-disable no-undef, no-global-assign */\n\n          /* jshint -W020 */\n\n          Number = NumberShim;\n          Value.redefine(globals, 'Number', NumberShim);\n          /* jshint +W020 */\n\n          /* eslint-enable no-undef, no-global-assign */\n\n          /* globals Number: false */\n        }\n\n        var maxSafeInteger = Math.pow(2, 53) - 1;\n        defineProperties(Number, {\n          MAX_SAFE_INTEGER: maxSafeInteger,\n          MIN_SAFE_INTEGER: -maxSafeInteger,\n          EPSILON: 2.220446049250313e-16,\n          parseInt: globals.parseInt,\n          parseFloat: globals.parseFloat,\n          isFinite: numberIsFinite,\n          isInteger: function isInteger(value) {\n            return numberIsFinite(value) && ES.ToInteger(value) === value;\n          },\n          isSafeInteger: function isSafeInteger(value) {\n            return Number.isInteger(value) && _abs(value) <= Number.MAX_SAFE_INTEGER;\n          },\n          isNaN: numberIsNaN\n        }); // Firefox 37 has a conforming Number.parseInt, but it's not === to the global parseInt (fixed in v40)\n\n        defineProperty(Number, 'parseInt', globals.parseInt, Number.parseInt !== globals.parseInt); // Work around bugs in Array#find and Array#findIndex -- early\n        // implementations skipped holes in sparse arrays. (Note that the\n        // implementations of find/findIndex indirectly use shimmed\n        // methods of Number, so this test has to happen down here.)\n\n        /*jshint elision: true */\n\n        /* eslint-disable no-sparse-arrays */\n\n        if ([, 1].find(function () {\n          return true;\n        }) === 1) {\n          overrideNative(Array.prototype, 'find', ArrayPrototypeShims.find);\n        }\n\n        if ([, 1].findIndex(function () {\n          return true;\n        }) !== 0) {\n          overrideNative(Array.prototype, 'findIndex', ArrayPrototypeShims.findIndex);\n        }\n        /* eslint-enable no-sparse-arrays */\n\n        /*jshint elision: false */\n\n\n        var isEnumerableOn = Function.bind.call(Function.bind, Object.prototype.propertyIsEnumerable);\n\n        var ensureEnumerable = function ensureEnumerable(obj, prop) {\n          if (supportsDescriptors && isEnumerableOn(obj, prop)) {\n            Object.defineProperty(obj, prop, {\n              enumerable: false\n            });\n          }\n        };\n\n        var sliceArgs = function sliceArgs() {\n          // per https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments\n          // and https://gist.github.com/WebReflection/4327762cb87a8c634a29\n          var initial = Number(this);\n          var len = arguments.length;\n          var desiredArgCount = len - initial;\n          var args = new Array(desiredArgCount < 0 ? 0 : desiredArgCount);\n\n          for (var i = initial; i < len; ++i) {\n            args[i - initial] = arguments[i];\n          }\n\n          return args;\n        };\n\n        var assignTo = function assignTo(source) {\n          return function assignToSource(target, key) {\n            target[key] = source[key];\n            return target;\n          };\n        };\n\n        var assignReducer = function (target, source) {\n          var sourceKeys = keys(Object(source));\n          var symbols;\n\n          if (ES.IsCallable(Object.getOwnPropertySymbols)) {\n            symbols = _filter(Object.getOwnPropertySymbols(Object(source)), isEnumerableOn(source));\n          }\n\n          return _reduce(_concat(sourceKeys, symbols || []), assignTo(source), target);\n        };\n\n        var ObjectShims = {\n          // 19.1.3.1\n          assign: function (target, source) {\n            var to = ES.ToObject(target, 'Cannot convert undefined or null to object');\n            return _reduce(ES.Call(sliceArgs, 1, arguments), assignReducer, to);\n          },\n          // Added in WebKit in https://bugs.webkit.org/show_bug.cgi?id=143865\n          is: function is(a, b) {\n            return ES.SameValue(a, b);\n          }\n        };\n\n        var assignHasPendingExceptions = Object.assign && Object.preventExtensions && function () {\n          // Firefox 37 still has \"pending exception\" logic in its Object.assign implementation,\n          // which is 72% slower than our shim, and Firefox 40's native implementation.\n          var thrower = Object.preventExtensions({\n            1: 2\n          });\n\n          try {\n            Object.assign(thrower, 'xy');\n          } catch (e) {\n            return thrower[1] === 'y';\n          }\n        }();\n\n        if (assignHasPendingExceptions) {\n          overrideNative(Object, 'assign', ObjectShims.assign);\n        }\n\n        defineProperties(Object, ObjectShims);\n\n        if (supportsDescriptors) {\n          var ES5ObjectShims = {\n            // 19.1.3.9\n            // shim from https://gist.github.com/WebReflection/5593554\n            setPrototypeOf: function (Object, magic) {\n              var set;\n\n              var checkArgs = function (O, proto) {\n                if (!ES.TypeIsObject(O)) {\n                  throw new TypeError('cannot set prototype on a non-object');\n                }\n\n                if (!(proto === null || ES.TypeIsObject(proto))) {\n                  throw new TypeError('can only set prototype to an object or null' + proto);\n                }\n              };\n\n              var setPrototypeOf = function (O, proto) {\n                checkArgs(O, proto);\n\n                _call(set, O, proto);\n\n                return O;\n              };\n\n              try {\n                // this works already in Firefox and Safari\n                set = Object.getOwnPropertyDescriptor(Object.prototype, magic).set;\n\n                _call(set, {}, null);\n              } catch (e) {\n                if (Object.prototype !== {}[magic]) {\n                  // IE < 11 cannot be shimmed\n                  return;\n                } // probably Chrome or some old Mobile stock browser\n\n\n                set = function (proto) {\n                  this[magic] = proto;\n                }; // please note that this will **not** work\n                // in those browsers that do not inherit\n                // __proto__ by mistake from Object.prototype\n                // in these cases we should probably throw an error\n                // or at least be informed about the issue\n\n\n                setPrototypeOf.polyfill = setPrototypeOf(setPrototypeOf({}, null), Object.prototype) instanceof Object; // setPrototypeOf.polyfill === true means it works as meant\n                // setPrototypeOf.polyfill === false means it's not 100% reliable\n                // setPrototypeOf.polyfill === undefined\n                // or\n                // setPrototypeOf.polyfill ==  null means it's not a polyfill\n                // which means it works as expected\n                // we can even delete Object.prototype.__proto__;\n              }\n\n              return setPrototypeOf;\n            }(Object, '__proto__')\n          };\n          defineProperties(Object, ES5ObjectShims);\n        } // Workaround bug in Opera 12 where setPrototypeOf(x, null) doesn't work,\n        // but Object.create(null) does.\n\n\n        if (Object.setPrototypeOf && Object.getPrototypeOf && Object.getPrototypeOf(Object.setPrototypeOf({}, null)) !== null && Object.getPrototypeOf(Object.create(null)) === null) {\n          (function () {\n            var FAKENULL = Object.create(null);\n            var gpo = Object.getPrototypeOf;\n            var spo = Object.setPrototypeOf;\n\n            Object.getPrototypeOf = function (o) {\n              var result = gpo(o);\n              return result === FAKENULL ? null : result;\n            };\n\n            Object.setPrototypeOf = function (o, p) {\n              var proto = p === null ? FAKENULL : p;\n              return spo(o, proto);\n            };\n\n            Object.setPrototypeOf.polyfill = false;\n          })();\n        }\n\n        var objectKeysAcceptsPrimitives = !throwsError(function () {\n          Object.keys('foo');\n        });\n\n        if (!objectKeysAcceptsPrimitives) {\n          var originalObjectKeys = Object.keys;\n          overrideNative(Object, 'keys', function keys(value) {\n            return originalObjectKeys(ES.ToObject(value));\n          });\n          keys = Object.keys;\n        }\n\n        var objectKeysRejectsRegex = throwsError(function () {\n          Object.keys(/a/g);\n        });\n\n        if (objectKeysRejectsRegex) {\n          var regexRejectingObjectKeys = Object.keys;\n          overrideNative(Object, 'keys', function keys(value) {\n            if (Type.regex(value)) {\n              var regexKeys = [];\n\n              for (var k in value) {\n                if (_hasOwnProperty(value, k)) {\n                  _push(regexKeys, k);\n                }\n              }\n\n              return regexKeys;\n            }\n\n            return regexRejectingObjectKeys(value);\n          });\n          keys = Object.keys;\n        }\n\n        if (Object.getOwnPropertyNames) {\n          var objectGOPNAcceptsPrimitives = !throwsError(function () {\n            Object.getOwnPropertyNames('foo');\n          });\n\n          if (!objectGOPNAcceptsPrimitives) {\n            var cachedWindowNames = typeof window === 'object' ? Object.getOwnPropertyNames(window) : [];\n            var originalObjectGetOwnPropertyNames = Object.getOwnPropertyNames;\n            overrideNative(Object, 'getOwnPropertyNames', function getOwnPropertyNames(value) {\n              var val = ES.ToObject(value);\n\n              if (_toString(val) === '[object Window]') {\n                try {\n                  return originalObjectGetOwnPropertyNames(val);\n                } catch (e) {\n                  // IE bug where layout engine calls userland gOPN for cross-domain `window` objects\n                  return _concat([], cachedWindowNames);\n                }\n              }\n\n              return originalObjectGetOwnPropertyNames(val);\n            });\n          }\n        }\n\n        if (Object.getOwnPropertyDescriptor) {\n          var objectGOPDAcceptsPrimitives = !throwsError(function () {\n            Object.getOwnPropertyDescriptor('foo', 'bar');\n          });\n\n          if (!objectGOPDAcceptsPrimitives) {\n            var originalObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n            overrideNative(Object, 'getOwnPropertyDescriptor', function getOwnPropertyDescriptor(value, property) {\n              return originalObjectGetOwnPropertyDescriptor(ES.ToObject(value), property);\n            });\n          }\n        }\n\n        if (Object.seal) {\n          var objectSealAcceptsPrimitives = !throwsError(function () {\n            Object.seal('foo');\n          });\n\n          if (!objectSealAcceptsPrimitives) {\n            var originalObjectSeal = Object.seal;\n            overrideNative(Object, 'seal', function seal(value) {\n              if (!ES.TypeIsObject(value)) {\n                return value;\n              }\n\n              return originalObjectSeal(value);\n            });\n          }\n        }\n\n        if (Object.isSealed) {\n          var objectIsSealedAcceptsPrimitives = !throwsError(function () {\n            Object.isSealed('foo');\n          });\n\n          if (!objectIsSealedAcceptsPrimitives) {\n            var originalObjectIsSealed = Object.isSealed;\n            overrideNative(Object, 'isSealed', function isSealed(value) {\n              if (!ES.TypeIsObject(value)) {\n                return true;\n              }\n\n              return originalObjectIsSealed(value);\n            });\n          }\n        }\n\n        if (Object.freeze) {\n          var objectFreezeAcceptsPrimitives = !throwsError(function () {\n            Object.freeze('foo');\n          });\n\n          if (!objectFreezeAcceptsPrimitives) {\n            var originalObjectFreeze = Object.freeze;\n            overrideNative(Object, 'freeze', function freeze(value) {\n              if (!ES.TypeIsObject(value)) {\n                return value;\n              }\n\n              return originalObjectFreeze(value);\n            });\n          }\n        }\n\n        if (Object.isFrozen) {\n          var objectIsFrozenAcceptsPrimitives = !throwsError(function () {\n            Object.isFrozen('foo');\n          });\n\n          if (!objectIsFrozenAcceptsPrimitives) {\n            var originalObjectIsFrozen = Object.isFrozen;\n            overrideNative(Object, 'isFrozen', function isFrozen(value) {\n              if (!ES.TypeIsObject(value)) {\n                return true;\n              }\n\n              return originalObjectIsFrozen(value);\n            });\n          }\n        }\n\n        if (Object.preventExtensions) {\n          var objectPreventExtensionsAcceptsPrimitives = !throwsError(function () {\n            Object.preventExtensions('foo');\n          });\n\n          if (!objectPreventExtensionsAcceptsPrimitives) {\n            var originalObjectPreventExtensions = Object.preventExtensions;\n            overrideNative(Object, 'preventExtensions', function preventExtensions(value) {\n              if (!ES.TypeIsObject(value)) {\n                return value;\n              }\n\n              return originalObjectPreventExtensions(value);\n            });\n          }\n        }\n\n        if (Object.isExtensible) {\n          var objectIsExtensibleAcceptsPrimitives = !throwsError(function () {\n            Object.isExtensible('foo');\n          });\n\n          if (!objectIsExtensibleAcceptsPrimitives) {\n            var originalObjectIsExtensible = Object.isExtensible;\n            overrideNative(Object, 'isExtensible', function isExtensible(value) {\n              if (!ES.TypeIsObject(value)) {\n                return false;\n              }\n\n              return originalObjectIsExtensible(value);\n            });\n          }\n        }\n\n        if (Object.getPrototypeOf) {\n          var objectGetProtoAcceptsPrimitives = !throwsError(function () {\n            Object.getPrototypeOf('foo');\n          });\n\n          if (!objectGetProtoAcceptsPrimitives) {\n            var originalGetProto = Object.getPrototypeOf;\n            overrideNative(Object, 'getPrototypeOf', function getPrototypeOf(value) {\n              return originalGetProto(ES.ToObject(value));\n            });\n          }\n        }\n\n        var hasFlags = supportsDescriptors && function () {\n          var desc = Object.getOwnPropertyDescriptor(RegExp.prototype, 'flags');\n          return desc && ES.IsCallable(desc.get);\n        }();\n\n        if (supportsDescriptors && !hasFlags) {\n          var regExpFlagsGetter = function flags() {\n            if (!ES.TypeIsObject(this)) {\n              throw new TypeError('Method called on incompatible type: must be an object.');\n            }\n\n            var result = '';\n\n            if (this.global) {\n              result += 'g';\n            }\n\n            if (this.ignoreCase) {\n              result += 'i';\n            }\n\n            if (this.multiline) {\n              result += 'm';\n            }\n\n            if (this.unicode) {\n              result += 'u';\n            }\n\n            if (this.sticky) {\n              result += 'y';\n            }\n\n            return result;\n          };\n\n          Value.getter(RegExp.prototype, 'flags', regExpFlagsGetter);\n        }\n\n        var regExpSupportsFlagsWithRegex = supportsDescriptors && valueOrFalseIfThrows(function () {\n          return String(new RegExp(/a/g, 'i')) === '/a/i';\n        });\n\n        var regExpNeedsToSupportSymbolMatch = hasSymbols && supportsDescriptors && function () {\n          // Edge 0.12 supports flags fully, but does not support Symbol.match\n          var regex = /./;\n          regex[Symbol.match] = false;\n          return RegExp(regex) === regex;\n        }();\n\n        var regexToStringIsGeneric = valueOrFalseIfThrows(function () {\n          return RegExp.prototype.toString.call({\n            source: 'abc'\n          }) === '/abc/';\n        });\n        var regexToStringSupportsGenericFlags = regexToStringIsGeneric && valueOrFalseIfThrows(function () {\n          return RegExp.prototype.toString.call({\n            source: 'a',\n            flags: 'b'\n          }) === '/a/b';\n        });\n\n        if (!regexToStringIsGeneric || !regexToStringSupportsGenericFlags) {\n          var origRegExpToString = RegExp.prototype.toString;\n          defineProperty(RegExp.prototype, 'toString', function toString() {\n            var R = ES.RequireObjectCoercible(this);\n\n            if (Type.regex(R)) {\n              return _call(origRegExpToString, R);\n            }\n\n            var pattern = $String(R.source);\n            var flags = $String(R.flags);\n            return '/' + pattern + '/' + flags;\n          }, true);\n          Value.preserveToString(RegExp.prototype.toString, origRegExpToString);\n        }\n\n        if (supportsDescriptors && (!regExpSupportsFlagsWithRegex || regExpNeedsToSupportSymbolMatch)) {\n          var flagsGetter = Object.getOwnPropertyDescriptor(RegExp.prototype, 'flags').get;\n          var sourceDesc = Object.getOwnPropertyDescriptor(RegExp.prototype, 'source') || {};\n\n          var legacySourceGetter = function () {\n            // prior to it being a getter, it's own + nonconfigurable\n            return this.source;\n          };\n\n          var sourceGetter = ES.IsCallable(sourceDesc.get) ? sourceDesc.get : legacySourceGetter;\n          var OrigRegExp = RegExp;\n\n          var RegExpShim = function () {\n            return function RegExp(pattern, flags) {\n              var patternIsRegExp = ES.IsRegExp(pattern);\n              var calledWithNew = this instanceof RegExp;\n\n              if (!calledWithNew && patternIsRegExp && typeof flags === 'undefined' && pattern.constructor === RegExp) {\n                return pattern;\n              }\n\n              var P = pattern;\n              var F = flags;\n\n              if (Type.regex(pattern)) {\n                P = ES.Call(sourceGetter, pattern);\n                F = typeof flags === 'undefined' ? ES.Call(flagsGetter, pattern) : flags;\n                return new RegExp(P, F);\n              } else if (patternIsRegExp) {\n                P = pattern.source;\n                F = typeof flags === 'undefined' ? pattern.flags : flags;\n              }\n\n              return new OrigRegExp(pattern, flags);\n            };\n          }();\n\n          wrapConstructor(OrigRegExp, RegExpShim, {\n            $input: true // Chrome < v39 & Opera < 26 have a nonstandard \"$input\" property\n\n          });\n          /* globals RegExp: true */\n\n          /* eslint-disable no-undef, no-global-assign */\n\n          /* jshint -W020 */\n\n          RegExp = RegExpShim;\n          Value.redefine(globals, 'RegExp', RegExpShim);\n          /* jshint +W020 */\n\n          /* eslint-enable no-undef, no-global-assign */\n\n          /* globals RegExp: false */\n        }\n\n        if (supportsDescriptors) {\n          var regexGlobals = {\n            input: '$_',\n            lastMatch: '$&',\n            lastParen: '$+',\n            leftContext: '$`',\n            rightContext: '$\\''\n          };\n\n          _forEach(keys(regexGlobals), function (prop) {\n            if (prop in RegExp && !(regexGlobals[prop] in RegExp)) {\n              Value.getter(RegExp, regexGlobals[prop], function get() {\n                return RegExp[prop];\n              });\n            }\n          });\n        }\n\n        addDefaultSpecies(RegExp);\n        var inverseEpsilon = 1 / Number.EPSILON;\n\n        var roundTiesToEven = function roundTiesToEven(n) {\n          // Even though this reduces down to `return n`, it takes advantage of built-in rounding.\n          return n + inverseEpsilon - inverseEpsilon;\n        };\n\n        var BINARY_32_EPSILON = Math.pow(2, -23);\n        var BINARY_32_MAX_VALUE = Math.pow(2, 127) * (2 - BINARY_32_EPSILON);\n        var BINARY_32_MIN_VALUE = Math.pow(2, -126);\n        var E = Math.E;\n        var LOG2E = Math.LOG2E;\n        var LOG10E = Math.LOG10E;\n        var numberCLZ = Number.prototype.clz;\n        delete Number.prototype.clz; // Safari 8 has Number#clz\n\n        var MathShims = {\n          acosh: function acosh(value) {\n            var x = Number(value);\n\n            if (numberIsNaN(x) || value < 1) {\n              return NaN;\n            }\n\n            if (x === 1) {\n              return 0;\n            }\n\n            if (x === Infinity) {\n              return x;\n            }\n\n            return _log(x / E + _sqrt(x + 1) * _sqrt(x - 1) / E) + 1;\n          },\n          asinh: function asinh(value) {\n            var x = Number(value);\n\n            if (x === 0 || !globalIsFinite(x)) {\n              return x;\n            }\n\n            return x < 0 ? -asinh(-x) : _log(x + _sqrt(x * x + 1));\n          },\n          atanh: function atanh(value) {\n            var x = Number(value);\n\n            if (numberIsNaN(x) || x < -1 || x > 1) {\n              return NaN;\n            }\n\n            if (x === -1) {\n              return -Infinity;\n            }\n\n            if (x === 1) {\n              return Infinity;\n            }\n\n            if (x === 0) {\n              return x;\n            }\n\n            return 0.5 * _log((1 + x) / (1 - x));\n          },\n          cbrt: function cbrt(value) {\n            var x = Number(value);\n\n            if (x === 0) {\n              return x;\n            }\n\n            var negate = x < 0;\n            var result;\n\n            if (negate) {\n              x = -x;\n            }\n\n            if (x === Infinity) {\n              result = Infinity;\n            } else {\n              result = _exp(_log(x) / 3); // from http://en.wikipedia.org/wiki/Cube_root#Numerical_methods\n\n              result = (x / (result * result) + 2 * result) / 3;\n            }\n\n            return negate ? -result : result;\n          },\n          clz32: function clz32(value) {\n            // See https://bugs.ecmascript.org/show_bug.cgi?id=2465\n            var x = Number(value);\n            var number = ES.ToUint32(x);\n\n            if (number === 0) {\n              return 32;\n            }\n\n            return numberCLZ ? ES.Call(numberCLZ, number) : 31 - _floor(_log(number + 0.5) * LOG2E);\n          },\n          cosh: function cosh(value) {\n            var x = Number(value);\n\n            if (x === 0) {\n              return 1;\n            } // +0 or -0\n\n\n            if (numberIsNaN(x)) {\n              return NaN;\n            }\n\n            if (!globalIsFinite(x)) {\n              return Infinity;\n            }\n\n            if (x < 0) {\n              x = -x;\n            }\n\n            if (x > 21) {\n              return _exp(x) / 2;\n            }\n\n            return (_exp(x) + _exp(-x)) / 2;\n          },\n          expm1: function expm1(value) {\n            var x = Number(value);\n\n            if (x === -Infinity) {\n              return -1;\n            }\n\n            if (!globalIsFinite(x) || x === 0) {\n              return x;\n            }\n\n            if (_abs(x) > 0.5) {\n              return _exp(x) - 1;\n            } // A more precise approximation using Taylor series expansion\n            // from https://github.com/paulmillr/es6-shim/issues/314#issuecomment-70293986\n\n\n            var t = x;\n            var sum = 0;\n            var n = 1;\n\n            while (sum + t !== sum) {\n              sum += t;\n              n += 1;\n              t *= x / n;\n            }\n\n            return sum;\n          },\n          hypot: function hypot(x, y) {\n            var result = 0;\n            var largest = 0;\n\n            for (var i = 0; i < arguments.length; ++i) {\n              var value = _abs(Number(arguments[i]));\n\n              if (largest < value) {\n                result *= largest / value * (largest / value);\n                result += 1;\n                largest = value;\n              } else {\n                result += value > 0 ? value / largest * (value / largest) : value;\n              }\n            }\n\n            return largest === Infinity ? Infinity : largest * _sqrt(result);\n          },\n          log2: function log2(value) {\n            return _log(value) * LOG2E;\n          },\n          log10: function log10(value) {\n            return _log(value) * LOG10E;\n          },\n          log1p: function log1p(value) {\n            var x = Number(value);\n\n            if (x < -1 || numberIsNaN(x)) {\n              return NaN;\n            }\n\n            if (x === 0 || x === Infinity) {\n              return x;\n            }\n\n            if (x === -1) {\n              return -Infinity;\n            }\n\n            return 1 + x - 1 === 0 ? x : x * (_log(1 + x) / (1 + x - 1));\n          },\n          sign: _sign,\n          sinh: function sinh(value) {\n            var x = Number(value);\n\n            if (!globalIsFinite(x) || x === 0) {\n              return x;\n            }\n\n            if (_abs(x) < 1) {\n              return (Math.expm1(x) - Math.expm1(-x)) / 2;\n            }\n\n            return (_exp(x - 1) - _exp(-x - 1)) * E / 2;\n          },\n          tanh: function tanh(value) {\n            var x = Number(value);\n\n            if (numberIsNaN(x) || x === 0) {\n              return x;\n            } // can exit early at +-20 as JS loses precision for true value at this integer\n\n\n            if (x >= 20) {\n              return 1;\n            }\n\n            if (x <= -20) {\n              return -1;\n            }\n\n            return (Math.expm1(x) - Math.expm1(-x)) / (_exp(x) + _exp(-x));\n          },\n          trunc: function trunc(value) {\n            var x = Number(value);\n            return x < 0 ? -_floor(-x) : _floor(x);\n          },\n          imul: function imul(x, y) {\n            // taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n            var a = ES.ToUint32(x);\n            var b = ES.ToUint32(y);\n            var ah = a >>> 16 & 0xffff;\n            var al = a & 0xffff;\n            var bh = b >>> 16 & 0xffff;\n            var bl = b & 0xffff; // the shift by 0 fixes the sign on the high part\n            // the final |0 converts the unsigned value into a signed value\n\n            return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;\n          },\n          fround: function fround(x) {\n            var v = Number(x);\n\n            if (v === 0 || v === Infinity || v === -Infinity || numberIsNaN(v)) {\n              return v;\n            }\n\n            var sign = _sign(v);\n\n            var abs = _abs(v);\n\n            if (abs < BINARY_32_MIN_VALUE) {\n              return sign * roundTiesToEven(abs / BINARY_32_MIN_VALUE / BINARY_32_EPSILON) * BINARY_32_MIN_VALUE * BINARY_32_EPSILON;\n            } // Veltkamp's splitting (?)\n\n\n            var a = (1 + BINARY_32_EPSILON / Number.EPSILON) * abs;\n            var result = a - (a - abs);\n\n            if (result > BINARY_32_MAX_VALUE || numberIsNaN(result)) {\n              return sign * Infinity;\n            }\n\n            return sign * result;\n          }\n        };\n        defineProperties(Math, MathShims); // IE 11 TP has an imprecise log1p: reports Math.log1p(-1e-17) as 0\n\n        defineProperty(Math, 'log1p', MathShims.log1p, Math.log1p(-1e-17) !== -1e-17); // IE 11 TP has an imprecise asinh: reports Math.asinh(-1e7) as not exactly equal to -Math.asinh(1e7)\n\n        defineProperty(Math, 'asinh', MathShims.asinh, Math.asinh(-1e7) !== -Math.asinh(1e7)); // Chrome 40 has an imprecise Math.tanh with very small numbers\n\n        defineProperty(Math, 'tanh', MathShims.tanh, Math.tanh(-2e-17) !== -2e-17); // Chrome 40 loses Math.acosh precision with high numbers\n\n        defineProperty(Math, 'acosh', MathShims.acosh, Math.acosh(Number.MAX_VALUE) === Infinity); // Firefox 38 on Windows\n\n        defineProperty(Math, 'cbrt', MathShims.cbrt, Math.abs(1 - Math.cbrt(1e-300) / 1e-100) / Number.EPSILON > 8); // node 0.11 has an imprecise Math.sinh with very small numbers\n\n        defineProperty(Math, 'sinh', MathShims.sinh, Math.sinh(-2e-17) !== -2e-17); // FF 35 on Linux reports 22025.465794806725 for Math.expm1(10)\n\n        var expm1OfTen = Math.expm1(10);\n        defineProperty(Math, 'expm1', MathShims.expm1, expm1OfTen > 22025.465794806719 || expm1OfTen < 22025.4657948067165168);\n        var origMathRound = Math.round; // breaks in e.g. Safari 8, Internet Explorer 11, Opera 12\n\n        var roundHandlesBoundaryConditions = Math.round(0.5 - Number.EPSILON / 4) === 0 && Math.round(-0.5 + Number.EPSILON / 3.99) === 1; // When engines use Math.floor(x + 0.5) internally, Math.round can be buggy for large integers.\n        // This behavior should be governed by \"round to nearest, ties to even mode\"\n        // see http://www.ecma-international.org/ecma-262/6.0/#sec-terms-and-definitions-number-type\n        // These are the boundary cases where it breaks.\n\n        var smallestPositiveNumberWhereRoundBreaks = inverseEpsilon + 1;\n        var largestPositiveNumberWhereRoundBreaks = 2 * inverseEpsilon - 1;\n        var roundDoesNotIncreaseIntegers = [smallestPositiveNumberWhereRoundBreaks, largestPositiveNumberWhereRoundBreaks].every(function (num) {\n          return Math.round(num) === num;\n        });\n        defineProperty(Math, 'round', function round(x) {\n          var floor = _floor(x);\n\n          var ceil = floor === -1 ? -0 : floor + 1;\n          return x - floor < 0.5 ? floor : ceil;\n        }, !roundHandlesBoundaryConditions || !roundDoesNotIncreaseIntegers);\n        Value.preserveToString(Math.round, origMathRound);\n        var origImul = Math.imul;\n\n        if (Math.imul(0xffffffff, 5) !== -5) {\n          // Safari 6.1, at least, reports \"0\" for this value\n          Math.imul = MathShims.imul;\n          Value.preserveToString(Math.imul, origImul);\n        }\n\n        if (Math.imul.length !== 2) {\n          // Safari 8.0.4 has a length of 1\n          // fixed in https://bugs.webkit.org/show_bug.cgi?id=143658\n          overrideNative(Math, 'imul', function imul(x, y) {\n            return ES.Call(origImul, Math, arguments);\n          });\n        } // Promises\n        // Simplest possible implementation; use a 3rd-party library if you\n        // want the best possible speed and/or long stack traces.\n\n\n        var PromiseShim = function () {\n          var setTimeout = globals.setTimeout; // some environments don't have setTimeout - no way to shim here.\n\n          if (typeof setTimeout !== 'function' && typeof setTimeout !== 'object') {\n            return;\n          }\n\n          ES.IsPromise = function (promise) {\n            if (!ES.TypeIsObject(promise)) {\n              return false;\n            }\n\n            if (typeof promise._promise === 'undefined') {\n              return false; // uninitialized, or missing our hidden field.\n            }\n\n            return true;\n          }; // \"PromiseCapability\" in the spec is what most promise implementations\n          // call a \"deferred\".\n\n\n          var PromiseCapability = function (C) {\n            if (!ES.IsConstructor(C)) {\n              throw new TypeError('Bad promise constructor');\n            }\n\n            var capability = this;\n\n            var resolver = function (resolve, reject) {\n              if (capability.resolve !== void 0 || capability.reject !== void 0) {\n                throw new TypeError('Bad Promise implementation!');\n              }\n\n              capability.resolve = resolve;\n              capability.reject = reject;\n            }; // Initialize fields to inform optimizers about the object shape.\n\n\n            capability.resolve = void 0;\n            capability.reject = void 0;\n            capability.promise = new C(resolver);\n\n            if (!(ES.IsCallable(capability.resolve) && ES.IsCallable(capability.reject))) {\n              throw new TypeError('Bad promise constructor');\n            }\n          }; // find an appropriate setImmediate-alike\n\n\n          var makeZeroTimeout;\n          /*global window */\n\n          if (typeof window !== 'undefined' && ES.IsCallable(window.postMessage)) {\n            makeZeroTimeout = function () {\n              // from http://dbaron.org/log/20100309-faster-timeouts\n              var timeouts = [];\n              var messageName = 'zero-timeout-message';\n\n              var setZeroTimeout = function (fn) {\n                _push(timeouts, fn);\n\n                window.postMessage(messageName, '*');\n              };\n\n              var handleMessage = function (event) {\n                if (event.source === window && event.data === messageName) {\n                  event.stopPropagation();\n\n                  if (timeouts.length === 0) {\n                    return;\n                  }\n\n                  var fn = _shift(timeouts);\n\n                  fn();\n                }\n              };\n\n              window.addEventListener('message', handleMessage, true);\n              return setZeroTimeout;\n            };\n          }\n\n          var makePromiseAsap = function () {\n            // An efficient task-scheduler based on a pre-existing Promise\n            // implementation, which we can use even if we override the\n            // global Promise below (in order to workaround bugs)\n            // https://github.com/Raynos/observ-hash/issues/2#issuecomment-35857671\n            var P = globals.Promise;\n            var pr = P && P.resolve && P.resolve();\n            return pr && function (task) {\n              return pr.then(task);\n            };\n          };\n          /*global process */\n\n          /* jscs:disable disallowMultiLineTernary */\n\n\n          var enqueue = ES.IsCallable(globals.setImmediate) ? globals.setImmediate : typeof process === 'object' && process.nextTick ? process.nextTick : makePromiseAsap() || (ES.IsCallable(makeZeroTimeout) ? makeZeroTimeout() : function (task) {\n            setTimeout(task, 0);\n          }); // fallback\n\n          /* jscs:enable disallowMultiLineTernary */\n          // Constants for Promise implementation\n\n          var PROMISE_IDENTITY = function (x) {\n            return x;\n          };\n\n          var PROMISE_THROWER = function (e) {\n            throw e;\n          };\n\n          var PROMISE_PENDING = 0;\n          var PROMISE_FULFILLED = 1;\n          var PROMISE_REJECTED = 2; // We store fulfill/reject handlers and capabilities in a single array.\n\n          var PROMISE_FULFILL_OFFSET = 0;\n          var PROMISE_REJECT_OFFSET = 1;\n          var PROMISE_CAPABILITY_OFFSET = 2; // This is used in an optimization for chaining promises via then.\n\n          var PROMISE_FAKE_CAPABILITY = {};\n\n          var enqueuePromiseReactionJob = function (handler, capability, argument) {\n            enqueue(function () {\n              promiseReactionJob(handler, capability, argument);\n            });\n          };\n\n          var promiseReactionJob = function (handler, promiseCapability, argument) {\n            var handlerResult, f;\n\n            if (promiseCapability === PROMISE_FAKE_CAPABILITY) {\n              // Fast case, when we don't actually need to chain through to a\n              // (real) promiseCapability.\n              return handler(argument);\n            }\n\n            try {\n              handlerResult = handler(argument);\n              f = promiseCapability.resolve;\n            } catch (e) {\n              handlerResult = e;\n              f = promiseCapability.reject;\n            }\n\n            f(handlerResult);\n          };\n\n          var fulfillPromise = function (promise, value) {\n            var _promise = promise._promise;\n            var length = _promise.reactionLength;\n\n            if (length > 0) {\n              enqueuePromiseReactionJob(_promise.fulfillReactionHandler0, _promise.reactionCapability0, value);\n              _promise.fulfillReactionHandler0 = void 0;\n              _promise.rejectReactions0 = void 0;\n              _promise.reactionCapability0 = void 0;\n\n              if (length > 1) {\n                for (var i = 1, idx = 0; i < length; i++, idx += 3) {\n                  enqueuePromiseReactionJob(_promise[idx + PROMISE_FULFILL_OFFSET], _promise[idx + PROMISE_CAPABILITY_OFFSET], value);\n                  promise[idx + PROMISE_FULFILL_OFFSET] = void 0;\n                  promise[idx + PROMISE_REJECT_OFFSET] = void 0;\n                  promise[idx + PROMISE_CAPABILITY_OFFSET] = void 0;\n                }\n              }\n            }\n\n            _promise.result = value;\n            _promise.state = PROMISE_FULFILLED;\n            _promise.reactionLength = 0;\n          };\n\n          var rejectPromise = function (promise, reason) {\n            var _promise = promise._promise;\n            var length = _promise.reactionLength;\n\n            if (length > 0) {\n              enqueuePromiseReactionJob(_promise.rejectReactionHandler0, _promise.reactionCapability0, reason);\n              _promise.fulfillReactionHandler0 = void 0;\n              _promise.rejectReactions0 = void 0;\n              _promise.reactionCapability0 = void 0;\n\n              if (length > 1) {\n                for (var i = 1, idx = 0; i < length; i++, idx += 3) {\n                  enqueuePromiseReactionJob(_promise[idx + PROMISE_REJECT_OFFSET], _promise[idx + PROMISE_CAPABILITY_OFFSET], reason);\n                  promise[idx + PROMISE_FULFILL_OFFSET] = void 0;\n                  promise[idx + PROMISE_REJECT_OFFSET] = void 0;\n                  promise[idx + PROMISE_CAPABILITY_OFFSET] = void 0;\n                }\n              }\n            }\n\n            _promise.result = reason;\n            _promise.state = PROMISE_REJECTED;\n            _promise.reactionLength = 0;\n          };\n\n          var createResolvingFunctions = function (promise) {\n            var alreadyResolved = false;\n\n            var resolve = function (resolution) {\n              var then;\n\n              if (alreadyResolved) {\n                return;\n              }\n\n              alreadyResolved = true;\n\n              if (resolution === promise) {\n                return rejectPromise(promise, new TypeError('Self resolution'));\n              }\n\n              if (!ES.TypeIsObject(resolution)) {\n                return fulfillPromise(promise, resolution);\n              }\n\n              try {\n                then = resolution.then;\n              } catch (e) {\n                return rejectPromise(promise, e);\n              }\n\n              if (!ES.IsCallable(then)) {\n                return fulfillPromise(promise, resolution);\n              }\n\n              enqueue(function () {\n                promiseResolveThenableJob(promise, resolution, then);\n              });\n            };\n\n            var reject = function (reason) {\n              if (alreadyResolved) {\n                return;\n              }\n\n              alreadyResolved = true;\n              return rejectPromise(promise, reason);\n            };\n\n            return {\n              resolve: resolve,\n              reject: reject\n            };\n          };\n\n          var optimizedThen = function (then, thenable, resolve, reject) {\n            // Optimization: since we discard the result, we can pass our\n            // own then implementation a special hint to let it know it\n            // doesn't have to create it.  (The PROMISE_FAKE_CAPABILITY\n            // object is local to this implementation and unforgeable outside.)\n            if (then === Promise$prototype$then) {\n              _call(then, thenable, resolve, reject, PROMISE_FAKE_CAPABILITY);\n            } else {\n              _call(then, thenable, resolve, reject);\n            }\n          };\n\n          var promiseResolveThenableJob = function (promise, thenable, then) {\n            var resolvingFunctions = createResolvingFunctions(promise);\n            var resolve = resolvingFunctions.resolve;\n            var reject = resolvingFunctions.reject;\n\n            try {\n              optimizedThen(then, thenable, resolve, reject);\n            } catch (e) {\n              reject(e);\n            }\n          };\n\n          var Promise$prototype, Promise$prototype$then;\n\n          var Promise = function () {\n            var PromiseShim = function Promise(resolver) {\n              if (!(this instanceof PromiseShim)) {\n                throw new TypeError('Constructor Promise requires \"new\"');\n              }\n\n              if (this && this._promise) {\n                throw new TypeError('Bad construction');\n              } // see https://bugs.ecmascript.org/show_bug.cgi?id=2482\n\n\n              if (!ES.IsCallable(resolver)) {\n                throw new TypeError('not a valid resolver');\n              }\n\n              var promise = emulateES6construct(this, PromiseShim, Promise$prototype, {\n                _promise: {\n                  result: void 0,\n                  state: PROMISE_PENDING,\n                  // The first member of the \"reactions\" array is inlined here,\n                  // since most promises only have one reaction.\n                  // We've also exploded the 'reaction' object to inline the\n                  // \"handler\" and \"capability\" fields, since both fulfill and\n                  // reject reactions share the same capability.\n                  reactionLength: 0,\n                  fulfillReactionHandler0: void 0,\n                  rejectReactionHandler0: void 0,\n                  reactionCapability0: void 0\n                }\n              });\n              var resolvingFunctions = createResolvingFunctions(promise);\n              var reject = resolvingFunctions.reject;\n\n              try {\n                resolver(resolvingFunctions.resolve, reject);\n              } catch (e) {\n                reject(e);\n              }\n\n              return promise;\n            };\n\n            return PromiseShim;\n          }();\n\n          Promise$prototype = Promise.prototype;\n\n          var _promiseAllResolver = function (index, values, capability, remaining) {\n            var alreadyCalled = false;\n            return function (x) {\n              if (alreadyCalled) {\n                return;\n              }\n\n              alreadyCalled = true;\n              values[index] = x;\n\n              if (--remaining.count === 0) {\n                var resolve = capability.resolve;\n                resolve(values); // call w/ this===undefined\n              }\n            };\n          };\n\n          var performPromiseAll = function (iteratorRecord, C, resultCapability) {\n            var it = iteratorRecord.iterator;\n            var values = [];\n            var remaining = {\n              count: 1\n            };\n            var next, nextValue;\n            var index = 0;\n\n            while (true) {\n              try {\n                next = ES.IteratorStep(it);\n\n                if (next === false) {\n                  iteratorRecord.done = true;\n                  break;\n                }\n\n                nextValue = next.value;\n              } catch (e) {\n                iteratorRecord.done = true;\n                throw e;\n              }\n\n              values[index] = void 0;\n              var nextPromise = C.resolve(nextValue);\n\n              var resolveElement = _promiseAllResolver(index, values, resultCapability, remaining);\n\n              remaining.count += 1;\n              optimizedThen(nextPromise.then, nextPromise, resolveElement, resultCapability.reject);\n              index += 1;\n            }\n\n            if (--remaining.count === 0) {\n              var resolve = resultCapability.resolve;\n              resolve(values); // call w/ this===undefined\n            }\n\n            return resultCapability.promise;\n          };\n\n          var performPromiseRace = function (iteratorRecord, C, resultCapability) {\n            var it = iteratorRecord.iterator;\n            var next, nextValue, nextPromise;\n\n            while (true) {\n              try {\n                next = ES.IteratorStep(it);\n\n                if (next === false) {\n                  // NOTE: If iterable has no items, resulting promise will never\n                  // resolve; see:\n                  // https://github.com/domenic/promises-unwrapping/issues/75\n                  // https://bugs.ecmascript.org/show_bug.cgi?id=2515\n                  iteratorRecord.done = true;\n                  break;\n                }\n\n                nextValue = next.value;\n              } catch (e) {\n                iteratorRecord.done = true;\n                throw e;\n              }\n\n              nextPromise = C.resolve(nextValue);\n              optimizedThen(nextPromise.then, nextPromise, resultCapability.resolve, resultCapability.reject);\n            }\n\n            return resultCapability.promise;\n          };\n\n          defineProperties(Promise, {\n            all: function all(iterable) {\n              var C = this;\n\n              if (!ES.TypeIsObject(C)) {\n                throw new TypeError('Promise is not object');\n              }\n\n              var capability = new PromiseCapability(C);\n              var iterator, iteratorRecord;\n\n              try {\n                iterator = ES.GetIterator(iterable);\n                iteratorRecord = {\n                  iterator: iterator,\n                  done: false\n                };\n                return performPromiseAll(iteratorRecord, C, capability);\n              } catch (e) {\n                var exception = e;\n\n                if (iteratorRecord && !iteratorRecord.done) {\n                  try {\n                    ES.IteratorClose(iterator, true);\n                  } catch (ee) {\n                    exception = ee;\n                  }\n                }\n\n                var reject = capability.reject;\n                reject(exception);\n                return capability.promise;\n              }\n            },\n            race: function race(iterable) {\n              var C = this;\n\n              if (!ES.TypeIsObject(C)) {\n                throw new TypeError('Promise is not object');\n              }\n\n              var capability = new PromiseCapability(C);\n              var iterator, iteratorRecord;\n\n              try {\n                iterator = ES.GetIterator(iterable);\n                iteratorRecord = {\n                  iterator: iterator,\n                  done: false\n                };\n                return performPromiseRace(iteratorRecord, C, capability);\n              } catch (e) {\n                var exception = e;\n\n                if (iteratorRecord && !iteratorRecord.done) {\n                  try {\n                    ES.IteratorClose(iterator, true);\n                  } catch (ee) {\n                    exception = ee;\n                  }\n                }\n\n                var reject = capability.reject;\n                reject(exception);\n                return capability.promise;\n              }\n            },\n            reject: function reject(reason) {\n              var C = this;\n\n              if (!ES.TypeIsObject(C)) {\n                throw new TypeError('Bad promise constructor');\n              }\n\n              var capability = new PromiseCapability(C);\n              var rejectFunc = capability.reject;\n              rejectFunc(reason); // call with this===undefined\n\n              return capability.promise;\n            },\n            resolve: function resolve(v) {\n              // See https://esdiscuss.org/topic/fixing-promise-resolve for spec\n              var C = this;\n\n              if (!ES.TypeIsObject(C)) {\n                throw new TypeError('Bad promise constructor');\n              }\n\n              if (ES.IsPromise(v)) {\n                var constructor = v.constructor;\n\n                if (constructor === C) {\n                  return v;\n                }\n              }\n\n              var capability = new PromiseCapability(C);\n              var resolveFunc = capability.resolve;\n              resolveFunc(v); // call with this===undefined\n\n              return capability.promise;\n            }\n          });\n          defineProperties(Promise$prototype, {\n            'catch': function (onRejected) {\n              return this.then(null, onRejected);\n            },\n            then: function then(onFulfilled, onRejected) {\n              var promise = this;\n\n              if (!ES.IsPromise(promise)) {\n                throw new TypeError('not a promise');\n              }\n\n              var C = ES.SpeciesConstructor(promise, Promise);\n              var resultCapability;\n              var returnValueIsIgnored = arguments.length > 2 && arguments[2] === PROMISE_FAKE_CAPABILITY;\n\n              if (returnValueIsIgnored && C === Promise) {\n                resultCapability = PROMISE_FAKE_CAPABILITY;\n              } else {\n                resultCapability = new PromiseCapability(C);\n              } // PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability)\n              // Note that we've split the 'reaction' object into its two\n              // components, \"capabilities\" and \"handler\"\n              // \"capabilities\" is always equal to `resultCapability`\n\n\n              var fulfillReactionHandler = ES.IsCallable(onFulfilled) ? onFulfilled : PROMISE_IDENTITY;\n              var rejectReactionHandler = ES.IsCallable(onRejected) ? onRejected : PROMISE_THROWER;\n              var _promise = promise._promise;\n              var value;\n\n              if (_promise.state === PROMISE_PENDING) {\n                if (_promise.reactionLength === 0) {\n                  _promise.fulfillReactionHandler0 = fulfillReactionHandler;\n                  _promise.rejectReactionHandler0 = rejectReactionHandler;\n                  _promise.reactionCapability0 = resultCapability;\n                } else {\n                  var idx = 3 * (_promise.reactionLength - 1);\n                  _promise[idx + PROMISE_FULFILL_OFFSET] = fulfillReactionHandler;\n                  _promise[idx + PROMISE_REJECT_OFFSET] = rejectReactionHandler;\n                  _promise[idx + PROMISE_CAPABILITY_OFFSET] = resultCapability;\n                }\n\n                _promise.reactionLength += 1;\n              } else if (_promise.state === PROMISE_FULFILLED) {\n                value = _promise.result;\n                enqueuePromiseReactionJob(fulfillReactionHandler, resultCapability, value);\n              } else if (_promise.state === PROMISE_REJECTED) {\n                value = _promise.result;\n                enqueuePromiseReactionJob(rejectReactionHandler, resultCapability, value);\n              } else {\n                throw new TypeError('unexpected Promise state');\n              }\n\n              return resultCapability.promise;\n            }\n          }); // This helps the optimizer by ensuring that methods which take\n          // capabilities aren't polymorphic.\n\n          PROMISE_FAKE_CAPABILITY = new PromiseCapability(Promise);\n          Promise$prototype$then = Promise$prototype.then;\n          return Promise;\n        }(); // Chrome's native Promise has extra methods that it shouldn't have. Let's remove them.\n\n\n        if (globals.Promise) {\n          delete globals.Promise.accept;\n          delete globals.Promise.defer;\n          delete globals.Promise.prototype.chain;\n        }\n\n        if (typeof PromiseShim === 'function') {\n          // export the Promise constructor.\n          defineProperties(globals, {\n            Promise: PromiseShim\n          }); // In Chrome 33 (and thereabouts) Promise is defined, but the\n          // implementation is buggy in a number of ways.  Let's check subclassing\n          // support to see if we have a buggy implementation.\n\n          var promiseSupportsSubclassing = supportsSubclassing(globals.Promise, function (S) {\n            return S.resolve(42).then(function () {}) instanceof S;\n          });\n          var promiseIgnoresNonFunctionThenCallbacks = !throwsError(function () {\n            globals.Promise.reject(42).then(null, 5).then(null, noop);\n          });\n          var promiseRequiresObjectContext = throwsError(function () {\n            globals.Promise.call(3, noop);\n          }); // Promise.resolve() was errata'ed late in the ES6 process.\n          // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1170742\n          //      https://code.google.com/p/v8/issues/detail?id=4161\n          // It serves as a proxy for a number of other bugs in early Promise\n          // implementations.\n\n          var promiseResolveBroken = function (Promise) {\n            var p = Promise.resolve(5);\n            p.constructor = {};\n            var p2 = Promise.resolve(p);\n\n            try {\n              p2.then(null, noop).then(null, noop); // avoid \"uncaught rejection\" warnings in console\n            } catch (e) {\n              return true; // v8 native Promises break here https://code.google.com/p/chromium/issues/detail?id=575314\n            }\n\n            return p === p2; // This *should* be false!\n          }(globals.Promise); // Chrome 46 (probably older too) does not retrieve a thenable's .then synchronously\n\n\n          var getsThenSynchronously = supportsDescriptors && function () {\n            var count = 0;\n            var thenable = Object.defineProperty({}, 'then', {\n              get: function () {\n                count += 1;\n              }\n            });\n            Promise.resolve(thenable);\n            return count === 1;\n          }();\n\n          var BadResolverPromise = function BadResolverPromise(executor) {\n            var p = new Promise(executor);\n            executor(3, function () {});\n            this.then = p.then;\n            this.constructor = BadResolverPromise;\n          };\n\n          BadResolverPromise.prototype = Promise.prototype;\n          BadResolverPromise.all = Promise.all; // Chrome Canary 49 (probably older too) has some implementation bugs\n\n          var hasBadResolverPromise = valueOrFalseIfThrows(function () {\n            return !!BadResolverPromise.all([1, 2]);\n          });\n\n          if (!promiseSupportsSubclassing || !promiseIgnoresNonFunctionThenCallbacks || !promiseRequiresObjectContext || promiseResolveBroken || !getsThenSynchronously || hasBadResolverPromise) {\n            /* globals Promise: true */\n\n            /* eslint-disable no-undef, no-global-assign */\n\n            /* jshint -W020 */\n            Promise = PromiseShim;\n            /* jshint +W020 */\n\n            /* eslint-enable no-undef, no-global-assign */\n\n            /* globals Promise: false */\n\n            overrideNative(globals, 'Promise', PromiseShim);\n          }\n\n          if (Promise.all.length !== 1) {\n            var origAll = Promise.all;\n            overrideNative(Promise, 'all', function all(iterable) {\n              return ES.Call(origAll, this, arguments);\n            });\n          }\n\n          if (Promise.race.length !== 1) {\n            var origRace = Promise.race;\n            overrideNative(Promise, 'race', function race(iterable) {\n              return ES.Call(origRace, this, arguments);\n            });\n          }\n\n          if (Promise.resolve.length !== 1) {\n            var origResolve = Promise.resolve;\n            overrideNative(Promise, 'resolve', function resolve(x) {\n              return ES.Call(origResolve, this, arguments);\n            });\n          }\n\n          if (Promise.reject.length !== 1) {\n            var origReject = Promise.reject;\n            overrideNative(Promise, 'reject', function reject(r) {\n              return ES.Call(origReject, this, arguments);\n            });\n          }\n\n          ensureEnumerable(Promise, 'all');\n          ensureEnumerable(Promise, 'race');\n          ensureEnumerable(Promise, 'resolve');\n          ensureEnumerable(Promise, 'reject');\n          addDefaultSpecies(Promise);\n        } // Map and Set require a true ES5 environment\n        // Their fast path also requires that the environment preserve\n        // property insertion order, which is not guaranteed by the spec.\n\n\n        var testOrder = function (a) {\n          var b = keys(_reduce(a, function (o, k) {\n            o[k] = true;\n            return o;\n          }, {}));\n          return a.join(':') === b.join(':');\n        };\n\n        var preservesInsertionOrder = testOrder(['z', 'a', 'bb']); // some engines (eg, Chrome) only preserve insertion order for string keys\n\n        var preservesNumericInsertionOrder = testOrder(['z', 1, 'a', '3', 2]);\n\n        if (supportsDescriptors) {\n          var fastkey = function fastkey(key, skipInsertionOrderCheck) {\n            if (!skipInsertionOrderCheck && !preservesInsertionOrder) {\n              return null;\n            }\n\n            if (isNullOrUndefined(key)) {\n              return '^' + ES.ToString(key);\n            } else if (typeof key === 'string') {\n              return '$' + key;\n            } else if (typeof key === 'number') {\n              // note that -0 will get coerced to \"0\" when used as a property key\n              if (!preservesNumericInsertionOrder) {\n                return 'n' + key;\n              }\n\n              return key;\n            } else if (typeof key === 'boolean') {\n              return 'b' + key;\n            }\n\n            return null;\n          };\n\n          var emptyObject = function emptyObject() {\n            // accomodate some older not-quite-ES5 browsers\n            return Object.create ? Object.create(null) : {};\n          };\n\n          var addIterableToMap = function addIterableToMap(MapConstructor, map, iterable) {\n            if (isArray(iterable) || Type.string(iterable)) {\n              _forEach(iterable, function (entry) {\n                if (!ES.TypeIsObject(entry)) {\n                  throw new TypeError('Iterator value ' + entry + ' is not an entry object');\n                }\n\n                map.set(entry[0], entry[1]);\n              });\n            } else if (iterable instanceof MapConstructor) {\n              _call(MapConstructor.prototype.forEach, iterable, function (value, key) {\n                map.set(key, value);\n              });\n            } else {\n              var iter, adder;\n\n              if (!isNullOrUndefined(iterable)) {\n                adder = map.set;\n\n                if (!ES.IsCallable(adder)) {\n                  throw new TypeError('bad map');\n                }\n\n                iter = ES.GetIterator(iterable);\n              }\n\n              if (typeof iter !== 'undefined') {\n                while (true) {\n                  var next = ES.IteratorStep(iter);\n\n                  if (next === false) {\n                    break;\n                  }\n\n                  var nextItem = next.value;\n\n                  try {\n                    if (!ES.TypeIsObject(nextItem)) {\n                      throw new TypeError('Iterator value ' + nextItem + ' is not an entry object');\n                    }\n\n                    _call(adder, map, nextItem[0], nextItem[1]);\n                  } catch (e) {\n                    ES.IteratorClose(iter, true);\n                    throw e;\n                  }\n                }\n              }\n            }\n          };\n\n          var addIterableToSet = function addIterableToSet(SetConstructor, set, iterable) {\n            if (isArray(iterable) || Type.string(iterable)) {\n              _forEach(iterable, function (value) {\n                set.add(value);\n              });\n            } else if (iterable instanceof SetConstructor) {\n              _call(SetConstructor.prototype.forEach, iterable, function (value) {\n                set.add(value);\n              });\n            } else {\n              var iter, adder;\n\n              if (!isNullOrUndefined(iterable)) {\n                adder = set.add;\n\n                if (!ES.IsCallable(adder)) {\n                  throw new TypeError('bad set');\n                }\n\n                iter = ES.GetIterator(iterable);\n              }\n\n              if (typeof iter !== 'undefined') {\n                while (true) {\n                  var next = ES.IteratorStep(iter);\n\n                  if (next === false) {\n                    break;\n                  }\n\n                  var nextValue = next.value;\n\n                  try {\n                    _call(adder, set, nextValue);\n                  } catch (e) {\n                    ES.IteratorClose(iter, true);\n                    throw e;\n                  }\n                }\n              }\n            }\n          };\n\n          var collectionShims = {\n            Map: function () {\n              var empty = {};\n\n              var MapEntry = function MapEntry(key, value) {\n                this.key = key;\n                this.value = value;\n                this.next = null;\n                this.prev = null;\n              };\n\n              MapEntry.prototype.isRemoved = function isRemoved() {\n                return this.key === empty;\n              };\n\n              var isMap = function isMap(map) {\n                return !!map._es6map;\n              };\n\n              var requireMapSlot = function requireMapSlot(map, method) {\n                if (!ES.TypeIsObject(map) || !isMap(map)) {\n                  throw new TypeError('Method Map.prototype.' + method + ' called on incompatible receiver ' + ES.ToString(map));\n                }\n              };\n\n              var MapIterator = function MapIterator(map, kind) {\n                requireMapSlot(map, '[[MapIterator]]');\n                this.head = map._head;\n                this.i = this.head;\n                this.kind = kind;\n              };\n\n              MapIterator.prototype = {\n                next: function next() {\n                  var i = this.i;\n                  var kind = this.kind;\n                  var head = this.head;\n\n                  if (typeof this.i === 'undefined') {\n                    return iteratorResult();\n                  }\n\n                  while (i.isRemoved() && i !== head) {\n                    // back up off of removed entries\n                    i = i.prev;\n                  } // advance to next unreturned element.\n\n\n                  var result;\n\n                  while (i.next !== head) {\n                    i = i.next;\n\n                    if (!i.isRemoved()) {\n                      if (kind === 'key') {\n                        result = i.key;\n                      } else if (kind === 'value') {\n                        result = i.value;\n                      } else {\n                        result = [i.key, i.value];\n                      }\n\n                      this.i = i;\n                      return iteratorResult(result);\n                    }\n                  } // once the iterator is done, it is done forever.\n\n\n                  this.i = void 0;\n                  return iteratorResult();\n                }\n              };\n              addIterator(MapIterator.prototype);\n              var Map$prototype;\n\n              var MapShim = function Map() {\n                if (!(this instanceof Map)) {\n                  throw new TypeError('Constructor Map requires \"new\"');\n                }\n\n                if (this && this._es6map) {\n                  throw new TypeError('Bad construction');\n                }\n\n                var map = emulateES6construct(this, Map, Map$prototype, {\n                  _es6map: true,\n                  _head: null,\n                  _map: OrigMap ? new OrigMap() : null,\n                  _size: 0,\n                  _storage: emptyObject()\n                });\n                var head = new MapEntry(null, null); // circular doubly-linked list.\n\n                /* eslint no-multi-assign: 1 */\n\n                head.next = head.prev = head;\n                map._head = head; // Optionally initialize map from iterable\n\n                if (arguments.length > 0) {\n                  addIterableToMap(Map, map, arguments[0]);\n                }\n\n                return map;\n              };\n\n              Map$prototype = MapShim.prototype;\n              Value.getter(Map$prototype, 'size', function () {\n                if (typeof this._size === 'undefined') {\n                  throw new TypeError('size method called on incompatible Map');\n                }\n\n                return this._size;\n              });\n              defineProperties(Map$prototype, {\n                get: function get(key) {\n                  requireMapSlot(this, 'get');\n                  var entry;\n                  var fkey = fastkey(key, true);\n\n                  if (fkey !== null) {\n                    // fast O(1) path\n                    entry = this._storage[fkey];\n\n                    if (entry) {\n                      return entry.value;\n                    } else {\n                      return;\n                    }\n                  }\n\n                  if (this._map) {\n                    // fast object key path\n                    entry = origMapGet.call(this._map, key);\n\n                    if (entry) {\n                      return entry.value;\n                    } else {\n                      return;\n                    }\n                  }\n\n                  var head = this._head;\n                  var i = head;\n\n                  while ((i = i.next) !== head) {\n                    if (ES.SameValueZero(i.key, key)) {\n                      return i.value;\n                    }\n                  }\n                },\n                has: function has(key) {\n                  requireMapSlot(this, 'has');\n                  var fkey = fastkey(key, true);\n\n                  if (fkey !== null) {\n                    // fast O(1) path\n                    return typeof this._storage[fkey] !== 'undefined';\n                  }\n\n                  if (this._map) {\n                    // fast object key path\n                    return origMapHas.call(this._map, key);\n                  }\n\n                  var head = this._head;\n                  var i = head;\n\n                  while ((i = i.next) !== head) {\n                    if (ES.SameValueZero(i.key, key)) {\n                      return true;\n                    }\n                  }\n\n                  return false;\n                },\n                set: function set(key, value) {\n                  requireMapSlot(this, 'set');\n                  var head = this._head;\n                  var i = head;\n                  var entry;\n                  var fkey = fastkey(key, true);\n\n                  if (fkey !== null) {\n                    // fast O(1) path\n                    if (typeof this._storage[fkey] !== 'undefined') {\n                      this._storage[fkey].value = value;\n                      return this;\n                    } else {\n                      entry = this._storage[fkey] = new MapEntry(key, value);\n                      /* eslint no-multi-assign: 1 */\n\n                      i = head.prev; // fall through\n                    }\n                  } else if (this._map) {\n                    // fast object key path\n                    if (origMapHas.call(this._map, key)) {\n                      origMapGet.call(this._map, key).value = value;\n                    } else {\n                      entry = new MapEntry(key, value);\n                      origMapSet.call(this._map, key, entry);\n                      i = head.prev; // fall through\n                    }\n                  }\n\n                  while ((i = i.next) !== head) {\n                    if (ES.SameValueZero(i.key, key)) {\n                      i.value = value;\n                      return this;\n                    }\n                  }\n\n                  entry = entry || new MapEntry(key, value);\n\n                  if (ES.SameValue(-0, key)) {\n                    entry.key = +0; // coerce -0 to +0 in entry\n                  }\n\n                  entry.next = this._head;\n                  entry.prev = this._head.prev;\n                  entry.prev.next = entry;\n                  entry.next.prev = entry;\n                  this._size += 1;\n                  return this;\n                },\n                'delete': function (key) {\n                  requireMapSlot(this, 'delete');\n                  var head = this._head;\n                  var i = head;\n                  var fkey = fastkey(key, true);\n\n                  if (fkey !== null) {\n                    // fast O(1) path\n                    if (typeof this._storage[fkey] === 'undefined') {\n                      return false;\n                    }\n\n                    i = this._storage[fkey].prev;\n                    delete this._storage[fkey]; // fall through\n                  } else if (this._map) {\n                    // fast object key path\n                    if (!origMapHas.call(this._map, key)) {\n                      return false;\n                    }\n\n                    i = origMapGet.call(this._map, key).prev;\n                    origMapDelete.call(this._map, key); // fall through\n                  }\n\n                  while ((i = i.next) !== head) {\n                    if (ES.SameValueZero(i.key, key)) {\n                      i.key = empty;\n                      i.value = empty;\n                      i.prev.next = i.next;\n                      i.next.prev = i.prev;\n                      this._size -= 1;\n                      return true;\n                    }\n                  }\n\n                  return false;\n                },\n                clear: function clear() {\n                  /* eslint no-multi-assign: 1 */\n                  requireMapSlot(this, 'clear');\n                  this._map = OrigMap ? new OrigMap() : null;\n                  this._size = 0;\n                  this._storage = emptyObject();\n                  var head = this._head;\n                  var i = head;\n                  var p = i.next;\n\n                  while ((i = p) !== head) {\n                    i.key = empty;\n                    i.value = empty;\n                    p = i.next;\n                    i.next = i.prev = head;\n                  }\n\n                  head.next = head.prev = head;\n                },\n                keys: function keys() {\n                  requireMapSlot(this, 'keys');\n                  return new MapIterator(this, 'key');\n                },\n                values: function values() {\n                  requireMapSlot(this, 'values');\n                  return new MapIterator(this, 'value');\n                },\n                entries: function entries() {\n                  requireMapSlot(this, 'entries');\n                  return new MapIterator(this, 'key+value');\n                },\n                forEach: function forEach(callback) {\n                  requireMapSlot(this, 'forEach');\n                  var context = arguments.length > 1 ? arguments[1] : null;\n                  var it = this.entries();\n\n                  for (var entry = it.next(); !entry.done; entry = it.next()) {\n                    if (context) {\n                      _call(callback, context, entry.value[1], entry.value[0], this);\n                    } else {\n                      callback(entry.value[1], entry.value[0], this);\n                    }\n                  }\n                }\n              });\n              addIterator(Map$prototype, Map$prototype.entries);\n              return MapShim;\n            }(),\n            Set: function () {\n              var isSet = function isSet(set) {\n                return set._es6set && typeof set._storage !== 'undefined';\n              };\n\n              var requireSetSlot = function requireSetSlot(set, method) {\n                if (!ES.TypeIsObject(set) || !isSet(set)) {\n                  // https://github.com/paulmillr/es6-shim/issues/176\n                  throw new TypeError('Set.prototype.' + method + ' called on incompatible receiver ' + ES.ToString(set));\n                }\n              }; // Creating a Map is expensive.  To speed up the common case of\n              // Sets containing only string or numeric keys, we use an object\n              // as backing storage and lazily create a full Map only when\n              // required.\n\n\n              var Set$prototype;\n\n              var SetShim = function Set() {\n                if (!(this instanceof Set)) {\n                  throw new TypeError('Constructor Set requires \"new\"');\n                }\n\n                if (this && this._es6set) {\n                  throw new TypeError('Bad construction');\n                }\n\n                var set = emulateES6construct(this, Set, Set$prototype, {\n                  _es6set: true,\n                  '[[SetData]]': null,\n                  _storage: emptyObject()\n                });\n\n                if (!set._es6set) {\n                  throw new TypeError('bad set');\n                } // Optionally initialize Set from iterable\n\n\n                if (arguments.length > 0) {\n                  addIterableToSet(Set, set, arguments[0]);\n                }\n\n                return set;\n              };\n\n              Set$prototype = SetShim.prototype;\n\n              var decodeKey = function (key) {\n                var k = key;\n\n                if (k === '^null') {\n                  return null;\n                } else if (k === '^undefined') {\n                  return void 0;\n                } else {\n                  var first = k.charAt(0);\n\n                  if (first === '$') {\n                    return _strSlice(k, 1);\n                  } else if (first === 'n') {\n                    return +_strSlice(k, 1);\n                  } else if (first === 'b') {\n                    return k === 'btrue';\n                  }\n                }\n\n                return +k;\n              }; // Switch from the object backing storage to a full Map.\n\n\n              var ensureMap = function ensureMap(set) {\n                if (!set['[[SetData]]']) {\n                  var m = new collectionShims.Map();\n                  set['[[SetData]]'] = m;\n\n                  _forEach(keys(set._storage), function (key) {\n                    var k = decodeKey(key);\n                    m.set(k, k);\n                  });\n\n                  set['[[SetData]]'] = m;\n                }\n\n                set._storage = null; // free old backing storage\n              };\n\n              Value.getter(SetShim.prototype, 'size', function () {\n                requireSetSlot(this, 'size');\n\n                if (this._storage) {\n                  return keys(this._storage).length;\n                }\n\n                ensureMap(this);\n                return this['[[SetData]]'].size;\n              });\n              defineProperties(SetShim.prototype, {\n                has: function has(key) {\n                  requireSetSlot(this, 'has');\n                  var fkey;\n\n                  if (this._storage && (fkey = fastkey(key)) !== null) {\n                    return !!this._storage[fkey];\n                  }\n\n                  ensureMap(this);\n                  return this['[[SetData]]'].has(key);\n                },\n                add: function add(key) {\n                  requireSetSlot(this, 'add');\n                  var fkey;\n\n                  if (this._storage && (fkey = fastkey(key)) !== null) {\n                    this._storage[fkey] = true;\n                    return this;\n                  }\n\n                  ensureMap(this);\n                  this['[[SetData]]'].set(key, key);\n                  return this;\n                },\n                'delete': function (key) {\n                  requireSetSlot(this, 'delete');\n                  var fkey;\n\n                  if (this._storage && (fkey = fastkey(key)) !== null) {\n                    var hasFKey = _hasOwnProperty(this._storage, fkey);\n\n                    return delete this._storage[fkey] && hasFKey;\n                  }\n\n                  ensureMap(this);\n                  return this['[[SetData]]']['delete'](key);\n                },\n                clear: function clear() {\n                  requireSetSlot(this, 'clear');\n\n                  if (this._storage) {\n                    this._storage = emptyObject();\n                  }\n\n                  if (this['[[SetData]]']) {\n                    this['[[SetData]]'].clear();\n                  }\n                },\n                values: function values() {\n                  requireSetSlot(this, 'values');\n                  ensureMap(this);\n                  return this['[[SetData]]'].values();\n                },\n                entries: function entries() {\n                  requireSetSlot(this, 'entries');\n                  ensureMap(this);\n                  return this['[[SetData]]'].entries();\n                },\n                forEach: function forEach(callback) {\n                  requireSetSlot(this, 'forEach');\n                  var context = arguments.length > 1 ? arguments[1] : null;\n                  var entireSet = this;\n                  ensureMap(entireSet);\n                  this['[[SetData]]'].forEach(function (value, key) {\n                    if (context) {\n                      _call(callback, context, key, key, entireSet);\n                    } else {\n                      callback(key, key, entireSet);\n                    }\n                  });\n                }\n              });\n              defineProperty(SetShim.prototype, 'keys', SetShim.prototype.values, true);\n              addIterator(SetShim.prototype, SetShim.prototype.values);\n              return SetShim;\n            }()\n          };\n\n          if (globals.Map || globals.Set) {\n            // Safari 8, for example, doesn't accept an iterable.\n            var mapAcceptsArguments = valueOrFalseIfThrows(function () {\n              return new Map([[1, 2]]).get(1) === 2;\n            });\n\n            if (!mapAcceptsArguments) {\n              globals.Map = function Map() {\n                if (!(this instanceof Map)) {\n                  throw new TypeError('Constructor Map requires \"new\"');\n                }\n\n                var m = new OrigMap();\n\n                if (arguments.length > 0) {\n                  addIterableToMap(Map, m, arguments[0]);\n                }\n\n                delete m.constructor;\n                Object.setPrototypeOf(m, globals.Map.prototype);\n                return m;\n              };\n\n              globals.Map.prototype = create(OrigMap.prototype);\n              defineProperty(globals.Map.prototype, 'constructor', globals.Map, true);\n              Value.preserveToString(globals.Map, OrigMap);\n            }\n\n            var testMap = new Map();\n\n            var mapUsesSameValueZero = function () {\n              // Chrome 38-42, node 0.11/0.12, iojs 1/2 also have a bug when the Map has a size > 4\n              var m = new Map([[1, 0], [2, 0], [3, 0], [4, 0]]);\n              m.set(-0, m);\n              return m.get(0) === m && m.get(-0) === m && m.has(0) && m.has(-0);\n            }();\n\n            var mapSupportsChaining = testMap.set(1, 2) === testMap;\n\n            if (!mapUsesSameValueZero || !mapSupportsChaining) {\n              overrideNative(Map.prototype, 'set', function set(k, v) {\n                _call(origMapSet, this, k === 0 ? 0 : k, v);\n\n                return this;\n              });\n            }\n\n            if (!mapUsesSameValueZero) {\n              defineProperties(Map.prototype, {\n                get: function get(k) {\n                  return _call(origMapGet, this, k === 0 ? 0 : k);\n                },\n                has: function has(k) {\n                  return _call(origMapHas, this, k === 0 ? 0 : k);\n                }\n              }, true);\n              Value.preserveToString(Map.prototype.get, origMapGet);\n              Value.preserveToString(Map.prototype.has, origMapHas);\n            }\n\n            var testSet = new Set();\n\n            var setUsesSameValueZero = function (s) {\n              s['delete'](0);\n              s.add(-0);\n              return !s.has(0);\n            }(testSet);\n\n            var setSupportsChaining = testSet.add(1) === testSet;\n\n            if (!setUsesSameValueZero || !setSupportsChaining) {\n              var origSetAdd = Set.prototype.add;\n\n              Set.prototype.add = function add(v) {\n                _call(origSetAdd, this, v === 0 ? 0 : v);\n\n                return this;\n              };\n\n              Value.preserveToString(Set.prototype.add, origSetAdd);\n            }\n\n            if (!setUsesSameValueZero) {\n              var origSetHas = Set.prototype.has;\n\n              Set.prototype.has = function has(v) {\n                return _call(origSetHas, this, v === 0 ? 0 : v);\n              };\n\n              Value.preserveToString(Set.prototype.has, origSetHas);\n              var origSetDel = Set.prototype['delete'];\n\n              Set.prototype['delete'] = function SetDelete(v) {\n                return _call(origSetDel, this, v === 0 ? 0 : v);\n              };\n\n              Value.preserveToString(Set.prototype['delete'], origSetDel);\n            }\n\n            var mapSupportsSubclassing = supportsSubclassing(globals.Map, function (M) {\n              var m = new M([]); // Firefox 32 is ok with the instantiating the subclass but will\n              // throw when the map is used.\n\n              m.set(42, 42);\n              return m instanceof M;\n            }); // without Object.setPrototypeOf, subclassing is not possible\n\n            var mapFailsToSupportSubclassing = Object.setPrototypeOf && !mapSupportsSubclassing;\n\n            var mapRequiresNew = function () {\n              try {\n                return !(globals.Map() instanceof globals.Map);\n              } catch (e) {\n                return e instanceof TypeError;\n              }\n            }();\n\n            if (globals.Map.length !== 0 || mapFailsToSupportSubclassing || !mapRequiresNew) {\n              globals.Map = function Map() {\n                if (!(this instanceof Map)) {\n                  throw new TypeError('Constructor Map requires \"new\"');\n                }\n\n                var m = new OrigMap();\n\n                if (arguments.length > 0) {\n                  addIterableToMap(Map, m, arguments[0]);\n                }\n\n                delete m.constructor;\n                Object.setPrototypeOf(m, Map.prototype);\n                return m;\n              };\n\n              globals.Map.prototype = OrigMap.prototype;\n              defineProperty(globals.Map.prototype, 'constructor', globals.Map, true);\n              Value.preserveToString(globals.Map, OrigMap);\n            }\n\n            var setSupportsSubclassing = supportsSubclassing(globals.Set, function (S) {\n              var s = new S([]);\n              s.add(42, 42);\n              return s instanceof S;\n            }); // without Object.setPrototypeOf, subclassing is not possible\n\n            var setFailsToSupportSubclassing = Object.setPrototypeOf && !setSupportsSubclassing;\n\n            var setRequiresNew = function () {\n              try {\n                return !(globals.Set() instanceof globals.Set);\n              } catch (e) {\n                return e instanceof TypeError;\n              }\n            }();\n\n            if (globals.Set.length !== 0 || setFailsToSupportSubclassing || !setRequiresNew) {\n              var OrigSet = globals.Set;\n\n              globals.Set = function Set() {\n                if (!(this instanceof Set)) {\n                  throw new TypeError('Constructor Set requires \"new\"');\n                }\n\n                var s = new OrigSet();\n\n                if (arguments.length > 0) {\n                  addIterableToSet(Set, s, arguments[0]);\n                }\n\n                delete s.constructor;\n                Object.setPrototypeOf(s, Set.prototype);\n                return s;\n              };\n\n              globals.Set.prototype = OrigSet.prototype;\n              defineProperty(globals.Set.prototype, 'constructor', globals.Set, true);\n              Value.preserveToString(globals.Set, OrigSet);\n            }\n\n            var newMap = new globals.Map();\n            var mapIterationThrowsStopIterator = !valueOrFalseIfThrows(function () {\n              return newMap.keys().next().done;\n            });\n            /*\n              - In Firefox < 23, Map#size is a function.\n              - In all current Firefox, Set#entries/keys/values & Map#clear do not exist\n              - https://bugzilla.mozilla.org/show_bug.cgi?id=869996\n              - In Firefox 24, Map and Set do not implement forEach\n              - In Firefox 25 at least, Map and Set are callable without \"new\"\n            */\n\n            if (typeof globals.Map.prototype.clear !== 'function' || new globals.Set().size !== 0 || newMap.size !== 0 || typeof globals.Map.prototype.keys !== 'function' || typeof globals.Set.prototype.keys !== 'function' || typeof globals.Map.prototype.forEach !== 'function' || typeof globals.Set.prototype.forEach !== 'function' || isCallableWithoutNew(globals.Map) || isCallableWithoutNew(globals.Set) || typeof newMap.keys().next !== 'function' || // Safari 8\n            mapIterationThrowsStopIterator || // Firefox 25\n            !mapSupportsSubclassing) {\n              defineProperties(globals, {\n                Map: collectionShims.Map,\n                Set: collectionShims.Set\n              }, true);\n            }\n\n            if (globals.Set.prototype.keys !== globals.Set.prototype.values) {\n              // Fixed in WebKit with https://bugs.webkit.org/show_bug.cgi?id=144190\n              defineProperty(globals.Set.prototype, 'keys', globals.Set.prototype.values, true);\n            } // Shim incomplete iterator implementations.\n\n\n            addIterator(Object.getPrototypeOf(new globals.Map().keys()));\n            addIterator(Object.getPrototypeOf(new globals.Set().keys()));\n\n            if (functionsHaveNames && globals.Set.prototype.has.name !== 'has') {\n              // Microsoft Edge v0.11.10074.0 is missing a name on Set#has\n              var anonymousSetHas = globals.Set.prototype.has;\n              overrideNative(globals.Set.prototype, 'has', function has(key) {\n                return _call(anonymousSetHas, this, key);\n              });\n            }\n          }\n\n          defineProperties(globals, collectionShims);\n          addDefaultSpecies(globals.Map);\n          addDefaultSpecies(globals.Set);\n        }\n\n        var throwUnlessTargetIsObject = function throwUnlessTargetIsObject(target) {\n          if (!ES.TypeIsObject(target)) {\n            throw new TypeError('target must be an object');\n          }\n        }; // Some Reflect methods are basically the same as\n        // those on the Object global, except that a TypeError is thrown if\n        // target isn't an object. As well as returning a boolean indicating\n        // the success of the operation.\n\n\n        var ReflectShims = {\n          // Apply method in a functional form.\n          apply: function apply() {\n            return ES.Call(ES.Call, null, arguments);\n          },\n          // New operator in a functional form.\n          construct: function construct(constructor, args) {\n            if (!ES.IsConstructor(constructor)) {\n              throw new TypeError('First argument must be a constructor.');\n            }\n\n            var newTarget = arguments.length > 2 ? arguments[2] : constructor;\n\n            if (!ES.IsConstructor(newTarget)) {\n              throw new TypeError('new.target must be a constructor.');\n            }\n\n            return ES.Construct(constructor, args, newTarget, 'internal');\n          },\n          // When deleting a non-existent or configurable property,\n          // true is returned.\n          // When attempting to delete a non-configurable property,\n          // it will return false.\n          deleteProperty: function deleteProperty(target, key) {\n            throwUnlessTargetIsObject(target);\n\n            if (supportsDescriptors) {\n              var desc = Object.getOwnPropertyDescriptor(target, key);\n\n              if (desc && !desc.configurable) {\n                return false;\n              }\n            } // Will return true.\n\n\n            return delete target[key];\n          },\n          has: function has(target, key) {\n            throwUnlessTargetIsObject(target);\n            return key in target;\n          }\n        };\n\n        if (Object.getOwnPropertyNames) {\n          Object.assign(ReflectShims, {\n            // Basically the result of calling the internal [[OwnPropertyKeys]].\n            // Concatenating propertyNames and propertySymbols should do the trick.\n            // This should continue to work together with a Symbol shim\n            // which overrides Object.getOwnPropertyNames and implements\n            // Object.getOwnPropertySymbols.\n            ownKeys: function ownKeys(target) {\n              throwUnlessTargetIsObject(target);\n              var keys = Object.getOwnPropertyNames(target);\n\n              if (ES.IsCallable(Object.getOwnPropertySymbols)) {\n                _pushApply(keys, Object.getOwnPropertySymbols(target));\n              }\n\n              return keys;\n            }\n          });\n        }\n\n        var callAndCatchException = function ConvertExceptionToBoolean(func) {\n          return !throwsError(func);\n        };\n\n        if (Object.preventExtensions) {\n          Object.assign(ReflectShims, {\n            isExtensible: function isExtensible(target) {\n              throwUnlessTargetIsObject(target);\n              return Object.isExtensible(target);\n            },\n            preventExtensions: function preventExtensions(target) {\n              throwUnlessTargetIsObject(target);\n              return callAndCatchException(function () {\n                Object.preventExtensions(target);\n              });\n            }\n          });\n        }\n\n        if (supportsDescriptors) {\n          var internalGet = function get(target, key, receiver) {\n            var desc = Object.getOwnPropertyDescriptor(target, key);\n\n            if (!desc) {\n              var parent = Object.getPrototypeOf(target);\n\n              if (parent === null) {\n                return void 0;\n              }\n\n              return internalGet(parent, key, receiver);\n            }\n\n            if ('value' in desc) {\n              return desc.value;\n            }\n\n            if (desc.get) {\n              return ES.Call(desc.get, receiver);\n            }\n\n            return void 0;\n          };\n\n          var internalSet = function set(target, key, value, receiver) {\n            var desc = Object.getOwnPropertyDescriptor(target, key);\n\n            if (!desc) {\n              var parent = Object.getPrototypeOf(target);\n\n              if (parent !== null) {\n                return internalSet(parent, key, value, receiver);\n              }\n\n              desc = {\n                value: void 0,\n                writable: true,\n                enumerable: true,\n                configurable: true\n              };\n            }\n\n            if ('value' in desc) {\n              if (!desc.writable) {\n                return false;\n              }\n\n              if (!ES.TypeIsObject(receiver)) {\n                return false;\n              }\n\n              var existingDesc = Object.getOwnPropertyDescriptor(receiver, key);\n\n              if (existingDesc) {\n                return Reflect.defineProperty(receiver, key, {\n                  value: value\n                });\n              } else {\n                return Reflect.defineProperty(receiver, key, {\n                  value: value,\n                  writable: true,\n                  enumerable: true,\n                  configurable: true\n                });\n              }\n            }\n\n            if (desc.set) {\n              _call(desc.set, receiver, value);\n\n              return true;\n            }\n\n            return false;\n          };\n\n          Object.assign(ReflectShims, {\n            defineProperty: function defineProperty(target, propertyKey, attributes) {\n              throwUnlessTargetIsObject(target);\n              return callAndCatchException(function () {\n                Object.defineProperty(target, propertyKey, attributes);\n              });\n            },\n            getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {\n              throwUnlessTargetIsObject(target);\n              return Object.getOwnPropertyDescriptor(target, propertyKey);\n            },\n            // Syntax in a functional form.\n            get: function get(target, key) {\n              throwUnlessTargetIsObject(target);\n              var receiver = arguments.length > 2 ? arguments[2] : target;\n              return internalGet(target, key, receiver);\n            },\n            set: function set(target, key, value) {\n              throwUnlessTargetIsObject(target);\n              var receiver = arguments.length > 3 ? arguments[3] : target;\n              return internalSet(target, key, value, receiver);\n            }\n          });\n        }\n\n        if (Object.getPrototypeOf) {\n          var objectDotGetPrototypeOf = Object.getPrototypeOf;\n\n          ReflectShims.getPrototypeOf = function getPrototypeOf(target) {\n            throwUnlessTargetIsObject(target);\n            return objectDotGetPrototypeOf(target);\n          };\n        }\n\n        if (Object.setPrototypeOf && ReflectShims.getPrototypeOf) {\n          var willCreateCircularPrototype = function (object, lastProto) {\n            var proto = lastProto;\n\n            while (proto) {\n              if (object === proto) {\n                return true;\n              }\n\n              proto = ReflectShims.getPrototypeOf(proto);\n            }\n\n            return false;\n          };\n\n          Object.assign(ReflectShims, {\n            // Sets the prototype of the given object.\n            // Returns true on success, otherwise false.\n            setPrototypeOf: function setPrototypeOf(object, proto) {\n              throwUnlessTargetIsObject(object);\n\n              if (proto !== null && !ES.TypeIsObject(proto)) {\n                throw new TypeError('proto must be an object or null');\n              } // If they already are the same, we're done.\n\n\n              if (proto === Reflect.getPrototypeOf(object)) {\n                return true;\n              } // Cannot alter prototype if object not extensible.\n\n\n              if (Reflect.isExtensible && !Reflect.isExtensible(object)) {\n                return false;\n              } // Ensure that we do not create a circular prototype chain.\n\n\n              if (willCreateCircularPrototype(object, proto)) {\n                return false;\n              }\n\n              Object.setPrototypeOf(object, proto);\n              return true;\n            }\n          });\n        }\n\n        var defineOrOverrideReflectProperty = function (key, shim) {\n          if (!ES.IsCallable(globals.Reflect[key])) {\n            defineProperty(globals.Reflect, key, shim);\n          } else {\n            var acceptsPrimitives = valueOrFalseIfThrows(function () {\n              globals.Reflect[key](1);\n              globals.Reflect[key](NaN);\n              globals.Reflect[key](true);\n              return true;\n            });\n\n            if (acceptsPrimitives) {\n              overrideNative(globals.Reflect, key, shim);\n            }\n          }\n        };\n\n        Object.keys(ReflectShims).forEach(function (key) {\n          defineOrOverrideReflectProperty(key, ReflectShims[key]);\n        });\n        var originalReflectGetProto = globals.Reflect.getPrototypeOf;\n\n        if (functionsHaveNames && originalReflectGetProto && originalReflectGetProto.name !== 'getPrototypeOf') {\n          overrideNative(globals.Reflect, 'getPrototypeOf', function getPrototypeOf(target) {\n            return _call(originalReflectGetProto, globals.Reflect, target);\n          });\n        }\n\n        if (globals.Reflect.setPrototypeOf) {\n          if (valueOrFalseIfThrows(function () {\n            globals.Reflect.setPrototypeOf(1, {});\n            return true;\n          })) {\n            overrideNative(globals.Reflect, 'setPrototypeOf', ReflectShims.setPrototypeOf);\n          }\n        }\n\n        if (globals.Reflect.defineProperty) {\n          if (!valueOrFalseIfThrows(function () {\n            var basic = !globals.Reflect.defineProperty(1, 'test', {\n              value: 1\n            }); // \"extensible\" fails on Edge 0.12\n\n            var extensible = typeof Object.preventExtensions !== 'function' || !globals.Reflect.defineProperty(Object.preventExtensions({}), 'test', {});\n            return basic && extensible;\n          })) {\n            overrideNative(globals.Reflect, 'defineProperty', ReflectShims.defineProperty);\n          }\n        }\n\n        if (globals.Reflect.construct) {\n          if (!valueOrFalseIfThrows(function () {\n            var F = function F() {};\n\n            return globals.Reflect.construct(function () {}, [], F) instanceof F;\n          })) {\n            overrideNative(globals.Reflect, 'construct', ReflectShims.construct);\n          }\n        }\n\n        if (String(new Date(NaN)) !== 'Invalid Date') {\n          var dateToString = Date.prototype.toString;\n\n          var shimmedDateToString = function toString() {\n            var valueOf = +this;\n\n            if (valueOf !== valueOf) {\n              return 'Invalid Date';\n            }\n\n            return ES.Call(dateToString, this);\n          };\n\n          overrideNative(Date.prototype, 'toString', shimmedDateToString);\n        } // Annex B HTML methods\n        // http://www.ecma-international.org/ecma-262/6.0/#sec-additional-properties-of-the-string.prototype-object\n\n\n        var stringHTMLshims = {\n          anchor: function anchor(name) {\n            return ES.CreateHTML(this, 'a', 'name', name);\n          },\n          big: function big() {\n            return ES.CreateHTML(this, 'big', '', '');\n          },\n          blink: function blink() {\n            return ES.CreateHTML(this, 'blink', '', '');\n          },\n          bold: function bold() {\n            return ES.CreateHTML(this, 'b', '', '');\n          },\n          fixed: function fixed() {\n            return ES.CreateHTML(this, 'tt', '', '');\n          },\n          fontcolor: function fontcolor(color) {\n            return ES.CreateHTML(this, 'font', 'color', color);\n          },\n          fontsize: function fontsize(size) {\n            return ES.CreateHTML(this, 'font', 'size', size);\n          },\n          italics: function italics() {\n            return ES.CreateHTML(this, 'i', '', '');\n          },\n          link: function link(url) {\n            return ES.CreateHTML(this, 'a', 'href', url);\n          },\n          small: function small() {\n            return ES.CreateHTML(this, 'small', '', '');\n          },\n          strike: function strike() {\n            return ES.CreateHTML(this, 'strike', '', '');\n          },\n          sub: function sub() {\n            return ES.CreateHTML(this, 'sub', '', '');\n          },\n          sup: function sub() {\n            return ES.CreateHTML(this, 'sup', '', '');\n          }\n        };\n\n        _forEach(Object.keys(stringHTMLshims), function (key) {\n          var method = String.prototype[key];\n          var shouldOverwrite = false;\n\n          if (ES.IsCallable(method)) {\n            var output = _call(method, '', ' \" ');\n\n            var quotesCount = _concat([], output.match(/\"/g)).length;\n\n            shouldOverwrite = output !== output.toLowerCase() || quotesCount > 2;\n          } else {\n            shouldOverwrite = true;\n          }\n\n          if (shouldOverwrite) {\n            overrideNative(String.prototype, key, stringHTMLshims[key]);\n          }\n        });\n\n        var JSONstringifiesSymbols = function () {\n          // Microsoft Edge v0.12 stringifies Symbols incorrectly\n          if (!hasSymbols) {\n            return false;\n          } // Symbols are not supported\n\n\n          var stringify = typeof JSON === 'object' && typeof JSON.stringify === 'function' ? JSON.stringify : null;\n\n          if (!stringify) {\n            return false;\n          } // JSON.stringify is not supported\n\n\n          if (typeof stringify(Symbol()) !== 'undefined') {\n            return true;\n          } // Symbols should become `undefined`\n\n\n          if (stringify([Symbol()]) !== '[null]') {\n            return true;\n          } // Symbols in arrays should become `null`\n\n\n          var obj = {\n            a: Symbol()\n          };\n          obj[Symbol()] = true;\n\n          if (stringify(obj) !== '{}') {\n            return true;\n          } // Symbol-valued keys *and* Symbol-valued properties should be omitted\n\n\n          return false;\n        }();\n\n        var JSONstringifyAcceptsObjectSymbol = valueOrFalseIfThrows(function () {\n          // Chrome 45 throws on stringifying object symbols\n          if (!hasSymbols) {\n            return true;\n          } // Symbols are not supported\n\n\n          return JSON.stringify(Object(Symbol())) === '{}' && JSON.stringify([Object(Symbol())]) === '[{}]';\n        });\n\n        if (JSONstringifiesSymbols || !JSONstringifyAcceptsObjectSymbol) {\n          var origStringify = JSON.stringify;\n          overrideNative(JSON, 'stringify', function stringify(value) {\n            if (typeof value === 'symbol') {\n              return;\n            }\n\n            var replacer;\n\n            if (arguments.length > 1) {\n              replacer = arguments[1];\n            }\n\n            var args = [value];\n\n            if (!isArray(replacer)) {\n              var replaceFn = ES.IsCallable(replacer) ? replacer : null;\n\n              var wrappedReplacer = function (key, val) {\n                var parsedValue = replaceFn ? _call(replaceFn, this, key, val) : val;\n\n                if (typeof parsedValue !== 'symbol') {\n                  if (Type.symbol(parsedValue)) {\n                    return assignTo({})(parsedValue);\n                  } else {\n                    return parsedValue;\n                  }\n                }\n              };\n\n              args.push(wrappedReplacer);\n            } else {\n              // create wrapped replacer that handles an array replacer?\n              args.push(replacer);\n            }\n\n            if (arguments.length > 2) {\n              args.push(arguments[2]);\n            }\n\n            return origStringify.apply(this, args);\n          });\n        }\n\n        return globals;\n      });\n    }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n  }, {\n    \"_process\": 19\n  }],\n  10: [function (require, module, exports) {\n    // Copyright Joyent, Inc. and other Node contributors.\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a\n    // copy of this software and associated documentation files (the\n    // \"Software\"), to deal in the Software without restriction, including\n    // without limitation the rights to use, copy, modify, merge, publish,\n    // distribute, sublicense, and/or sell copies of the Software, and to permit\n    // persons to whom the Software is furnished to do so, subject to the\n    // following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included\n    // in all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n    // USE OR OTHER DEALINGS IN THE SOFTWARE.\n    function EventEmitter() {\n      this._events = this._events || {};\n      this._maxListeners = this._maxListeners || undefined;\n    }\n\n    module.exports = EventEmitter; // Backwards-compat with node 0.10.x\n\n    EventEmitter.EventEmitter = EventEmitter;\n    EventEmitter.prototype._events = undefined;\n    EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are\n    // added to it. This is a useful default which helps finding memory leaks.\n\n    EventEmitter.defaultMaxListeners = 10; // Obviously not all Emitters should be limited to 10. This function allows\n    // that to be increased. Set to zero for unlimited.\n\n    EventEmitter.prototype.setMaxListeners = function (n) {\n      if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');\n      this._maxListeners = n;\n      return this;\n    };\n\n    EventEmitter.prototype.emit = function (type) {\n      var er, handler, len, args, i, listeners;\n      if (!this._events) this._events = {}; // If there is no 'error' event listener then throw.\n\n      if (type === 'error') {\n        if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {\n          er = arguments[1];\n\n          if (er instanceof Error) {\n            throw er; // Unhandled 'error' event\n          } else {\n            // At least give some kind of context to the user\n            var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n            err.context = er;\n            throw err;\n          }\n        }\n      }\n\n      handler = this._events[type];\n      if (isUndefined(handler)) return false;\n\n      if (isFunction(handler)) {\n        switch (arguments.length) {\n          // fast cases\n          case 1:\n            handler.call(this);\n            break;\n\n          case 2:\n            handler.call(this, arguments[1]);\n            break;\n\n          case 3:\n            handler.call(this, arguments[1], arguments[2]);\n            break;\n          // slower\n\n          default:\n            args = Array.prototype.slice.call(arguments, 1);\n            handler.apply(this, args);\n        }\n      } else if (isObject(handler)) {\n        args = Array.prototype.slice.call(arguments, 1);\n        listeners = handler.slice();\n        len = listeners.length;\n\n        for (i = 0; i < len; i++) listeners[i].apply(this, args);\n      }\n\n      return true;\n    };\n\n    EventEmitter.prototype.addListener = function (type, listener) {\n      var m;\n      if (!isFunction(listener)) throw TypeError('listener must be a function');\n      if (!this._events) this._events = {}; // To avoid recursion in the case that type === \"newListener\"! Before\n      // adding it to the listeners, first emit \"newListener\".\n\n      if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);\n      if (!this._events[type]) // Optimize the case of one listener. Don't need the extra array object.\n        this._events[type] = listener;else if (isObject(this._events[type])) // If we've already got an array, just append.\n        this._events[type].push(listener);else // Adding the second element, need to change to array.\n        this._events[type] = [this._events[type], listener]; // Check for listener leak\n\n      if (isObject(this._events[type]) && !this._events[type].warned) {\n        if (!isUndefined(this._maxListeners)) {\n          m = this._maxListeners;\n        } else {\n          m = EventEmitter.defaultMaxListeners;\n        }\n\n        if (m && m > 0 && this._events[type].length > m) {\n          this._events[type].warned = true;\n          console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);\n\n          if (typeof console.trace === 'function') {\n            // not supported in IE 10\n            console.trace();\n          }\n        }\n      }\n\n      return this;\n    };\n\n    EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n    EventEmitter.prototype.once = function (type, listener) {\n      if (!isFunction(listener)) throw TypeError('listener must be a function');\n      var fired = false;\n\n      function g() {\n        this.removeListener(type, g);\n\n        if (!fired) {\n          fired = true;\n          listener.apply(this, arguments);\n        }\n      }\n\n      g.listener = listener;\n      this.on(type, g);\n      return this;\n    }; // emits a 'removeListener' event iff the listener was removed\n\n\n    EventEmitter.prototype.removeListener = function (type, listener) {\n      var list, position, length, i;\n      if (!isFunction(listener)) throw TypeError('listener must be a function');\n      if (!this._events || !this._events[type]) return this;\n      list = this._events[type];\n      length = list.length;\n      position = -1;\n\n      if (list === listener || isFunction(list.listener) && list.listener === listener) {\n        delete this._events[type];\n        if (this._events.removeListener) this.emit('removeListener', type, listener);\n      } else if (isObject(list)) {\n        for (i = length; i-- > 0;) {\n          if (list[i] === listener || list[i].listener && list[i].listener === listener) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0) return this;\n\n        if (list.length === 1) {\n          list.length = 0;\n          delete this._events[type];\n        } else {\n          list.splice(position, 1);\n        }\n\n        if (this._events.removeListener) this.emit('removeListener', type, listener);\n      }\n\n      return this;\n    };\n\n    EventEmitter.prototype.removeAllListeners = function (type) {\n      var key, listeners;\n      if (!this._events) return this; // not listening for removeListener, no need to emit\n\n      if (!this._events.removeListener) {\n        if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];\n        return this;\n      } // emit removeListener for all listeners on all events\n\n\n      if (arguments.length === 0) {\n        for (key in this._events) {\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n\n        this.removeAllListeners('removeListener');\n        this._events = {};\n        return this;\n      }\n\n      listeners = this._events[type];\n\n      if (isFunction(listeners)) {\n        this.removeListener(type, listeners);\n      } else if (listeners) {\n        // LIFO order\n        while (listeners.length) this.removeListener(type, listeners[listeners.length - 1]);\n      }\n\n      delete this._events[type];\n      return this;\n    };\n\n    EventEmitter.prototype.listeners = function (type) {\n      var ret;\n      if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();\n      return ret;\n    };\n\n    EventEmitter.prototype.listenerCount = function (type) {\n      if (this._events) {\n        var evlistener = this._events[type];\n        if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;\n      }\n\n      return 0;\n    };\n\n    EventEmitter.listenerCount = function (emitter, type) {\n      return emitter.listenerCount(type);\n    };\n\n    function isFunction(arg) {\n      return typeof arg === 'function';\n    }\n\n    function isNumber(arg) {\n      return typeof arg === 'number';\n    }\n\n    function isObject(arg) {\n      return typeof arg === 'object' && arg !== null;\n    }\n\n    function isUndefined(arg) {\n      return arg === void 0;\n    }\n  }, {}],\n  11: [function (require, module, exports) {\n    var http = require('http');\n\n    var https = module.exports;\n\n    for (var key in http) {\n      if (http.hasOwnProperty(key)) https[key] = http[key];\n    }\n\n    ;\n\n    https.request = function (params, cb) {\n      if (!params) params = {};\n      params.scheme = 'https';\n      params.protocol = 'https:';\n      return http.request.call(this, params, cb);\n    };\n  }, {\n    \"http\": 43\n  }],\n  12: [function (require, module, exports) {\n    exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n      var e, m;\n      var eLen = nBytes * 8 - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var nBits = -7;\n      var i = isLE ? nBytes - 1 : 0;\n      var d = isLE ? -1 : 1;\n      var s = buffer[offset + i];\n      i += d;\n      e = s & (1 << -nBits) - 1;\n      s >>= -nBits;\n      nBits += eLen;\n\n      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n      m = e & (1 << -nBits) - 1;\n      e >>= -nBits;\n      nBits += mLen;\n\n      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n      if (e === 0) {\n        e = 1 - eBias;\n      } else if (e === eMax) {\n        return m ? NaN : (s ? -1 : 1) * Infinity;\n      } else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n      }\n\n      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n    };\n\n    exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n      var e, m, c;\n      var eLen = nBytes * 8 - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n      var i = isLE ? 0 : nBytes - 1;\n      var d = isLE ? 1 : -1;\n      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n      value = Math.abs(value);\n\n      if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n      } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n\n        if (value * (c = Math.pow(2, -e)) < 1) {\n          e--;\n          c *= 2;\n        }\n\n        if (e + eBias >= 1) {\n          value += rt / c;\n        } else {\n          value += rt * Math.pow(2, 1 - eBias);\n        }\n\n        if (value * c >= 2) {\n          e++;\n          c /= 2;\n        }\n\n        if (e + eBias >= eMax) {\n          m = 0;\n          e = eMax;\n        } else if (e + eBias >= 1) {\n          m = (value * c - 1) * Math.pow(2, mLen);\n          e = e + eBias;\n        } else {\n          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n          e = 0;\n        }\n      }\n\n      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n      e = e << mLen | m;\n      eLen += mLen;\n\n      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n      buffer[offset + i - d] |= s * 128;\n    };\n  }, {}],\n  13: [function (require, module, exports) {\n    if (typeof Object.create === 'function') {\n      // implementation from standard node.js 'util' module\n      module.exports = function inherits(ctor, superCtor) {\n        ctor.super_ = superCtor;\n        ctor.prototype = Object.create(superCtor.prototype, {\n          constructor: {\n            value: ctor,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n      };\n    } else {\n      // old school shim for old browsers\n      module.exports = function inherits(ctor, superCtor) {\n        ctor.super_ = superCtor;\n\n        var TempCtor = function () {};\n\n        TempCtor.prototype = superCtor.prototype;\n        ctor.prototype = new TempCtor();\n        ctor.prototype.constructor = ctor;\n      };\n    }\n  }, {}],\n  14: [function (require, module, exports) {\n    /*!\n     * Determine if an object is a Buffer\n     *\n     * @author   Feross Aboukhadijeh <https://feross.org>\n     * @license  MIT\n     */\n    // The _isBuffer check is for Safari 5-7 support, because it's missing\n    // Object.prototype.constructor. Remove this eventually\n    module.exports = function (obj) {\n      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);\n    };\n\n    function isBuffer(obj) {\n      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);\n    } // For Node v0.10 support. Remove this eventually.\n\n\n    function isSlowBuffer(obj) {\n      return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));\n    }\n  }, {}],\n  15: [function (require, module, exports) {\n    var toString = {}.toString;\n\n    module.exports = Array.isArray || function (arr) {\n      return toString.call(arr) == '[object Array]';\n    };\n  }, {}],\n  16: [function (require, module, exports) {\n    (function (Buffer) {\n      'use strict';\n\n      var STREAM = require('stream'),\n          UTIL = require('util'),\n          StringDecoder = require('string_decoder').StringDecoder;\n\n      function MemoryReadableStream(data, options) {\n        if (!(this instanceof MemoryReadableStream)) return new MemoryReadableStream(data, options);\n        MemoryReadableStream.super_.call(this, options);\n        this.init(data, options);\n      }\n\n      UTIL.inherits(MemoryReadableStream, STREAM.Readable);\n\n      function MemoryWritableStream(data, options) {\n        if (!(this instanceof MemoryWritableStream)) return new MemoryWritableStream(data, options);\n        MemoryWritableStream.super_.call(this, options);\n        this.init(data, options);\n      }\n\n      UTIL.inherits(MemoryWritableStream, STREAM.Writable);\n\n      function MemoryDuplexStream(data, options) {\n        if (!(this instanceof MemoryDuplexStream)) return new MemoryDuplexStream(data, options);\n        MemoryDuplexStream.super_.call(this, options);\n        this.init(data, options);\n      }\n\n      UTIL.inherits(MemoryDuplexStream, STREAM.Duplex);\n\n      MemoryReadableStream.prototype.init = MemoryWritableStream.prototype.init = MemoryDuplexStream.prototype.init = function init(data, options) {\n        var self = this;\n        this.queue = [];\n\n        if (data) {\n          if (!Array.isArray(data)) {\n            data = [data];\n          }\n\n          data.forEach(function (chunk) {\n            if (!(chunk instanceof Buffer)) {\n              chunk = new Buffer(chunk);\n            }\n\n            self.queue.push(chunk);\n          });\n        }\n\n        options = options || {};\n        this.maxbufsize = options.hasOwnProperty('maxbufsize') ? options.maxbufsize : null;\n        this.bufoverflow = options.hasOwnProperty('bufoverflow') ? options.bufoverflow : null;\n        this.frequence = options.hasOwnProperty('frequence') ? options.frequence : null;\n      };\n\n      function MemoryStream(data, options) {\n        if (!(this instanceof MemoryStream)) return new MemoryStream(data, options);\n        options = options || {};\n        var readable = options.hasOwnProperty('readable') ? options.readable : true,\n            writable = options.hasOwnProperty('writable') ? options.writable : true;\n\n        if (readable && writable) {\n          return new MemoryDuplexStream(data, options);\n        } else if (readable) {\n          return new MemoryReadableStream(data, options);\n        } else if (writable) {\n          return new MemoryWritableStream(data, options);\n        } else {\n          throw new Error(\"Unknown stream type  Readable, Writable or Duplex \");\n        }\n      }\n\n      MemoryStream.createReadStream = function (data, options) {\n        options = options || {};\n        options.readable = true;\n        options.writable = false;\n        return new MemoryStream(data, options);\n      };\n\n      MemoryStream.createWriteStream = function (data, options) {\n        options = options || {};\n        options.readable = false;\n        options.writable = true;\n        return new MemoryStream(data, options);\n      };\n\n      MemoryReadableStream.prototype._read = MemoryDuplexStream.prototype._read = function _read(n) {\n        var self = this,\n            frequence = self.frequence || 0,\n            wait_data = this instanceof STREAM.Duplex && !this._writableState.finished ? true : false;\n\n        if (!this.queue.length && !wait_data) {\n          this.push(null); // finish stream\n        } else if (this.queue.length) {\n          setTimeout(function () {\n            if (self.queue.length) {\n              var chunk = self.queue.shift();\n\n              if (chunk && !self._readableState.ended) {\n                if (!self.push(chunk)) {\n                  self.queue.unshift(chunk);\n                }\n              }\n            }\n          }, frequence);\n        }\n      };\n\n      MemoryWritableStream.prototype._write = MemoryDuplexStream.prototype._write = function _write(chunk, encoding, cb) {\n        var decoder = null;\n\n        try {\n          decoder = this.decodeStrings && encoding ? new StringDecoder(encoding) : null;\n        } catch (err) {\n          return cb(err);\n        }\n\n        var decoded_chunk = decoder ? decoder.write(chunk) : chunk,\n            queue_size = this._getQueueSize(),\n            chunk_size = decoded_chunk.length;\n\n        if (this.maxbufsize && queue_size + chunk_size > this.maxbufsize) {\n          if (this.bufoverflow) {\n            return cb(\"Buffer overflowed (\" + this.bufoverflow + \"/\" + queue_size + \")\");\n          } else {\n            return cb();\n          }\n        }\n\n        if (this instanceof STREAM.Duplex) {\n          while (this.queue.length) {\n            this.push(this.queue.shift());\n          }\n\n          this.push(decoded_chunk);\n        } else {\n          this.queue.push(decoded_chunk);\n        }\n\n        cb();\n      };\n\n      MemoryDuplexStream.prototype.end = function (chunk, encoding, cb) {\n        var self = this;\n        return MemoryDuplexStream.super_.prototype.end.call(this, chunk, encoding, function () {\n          self.push(null); //finish readble stream too\n\n          if (cb) cb();\n        });\n      };\n\n      MemoryReadableStream.prototype._getQueueSize = MemoryWritableStream.prototype._getQueueSize = MemoryDuplexStream.prototype._getQueueSize = function () {\n        var queuesize = 0,\n            i;\n\n        for (i = 0; i < this.queue.length; i++) {\n          queuesize += Array.isArray(this.queue[i]) ? this.queue[i][0].length : this.queue[i].length;\n        }\n\n        return queuesize;\n      };\n\n      MemoryWritableStream.prototype.toString = MemoryDuplexStream.prototype.toString = MemoryReadableStream.prototype.toString = MemoryWritableStream.prototype.getAll = MemoryDuplexStream.prototype.getAll = MemoryReadableStream.prototype.getAll = function () {\n        var self = this,\n            ret = '';\n        this.queue.forEach(function (data) {\n          ret += data;\n        });\n        return ret;\n      };\n\n      MemoryWritableStream.prototype.toBuffer = MemoryDuplexStream.prototype.toBuffer = MemoryReadableStream.prototype.toBuffer = function () {\n        var buffer = new Buffer(this._getQueueSize()),\n            currentOffset = 0;\n        this.queue.forEach(function (data) {\n          var data_buffer = data instanceof Buffer ? data : new Buffer(data);\n          data_buffer.copy(buffer, currentOffset);\n          currentOffset += data.length;\n        });\n        return buffer;\n      };\n\n      module.exports = MemoryStream;\n    }).call(this, require(\"buffer\").Buffer);\n  }, {\n    \"buffer\": 6,\n    \"stream\": 42,\n    \"string_decoder\": 5,\n    \"util\": 54\n  }],\n  17: [function (require, module, exports) {\n    (function (process) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      // resolves . and .. elements in a path array with directory names there\n      // must be no slashes, empty elements, or device names (c:\\) in the array\n      // (so also no leading and trailing slashes - it does not distinguish\n      // relative and absolute paths)\n      function normalizeArray(parts, allowAboveRoot) {\n        // if the path tries to go above the root, `up` ends up > 0\n        var up = 0;\n\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n\n          if (last === '.') {\n            parts.splice(i, 1);\n          } else if (last === '..') {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        } // if the path is allowed to go above the root, restore leading ..s\n\n\n        if (allowAboveRoot) {\n          for (; up--; up) {\n            parts.unshift('..');\n          }\n        }\n\n        return parts;\n      } // Split a filename into [root, dir, basename, ext], unix version\n      // 'root' is just a slash, or nothing.\n\n\n      var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n\n      var splitPath = function (filename) {\n        return splitPathRe.exec(filename).slice(1);\n      }; // path.resolve([from ...], to)\n      // posix version\n\n\n      exports.resolve = function () {\n        var resolvedPath = '',\n            resolvedAbsolute = false;\n\n        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n          var path = i >= 0 ? arguments[i] : process.cwd(); // Skip empty and invalid entries\n\n          if (typeof path !== 'string') {\n            throw new TypeError('Arguments to path.resolve must be strings');\n          } else if (!path) {\n            continue;\n          }\n\n          resolvedPath = path + '/' + resolvedPath;\n          resolvedAbsolute = path.charAt(0) === '/';\n        } // At this point the path should be resolved to a full absolute path, but\n        // handle relative paths to be safe (might happen when process.cwd() fails)\n        // Normalize the path\n\n\n        resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {\n          return !!p;\n        }), !resolvedAbsolute).join('/');\n        return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';\n      }; // path.normalize(path)\n      // posix version\n\n\n      exports.normalize = function (path) {\n        var isAbsolute = exports.isAbsolute(path),\n            trailingSlash = substr(path, -1) === '/'; // Normalize the path\n\n        path = normalizeArray(filter(path.split('/'), function (p) {\n          return !!p;\n        }), !isAbsolute).join('/');\n\n        if (!path && !isAbsolute) {\n          path = '.';\n        }\n\n        if (path && trailingSlash) {\n          path += '/';\n        }\n\n        return (isAbsolute ? '/' : '') + path;\n      }; // posix version\n\n\n      exports.isAbsolute = function (path) {\n        return path.charAt(0) === '/';\n      }; // posix version\n\n\n      exports.join = function () {\n        var paths = Array.prototype.slice.call(arguments, 0);\n        return exports.normalize(filter(paths, function (p, index) {\n          if (typeof p !== 'string') {\n            throw new TypeError('Arguments to path.join must be strings');\n          }\n\n          return p;\n        }).join('/'));\n      }; // path.relative(from, to)\n      // posix version\n\n\n      exports.relative = function (from, to) {\n        from = exports.resolve(from).substr(1);\n        to = exports.resolve(to).substr(1);\n\n        function trim(arr) {\n          var start = 0;\n\n          for (; start < arr.length; start++) {\n            if (arr[start] !== '') break;\n          }\n\n          var end = arr.length - 1;\n\n          for (; end >= 0; end--) {\n            if (arr[end] !== '') break;\n          }\n\n          if (start > end) return [];\n          return arr.slice(start, end - start + 1);\n        }\n\n        var fromParts = trim(from.split('/'));\n        var toParts = trim(to.split('/'));\n        var length = Math.min(fromParts.length, toParts.length);\n        var samePartsLength = length;\n\n        for (var i = 0; i < length; i++) {\n          if (fromParts[i] !== toParts[i]) {\n            samePartsLength = i;\n            break;\n          }\n        }\n\n        var outputParts = [];\n\n        for (var i = samePartsLength; i < fromParts.length; i++) {\n          outputParts.push('..');\n        }\n\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\n        return outputParts.join('/');\n      };\n\n      exports.sep = '/';\n      exports.delimiter = ':';\n\n      exports.dirname = function (path) {\n        var result = splitPath(path),\n            root = result[0],\n            dir = result[1];\n\n        if (!root && !dir) {\n          // No dirname whatsoever\n          return '.';\n        }\n\n        if (dir) {\n          // It has a dirname, strip trailing slash\n          dir = dir.substr(0, dir.length - 1);\n        }\n\n        return root + dir;\n      };\n\n      exports.basename = function (path, ext) {\n        var f = splitPath(path)[2]; // TODO: make this comparison case-insensitive on windows?\n\n        if (ext && f.substr(-1 * ext.length) === ext) {\n          f = f.substr(0, f.length - ext.length);\n        }\n\n        return f;\n      };\n\n      exports.extname = function (path) {\n        return splitPath(path)[3];\n      };\n\n      function filter(xs, f) {\n        if (xs.filter) return xs.filter(f);\n        var res = [];\n\n        for (var i = 0; i < xs.length; i++) {\n          if (f(xs[i], i, xs)) res.push(xs[i]);\n        }\n\n        return res;\n      } // String.prototype.substr - negative index don't work in IE8\n\n\n      var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {\n        return str.substr(start, len);\n      } : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n      };\n    }).call(this, require('_process'));\n  }, {\n    \"_process\": 19\n  }],\n  18: [function (require, module, exports) {\n    (function (process) {\n      'use strict';\n\n      if (!process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n        module.exports = {\n          nextTick: nextTick\n        };\n      } else {\n        module.exports = process;\n      }\n\n      function nextTick(fn, arg1, arg2, arg3) {\n        if (typeof fn !== 'function') {\n          throw new TypeError('\"callback\" argument must be a function');\n        }\n\n        var len = arguments.length;\n        var args, i;\n\n        switch (len) {\n          case 0:\n          case 1:\n            return process.nextTick(fn);\n\n          case 2:\n            return process.nextTick(function afterTickOne() {\n              fn.call(null, arg1);\n            });\n\n          case 3:\n            return process.nextTick(function afterTickTwo() {\n              fn.call(null, arg1, arg2);\n            });\n\n          case 4:\n            return process.nextTick(function afterTickThree() {\n              fn.call(null, arg1, arg2, arg3);\n            });\n\n          default:\n            args = new Array(len - 1);\n            i = 0;\n\n            while (i < args.length) {\n              args[i++] = arguments[i];\n            }\n\n            return process.nextTick(function afterTick() {\n              fn.apply(null, args);\n            });\n        }\n      }\n    }).call(this, require('_process'));\n  }, {\n    \"_process\": 19\n  }],\n  19: [function (require, module, exports) {\n    // shim for using process in browser\n    var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n    // don't break things.  But we need to wrap it in a try catch in case it is\n    // wrapped in strict mode code which doesn't define any globals.  It's inside a\n    // function because try/catches deoptimize in certain engines.\n\n    var cachedSetTimeout;\n    var cachedClearTimeout;\n\n    function defaultSetTimout() {\n      throw new Error('setTimeout has not been defined');\n    }\n\n    function defaultClearTimeout() {\n      throw new Error('clearTimeout has not been defined');\n    }\n\n    (function () {\n      try {\n        if (typeof setTimeout === 'function') {\n          cachedSetTimeout = setTimeout;\n        } else {\n          cachedSetTimeout = defaultSetTimout;\n        }\n      } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n      }\n\n      try {\n        if (typeof clearTimeout === 'function') {\n          cachedClearTimeout = clearTimeout;\n        } else {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n      }\n    })();\n\n    function runTimeout(fun) {\n      if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n      } // if setTimeout wasn't available but was latter defined\n\n\n      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n      }\n\n      try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n      } catch (e) {\n        try {\n          // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n          return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n          // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n          return cachedSetTimeout.call(this, fun, 0);\n        }\n      }\n    }\n\n    function runClearTimeout(marker) {\n      if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n      } // if clearTimeout wasn't available but was latter defined\n\n\n      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n      }\n\n      try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n      } catch (e) {\n        try {\n          // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n          return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n          // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n          // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n          return cachedClearTimeout.call(this, marker);\n        }\n      }\n    }\n\n    var queue = [];\n    var draining = false;\n    var currentQueue;\n    var queueIndex = -1;\n\n    function cleanUpNextTick() {\n      if (!draining || !currentQueue) {\n        return;\n      }\n\n      draining = false;\n\n      if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n      } else {\n        queueIndex = -1;\n      }\n\n      if (queue.length) {\n        drainQueue();\n      }\n    }\n\n    function drainQueue() {\n      if (draining) {\n        return;\n      }\n\n      var timeout = runTimeout(cleanUpNextTick);\n      draining = true;\n      var len = queue.length;\n\n      while (len) {\n        currentQueue = queue;\n        queue = [];\n\n        while (++queueIndex < len) {\n          if (currentQueue) {\n            currentQueue[queueIndex].run();\n          }\n        }\n\n        queueIndex = -1;\n        len = queue.length;\n      }\n\n      currentQueue = null;\n      draining = false;\n      runClearTimeout(timeout);\n    }\n\n    process.nextTick = function (fun) {\n      var args = new Array(arguments.length - 1);\n\n      if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n          args[i - 1] = arguments[i];\n        }\n      }\n\n      queue.push(new Item(fun, args));\n\n      if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n      }\n    }; // v8 likes predictible objects\n\n\n    function Item(fun, array) {\n      this.fun = fun;\n      this.array = array;\n    }\n\n    Item.prototype.run = function () {\n      this.fun.apply(null, this.array);\n    };\n\n    process.title = 'browser';\n    process.browser = true;\n    process.env = {};\n    process.argv = [];\n    process.version = ''; // empty string to avoid regexp issues\n\n    process.versions = {};\n\n    function noop() {}\n\n    process.on = noop;\n    process.addListener = noop;\n    process.once = noop;\n    process.off = noop;\n    process.removeListener = noop;\n    process.removeAllListeners = noop;\n    process.emit = noop;\n    process.prependListener = noop;\n    process.prependOnceListener = noop;\n\n    process.listeners = function (name) {\n      return [];\n    };\n\n    process.binding = function (name) {\n      throw new Error('process.binding is not supported');\n    };\n\n    process.cwd = function () {\n      return '/';\n    };\n\n    process.chdir = function (dir) {\n      throw new Error('process.chdir is not supported');\n    };\n\n    process.umask = function () {\n      return 0;\n    };\n  }, {}],\n  20: [function (require, module, exports) {\n    (function (global) {\n      /*! https://mths.be/punycode v1.4.1 by @mathias */\n      ;\n\n      (function (root) {\n        /** Detect free variables */\n        var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n        var freeModule = typeof module == 'object' && module && !module.nodeType && module;\n        var freeGlobal = typeof global == 'object' && global;\n\n        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {\n          root = freeGlobal;\n        }\n        /**\n         * The `punycode` object.\n         * @name punycode\n         * @type Object\n         */\n\n\n        var punycode,\n\n        /** Highest positive signed 32-bit float value */\n        maxInt = 2147483647,\n            // aka. 0x7FFFFFFF or 2^31-1\n\n        /** Bootstring parameters */\n        base = 36,\n            tMin = 1,\n            tMax = 26,\n            skew = 38,\n            damp = 700,\n            initialBias = 72,\n            initialN = 128,\n            // 0x80\n        delimiter = '-',\n            // '\\x2D'\n\n        /** Regular expressions */\n        regexPunycode = /^xn--/,\n            regexNonASCII = /[^\\x20-\\x7E]/,\n            // unprintable ASCII chars + non-ASCII chars\n        regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g,\n            // RFC 3490 separators\n\n        /** Error messages */\n        errors = {\n          'overflow': 'Overflow: input needs wider integers to process',\n          'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n          'invalid-input': 'Invalid input'\n        },\n\n        /** Convenience shortcuts */\n        baseMinusTMin = base - tMin,\n            floor = Math.floor,\n            stringFromCharCode = String.fromCharCode,\n\n        /** Temporary variable */\n        key;\n        /*--------------------------------------------------------------------------*/\n\n        /**\n         * A generic error utility function.\n         * @private\n         * @param {String} type The error type.\n         * @returns {Error} Throws a `RangeError` with the applicable error message.\n         */\n\n        function error(type) {\n          throw new RangeError(errors[type]);\n        }\n        /**\n         * A generic `Array#map` utility function.\n         * @private\n         * @param {Array} array The array to iterate over.\n         * @param {Function} callback The function that gets called for every array\n         * item.\n         * @returns {Array} A new array of values returned by the callback function.\n         */\n\n\n        function map(array, fn) {\n          var length = array.length;\n          var result = [];\n\n          while (length--) {\n            result[length] = fn(array[length]);\n          }\n\n          return result;\n        }\n        /**\n         * A simple `Array#map`-like wrapper to work with domain name strings or email\n         * addresses.\n         * @private\n         * @param {String} domain The domain name or email address.\n         * @param {Function} callback The function that gets called for every\n         * character.\n         * @returns {Array} A new string of characters returned by the callback\n         * function.\n         */\n\n\n        function mapDomain(string, fn) {\n          var parts = string.split('@');\n          var result = '';\n\n          if (parts.length > 1) {\n            // In email addresses, only the domain name should be punycoded. Leave\n            // the local part (i.e. everything up to `@`) intact.\n            result = parts[0] + '@';\n            string = parts[1];\n          } // Avoid `split(regex)` for IE8 compatibility. See #17.\n\n\n          string = string.replace(regexSeparators, '\\x2E');\n          var labels = string.split('.');\n          var encoded = map(labels, fn).join('.');\n          return result + encoded;\n        }\n        /**\n         * Creates an array containing the numeric code points of each Unicode\n         * character in the string. While JavaScript uses UCS-2 internally,\n         * this function will convert a pair of surrogate halves (each of which\n         * UCS-2 exposes as separate characters) into a single code point,\n         * matching UTF-16.\n         * @see `punycode.ucs2.encode`\n         * @see <https://mathiasbynens.be/notes/javascript-encoding>\n         * @memberOf punycode.ucs2\n         * @name decode\n         * @param {String} string The Unicode input string (UCS-2).\n         * @returns {Array} The new array of code points.\n         */\n\n\n        function ucs2decode(string) {\n          var output = [],\n              counter = 0,\n              length = string.length,\n              value,\n              extra;\n\n          while (counter < length) {\n            value = string.charCodeAt(counter++);\n\n            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n              // high surrogate, and there is a next character\n              extra = string.charCodeAt(counter++);\n\n              if ((extra & 0xFC00) == 0xDC00) {\n                // low surrogate\n                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n              } else {\n                // unmatched surrogate; only append this code unit, in case the next\n                // code unit is the high surrogate of a surrogate pair\n                output.push(value);\n                counter--;\n              }\n            } else {\n              output.push(value);\n            }\n          }\n\n          return output;\n        }\n        /**\n         * Creates a string based on an array of numeric code points.\n         * @see `punycode.ucs2.decode`\n         * @memberOf punycode.ucs2\n         * @name encode\n         * @param {Array} codePoints The array of numeric code points.\n         * @returns {String} The new Unicode string (UCS-2).\n         */\n\n\n        function ucs2encode(array) {\n          return map(array, function (value) {\n            var output = '';\n\n            if (value > 0xFFFF) {\n              value -= 0x10000;\n              output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n              value = 0xDC00 | value & 0x3FF;\n            }\n\n            output += stringFromCharCode(value);\n            return output;\n          }).join('');\n        }\n        /**\n         * Converts a basic code point into a digit/integer.\n         * @see `digitToBasic()`\n         * @private\n         * @param {Number} codePoint The basic numeric code point value.\n         * @returns {Number} The numeric value of a basic code point (for use in\n         * representing integers) in the range `0` to `base - 1`, or `base` if\n         * the code point does not represent a value.\n         */\n\n\n        function basicToDigit(codePoint) {\n          if (codePoint - 48 < 10) {\n            return codePoint - 22;\n          }\n\n          if (codePoint - 65 < 26) {\n            return codePoint - 65;\n          }\n\n          if (codePoint - 97 < 26) {\n            return codePoint - 97;\n          }\n\n          return base;\n        }\n        /**\n         * Converts a digit/integer into a basic code point.\n         * @see `basicToDigit()`\n         * @private\n         * @param {Number} digit The numeric value of a basic code point.\n         * @returns {Number} The basic code point whose value (when used for\n         * representing integers) is `digit`, which needs to be in the range\n         * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n         * used; else, the lowercase form is used. The behavior is undefined\n         * if `flag` is non-zero and `digit` has no uppercase form.\n         */\n\n\n        function digitToBasic(digit, flag) {\n          //  0..25 map to ASCII a..z or A..Z\n          // 26..35 map to ASCII 0..9\n          return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n        }\n        /**\n         * Bias adaptation function as per section 3.4 of RFC 3492.\n         * https://tools.ietf.org/html/rfc3492#section-3.4\n         * @private\n         */\n\n\n        function adapt(delta, numPoints, firstTime) {\n          var k = 0;\n          delta = firstTime ? floor(delta / damp) : delta >> 1;\n          delta += floor(delta / numPoints);\n\n          for (;\n          /* no initialization */\n          delta > baseMinusTMin * tMax >> 1; k += base) {\n            delta = floor(delta / baseMinusTMin);\n          }\n\n          return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n        }\n        /**\n         * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n         * symbols.\n         * @memberOf punycode\n         * @param {String} input The Punycode string of ASCII-only symbols.\n         * @returns {String} The resulting string of Unicode symbols.\n         */\n\n\n        function decode(input) {\n          // Don't use UCS-2\n          var output = [],\n              inputLength = input.length,\n              out,\n              i = 0,\n              n = initialN,\n              bias = initialBias,\n              basic,\n              j,\n              index,\n              oldi,\n              w,\n              k,\n              digit,\n              t,\n\n          /** Cached calculation results */\n          baseMinusT; // Handle the basic code points: let `basic` be the number of input code\n          // points before the last delimiter, or `0` if there is none, then copy\n          // the first basic code points to the output.\n\n          basic = input.lastIndexOf(delimiter);\n\n          if (basic < 0) {\n            basic = 0;\n          }\n\n          for (j = 0; j < basic; ++j) {\n            // if it's not a basic code point\n            if (input.charCodeAt(j) >= 0x80) {\n              error('not-basic');\n            }\n\n            output.push(input.charCodeAt(j));\n          } // Main decoding loop: start just after the last delimiter if any basic code\n          // points were copied; start at the beginning otherwise.\n\n\n          for (index = basic > 0 ? basic + 1 : 0; index < inputLength;)\n          /* no final expression */\n          {\n            // `index` is the index of the next character to be consumed.\n            // Decode a generalized variable-length integer into `delta`,\n            // which gets added to `i`. The overflow checking is easier\n            // if we increase `i` as we go, then subtract off its starting\n            // value at the end to obtain `delta`.\n            for (oldi = i, w = 1, k = base;;\n            /* no condition */\n            k += base) {\n              if (index >= inputLength) {\n                error('invalid-input');\n              }\n\n              digit = basicToDigit(input.charCodeAt(index++));\n\n              if (digit >= base || digit > floor((maxInt - i) / w)) {\n                error('overflow');\n              }\n\n              i += digit * w;\n              t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n              if (digit < t) {\n                break;\n              }\n\n              baseMinusT = base - t;\n\n              if (w > floor(maxInt / baseMinusT)) {\n                error('overflow');\n              }\n\n              w *= baseMinusT;\n            }\n\n            out = output.length + 1;\n            bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,\n            // incrementing `n` each time, so we'll fix that now:\n\n            if (floor(i / out) > maxInt - n) {\n              error('overflow');\n            }\n\n            n += floor(i / out);\n            i %= out; // Insert `n` at position `i` of the output\n\n            output.splice(i++, 0, n);\n          }\n\n          return ucs2encode(output);\n        }\n        /**\n         * Converts a string of Unicode symbols (e.g. a domain name label) to a\n         * Punycode string of ASCII-only symbols.\n         * @memberOf punycode\n         * @param {String} input The string of Unicode symbols.\n         * @returns {String} The resulting Punycode string of ASCII-only symbols.\n         */\n\n\n        function encode(input) {\n          var n,\n              delta,\n              handledCPCount,\n              basicLength,\n              bias,\n              j,\n              m,\n              q,\n              k,\n              t,\n              currentValue,\n              output = [],\n\n          /** `inputLength` will hold the number of code points in `input`. */\n          inputLength,\n\n          /** Cached calculation results */\n          handledCPCountPlusOne,\n              baseMinusT,\n              qMinusT; // Convert the input in UCS-2 to Unicode\n\n          input = ucs2decode(input); // Cache the length\n\n          inputLength = input.length; // Initialize the state\n\n          n = initialN;\n          delta = 0;\n          bias = initialBias; // Handle the basic code points\n\n          for (j = 0; j < inputLength; ++j) {\n            currentValue = input[j];\n\n            if (currentValue < 0x80) {\n              output.push(stringFromCharCode(currentValue));\n            }\n          }\n\n          handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;\n          // `basicLength` is the number of basic code points.\n          // Finish the basic string - if it is not empty - with a delimiter\n\n          if (basicLength) {\n            output.push(delimiter);\n          } // Main encoding loop:\n\n\n          while (handledCPCount < inputLength) {\n            // All non-basic code points < n have been handled already. Find the next\n            // larger one:\n            for (m = maxInt, j = 0; j < inputLength; ++j) {\n              currentValue = input[j];\n\n              if (currentValue >= n && currentValue < m) {\n                m = currentValue;\n              }\n            } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n            // but guard against overflow\n\n\n            handledCPCountPlusOne = handledCPCount + 1;\n\n            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n              error('overflow');\n            }\n\n            delta += (m - n) * handledCPCountPlusOne;\n            n = m;\n\n            for (j = 0; j < inputLength; ++j) {\n              currentValue = input[j];\n\n              if (currentValue < n && ++delta > maxInt) {\n                error('overflow');\n              }\n\n              if (currentValue == n) {\n                // Represent delta as a generalized variable-length integer\n                for (q = delta, k = base;;\n                /* no condition */\n                k += base) {\n                  t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n                  if (q < t) {\n                    break;\n                  }\n\n                  qMinusT = q - t;\n                  baseMinusT = base - t;\n                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n                  q = floor(qMinusT / baseMinusT);\n                }\n\n                output.push(stringFromCharCode(digitToBasic(q, 0)));\n                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                delta = 0;\n                ++handledCPCount;\n              }\n            }\n\n            ++delta;\n            ++n;\n          }\n\n          return output.join('');\n        }\n        /**\n         * Converts a Punycode string representing a domain name or an email address\n         * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n         * it doesn't matter if you call it on a string that has already been\n         * converted to Unicode.\n         * @memberOf punycode\n         * @param {String} input The Punycoded domain name or email address to\n         * convert to Unicode.\n         * @returns {String} The Unicode representation of the given Punycode\n         * string.\n         */\n\n\n        function toUnicode(input) {\n          return mapDomain(input, function (string) {\n            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n          });\n        }\n        /**\n         * Converts a Unicode string representing a domain name or an email address to\n         * Punycode. Only the non-ASCII parts of the domain name will be converted,\n         * i.e. it doesn't matter if you call it with a domain that's already in\n         * ASCII.\n         * @memberOf punycode\n         * @param {String} input The domain name or email address to convert, as a\n         * Unicode string.\n         * @returns {String} The Punycode representation of the given domain name or\n         * email address.\n         */\n\n\n        function toASCII(input) {\n          return mapDomain(input, function (string) {\n            return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n          });\n        }\n        /*--------------------------------------------------------------------------*/\n\n        /** Define the public API */\n\n\n        punycode = {\n          /**\n           * A string representing the current Punycode.js version number.\n           * @memberOf punycode\n           * @type String\n           */\n          'version': '1.4.1',\n\n          /**\n           * An object of methods to convert from JavaScript's internal character\n           * representation (UCS-2) to Unicode code points, and back.\n           * @see <https://mathiasbynens.be/notes/javascript-encoding>\n           * @memberOf punycode\n           * @type Object\n           */\n          'ucs2': {\n            'decode': ucs2decode,\n            'encode': ucs2encode\n          },\n          'decode': decode,\n          'encode': encode,\n          'toASCII': toASCII,\n          'toUnicode': toUnicode\n        };\n        /** Expose `punycode` */\n        // Some AMD build optimizers, like r.js, check for specific condition patterns\n        // like the following:\n\n        if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n          define('punycode', function () {\n            return punycode;\n          });\n        } else if (freeExports && freeModule) {\n          if (module.exports == freeExports) {\n            // in Node.js, io.js, or RingoJS v0.8.0+\n            freeModule.exports = punycode;\n          } else {\n            // in Narwhal or RingoJS v0.7.0-\n            for (key in punycode) {\n              punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n            }\n          }\n        } else {\n          // in Rhino or a web browser\n          root.punycode = punycode;\n        }\n      })(this);\n    }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n  }, {}],\n  21: [function (require, module, exports) {\n    // Copyright Joyent, Inc. and other Node contributors.\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a\n    // copy of this software and associated documentation files (the\n    // \"Software\"), to deal in the Software without restriction, including\n    // without limitation the rights to use, copy, modify, merge, publish,\n    // distribute, sublicense, and/or sell copies of the Software, and to permit\n    // persons to whom the Software is furnished to do so, subject to the\n    // following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included\n    // in all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n    // USE OR OTHER DEALINGS IN THE SOFTWARE.\n    'use strict'; // If obj.hasOwnProperty has been overridden, then calling\n    // obj.hasOwnProperty(prop) will break.\n    // See: https://github.com/joyent/node/issues/1707\n\n    function hasOwnProperty(obj, prop) {\n      return Object.prototype.hasOwnProperty.call(obj, prop);\n    }\n\n    module.exports = function (qs, sep, eq, options) {\n      sep = sep || '&';\n      eq = eq || '=';\n      var obj = {};\n\n      if (typeof qs !== 'string' || qs.length === 0) {\n        return obj;\n      }\n\n      var regexp = /\\+/g;\n      qs = qs.split(sep);\n      var maxKeys = 1000;\n\n      if (options && typeof options.maxKeys === 'number') {\n        maxKeys = options.maxKeys;\n      }\n\n      var len = qs.length; // maxKeys <= 0 means that we should not limit keys count\n\n      if (maxKeys > 0 && len > maxKeys) {\n        len = maxKeys;\n      }\n\n      for (var i = 0; i < len; ++i) {\n        var x = qs[i].replace(regexp, '%20'),\n            idx = x.indexOf(eq),\n            kstr,\n            vstr,\n            k,\n            v;\n\n        if (idx >= 0) {\n          kstr = x.substr(0, idx);\n          vstr = x.substr(idx + 1);\n        } else {\n          kstr = x;\n          vstr = '';\n        }\n\n        k = decodeURIComponent(kstr);\n        v = decodeURIComponent(vstr);\n\n        if (!hasOwnProperty(obj, k)) {\n          obj[k] = v;\n        } else if (isArray(obj[k])) {\n          obj[k].push(v);\n        } else {\n          obj[k] = [obj[k], v];\n        }\n      }\n\n      return obj;\n    };\n\n    var isArray = Array.isArray || function (xs) {\n      return Object.prototype.toString.call(xs) === '[object Array]';\n    };\n  }, {}],\n  22: [function (require, module, exports) {\n    // Copyright Joyent, Inc. and other Node contributors.\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a\n    // copy of this software and associated documentation files (the\n    // \"Software\"), to deal in the Software without restriction, including\n    // without limitation the rights to use, copy, modify, merge, publish,\n    // distribute, sublicense, and/or sell copies of the Software, and to permit\n    // persons to whom the Software is furnished to do so, subject to the\n    // following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included\n    // in all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n    // USE OR OTHER DEALINGS IN THE SOFTWARE.\n    'use strict';\n\n    var stringifyPrimitive = function (v) {\n      switch (typeof v) {\n        case 'string':\n          return v;\n\n        case 'boolean':\n          return v ? 'true' : 'false';\n\n        case 'number':\n          return isFinite(v) ? v : '';\n\n        default:\n          return '';\n      }\n    };\n\n    module.exports = function (obj, sep, eq, name) {\n      sep = sep || '&';\n      eq = eq || '=';\n\n      if (obj === null) {\n        obj = undefined;\n      }\n\n      if (typeof obj === 'object') {\n        return map(objectKeys(obj), function (k) {\n          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n\n          if (isArray(obj[k])) {\n            return map(obj[k], function (v) {\n              return ks + encodeURIComponent(stringifyPrimitive(v));\n            }).join(sep);\n          } else {\n            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n          }\n        }).join(sep);\n      }\n\n      if (!name) return '';\n      return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));\n    };\n\n    var isArray = Array.isArray || function (xs) {\n      return Object.prototype.toString.call(xs) === '[object Array]';\n    };\n\n    function map(xs, f) {\n      if (xs.map) return xs.map(f);\n      var res = [];\n\n      for (var i = 0; i < xs.length; i++) {\n        res.push(f(xs[i], i));\n      }\n\n      return res;\n    }\n\n    var objectKeys = Object.keys || function (obj) {\n      var res = [];\n\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n      }\n\n      return res;\n    };\n  }, {}],\n  23: [function (require, module, exports) {\n    'use strict';\n\n    exports.decode = exports.parse = require('./decode');\n    exports.encode = exports.stringify = require('./encode');\n  }, {\n    \"./decode\": 21,\n    \"./encode\": 22\n  }],\n  24: [function (require, module, exports) {\n    module.exports = require('./lib/_stream_duplex.js');\n  }, {\n    \"./lib/_stream_duplex.js\": 25\n  }],\n  25: [function (require, module, exports) {\n    // Copyright Joyent, Inc. and other Node contributors.\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a\n    // copy of this software and associated documentation files (the\n    // \"Software\"), to deal in the Software without restriction, including\n    // without limitation the rights to use, copy, modify, merge, publish,\n    // distribute, sublicense, and/or sell copies of the Software, and to permit\n    // persons to whom the Software is furnished to do so, subject to the\n    // following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included\n    // in all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n    // USE OR OTHER DEALINGS IN THE SOFTWARE.\n    // a duplex stream is just a stream that is both readable and writable.\n    // Since JS doesn't have multiple prototypal inheritance, this class\n    // prototypally inherits from Readable, and then parasitically from\n    // Writable.\n    'use strict';\n    /*<replacement>*/\n\n    var pna = require('process-nextick-args');\n    /*</replacement>*/\n\n    /*<replacement>*/\n\n\n    var objectKeys = Object.keys || function (obj) {\n      var keys = [];\n\n      for (var key in obj) {\n        keys.push(key);\n      }\n\n      return keys;\n    };\n    /*</replacement>*/\n\n\n    module.exports = Duplex;\n    /*<replacement>*/\n\n    var util = require('core-util-is');\n\n    util.inherits = require('inherits');\n    /*</replacement>*/\n\n    var Readable = require('./_stream_readable');\n\n    var Writable = require('./_stream_writable');\n\n    util.inherits(Duplex, Readable);\n    {\n      // avoid scope creep, the keys array can then be collected\n      var keys = objectKeys(Writable.prototype);\n\n      for (var v = 0; v < keys.length; v++) {\n        var method = keys[v];\n        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n      }\n    }\n\n    function Duplex(options) {\n      if (!(this instanceof Duplex)) return new Duplex(options);\n      Readable.call(this, options);\n      Writable.call(this, options);\n      if (options && options.readable === false) this.readable = false;\n      if (options && options.writable === false) this.writable = false;\n      this.allowHalfOpen = true;\n      if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n\n    Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n      // making it explicit this property is not enumerable\n      // because otherwise some prototype manipulation in\n      // userland will fail\n      enumerable: false,\n      get: function () {\n        return this._writableState.highWaterMark;\n      }\n    }); // the no-half-open enforcer\n\n    function onend() {\n      // if we allow half-open state, or if the writable side ended,\n      // then we're ok.\n      if (this.allowHalfOpen || this._writableState.ended) return; // no more data can be written.\n      // But allow more writes to happen in this tick.\n\n      pna.nextTick(onEndNT, this);\n    }\n\n    function onEndNT(self) {\n      self.end();\n    }\n\n    Object.defineProperty(Duplex.prototype, 'destroyed', {\n      get: function () {\n        if (this._readableState === undefined || this._writableState === undefined) {\n          return false;\n        }\n\n        return this._readableState.destroyed && this._writableState.destroyed;\n      },\n      set: function (value) {\n        // we ignore the value if the stream\n        // has not been initialized yet\n        if (this._readableState === undefined || this._writableState === undefined) {\n          return;\n        } // backward compatibility, the user is explicitly\n        // managing destroyed\n\n\n        this._readableState.destroyed = value;\n        this._writableState.destroyed = value;\n      }\n    });\n\n    Duplex.prototype._destroy = function (err, cb) {\n      this.push(null);\n      this.end();\n      pna.nextTick(cb, err);\n    };\n  }, {\n    \"./_stream_readable\": 27,\n    \"./_stream_writable\": 29,\n    \"core-util-is\": 8,\n    \"inherits\": 13,\n    \"process-nextick-args\": 18\n  }],\n  26: [function (require, module, exports) {\n    // Copyright Joyent, Inc. and other Node contributors.\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a\n    // copy of this software and associated documentation files (the\n    // \"Software\"), to deal in the Software without restriction, including\n    // without limitation the rights to use, copy, modify, merge, publish,\n    // distribute, sublicense, and/or sell copies of the Software, and to permit\n    // persons to whom the Software is furnished to do so, subject to the\n    // following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included\n    // in all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n    // USE OR OTHER DEALINGS IN THE SOFTWARE.\n    // a passthrough stream.\n    // basically just the most minimal sort of Transform stream.\n    // Every written chunk gets output as-is.\n    'use strict';\n\n    module.exports = PassThrough;\n\n    var Transform = require('./_stream_transform');\n    /*<replacement>*/\n\n\n    var util = require('core-util-is');\n\n    util.inherits = require('inherits');\n    /*</replacement>*/\n\n    util.inherits(PassThrough, Transform);\n\n    function PassThrough(options) {\n      if (!(this instanceof PassThrough)) return new PassThrough(options);\n      Transform.call(this, options);\n    }\n\n    PassThrough.prototype._transform = function (chunk, encoding, cb) {\n      cb(null, chunk);\n    };\n  }, {\n    \"./_stream_transform\": 28,\n    \"core-util-is\": 8,\n    \"inherits\": 13\n  }],\n  27: [function (require, module, exports) {\n    (function (process, global) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      'use strict';\n      /*<replacement>*/\n\n      var pna = require('process-nextick-args');\n      /*</replacement>*/\n\n\n      module.exports = Readable;\n      /*<replacement>*/\n\n      var isArray = require('isarray');\n      /*</replacement>*/\n\n      /*<replacement>*/\n\n\n      var Duplex;\n      /*</replacement>*/\n\n      Readable.ReadableState = ReadableState;\n      /*<replacement>*/\n\n      var EE = require('events').EventEmitter;\n\n      var EElistenerCount = function (emitter, type) {\n        return emitter.listeners(type).length;\n      };\n      /*</replacement>*/\n\n      /*<replacement>*/\n\n\n      var Stream = require('./internal/streams/stream');\n      /*</replacement>*/\n\n      /*<replacement>*/\n\n\n      var Buffer = require('safe-buffer').Buffer;\n\n      var OurUint8Array = global.Uint8Array || function () {};\n\n      function _uint8ArrayToBuffer(chunk) {\n        return Buffer.from(chunk);\n      }\n\n      function _isUint8Array(obj) {\n        return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n      }\n      /*</replacement>*/\n\n      /*<replacement>*/\n\n\n      var util = require('core-util-is');\n\n      util.inherits = require('inherits');\n      /*</replacement>*/\n\n      /*<replacement>*/\n\n      var debugUtil = require('util');\n\n      var debug = void 0;\n\n      if (debugUtil && debugUtil.debuglog) {\n        debug = debugUtil.debuglog('stream');\n      } else {\n        debug = function () {};\n      }\n      /*</replacement>*/\n\n\n      var BufferList = require('./internal/streams/BufferList');\n\n      var destroyImpl = require('./internal/streams/destroy');\n\n      var StringDecoder;\n      util.inherits(Readable, Stream);\n      var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\n      function prependListener(emitter, event, fn) {\n        // Sadly this is not cacheable as some libraries bundle their own\n        // event emitter implementation with them.\n        if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n        // userland ones.  NEVER DO THIS. This is here only because this code needs\n        // to continue to work with older versions of Node.js that do not include\n        // the prependListener() method. The goal is to eventually remove this hack.\n\n        if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n      }\n\n      function ReadableState(options, stream) {\n        Duplex = Duplex || require('./_stream_duplex');\n        options = options || {}; // Duplex streams are both readable and writable, but share\n        // the same options object.\n        // However, some cases require setting options to different\n        // values for the readable and the writable sides of the duplex stream.\n        // These options can be provided separately as readableXXX and writableXXX.\n\n        var isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n        // make all the buffer merging and length checks go away\n\n        this.objectMode = !!options.objectMode;\n        if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n        // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n        var hwm = options.highWaterMark;\n        var readableHwm = options.readableHighWaterMark;\n        var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n        if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm; // cast to ints.\n\n        this.highWaterMark = Math.floor(this.highWaterMark); // A linked list is used to store data chunks instead of an array because the\n        // linked list can remove elements from the beginning faster than\n        // array.shift()\n\n        this.buffer = new BufferList();\n        this.length = 0;\n        this.pipes = null;\n        this.pipesCount = 0;\n        this.flowing = null;\n        this.ended = false;\n        this.endEmitted = false;\n        this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n        // immediately, or on a later tick.  We set this to true at first, because\n        // any actions that shouldn't happen until \"later\" should generally also\n        // not happen before the first read call.\n\n        this.sync = true; // whenever we return null, then we set a flag to say\n        // that we're awaiting a 'readable' event emission.\n\n        this.needReadable = false;\n        this.emittedReadable = false;\n        this.readableListening = false;\n        this.resumeScheduled = false; // has it been destroyed\n\n        this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n        // encoding is 'binary' so we have to make this configurable.\n        // Everything else in the universe uses 'utf8', though.\n\n        this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n        this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n        this.readingMore = false;\n        this.decoder = null;\n        this.encoding = null;\n\n        if (options.encoding) {\n          if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n          this.decoder = new StringDecoder(options.encoding);\n          this.encoding = options.encoding;\n        }\n      }\n\n      function Readable(options) {\n        Duplex = Duplex || require('./_stream_duplex');\n        if (!(this instanceof Readable)) return new Readable(options);\n        this._readableState = new ReadableState(options, this); // legacy\n\n        this.readable = true;\n\n        if (options) {\n          if (typeof options.read === 'function') this._read = options.read;\n          if (typeof options.destroy === 'function') this._destroy = options.destroy;\n        }\n\n        Stream.call(this);\n      }\n\n      Object.defineProperty(Readable.prototype, 'destroyed', {\n        get: function () {\n          if (this._readableState === undefined) {\n            return false;\n          }\n\n          return this._readableState.destroyed;\n        },\n        set: function (value) {\n          // we ignore the value if the stream\n          // has not been initialized yet\n          if (!this._readableState) {\n            return;\n          } // backward compatibility, the user is explicitly\n          // managing destroyed\n\n\n          this._readableState.destroyed = value;\n        }\n      });\n      Readable.prototype.destroy = destroyImpl.destroy;\n      Readable.prototype._undestroy = destroyImpl.undestroy;\n\n      Readable.prototype._destroy = function (err, cb) {\n        this.push(null);\n        cb(err);\n      }; // Manually shove something into the read() buffer.\n      // This returns true if the highWaterMark has not been hit yet,\n      // similar to how Writable.write() returns true if you should\n      // write() some more.\n\n\n      Readable.prototype.push = function (chunk, encoding) {\n        var state = this._readableState;\n        var skipChunkCheck;\n\n        if (!state.objectMode) {\n          if (typeof chunk === 'string') {\n            encoding = encoding || state.defaultEncoding;\n\n            if (encoding !== state.encoding) {\n              chunk = Buffer.from(chunk, encoding);\n              encoding = '';\n            }\n\n            skipChunkCheck = true;\n          }\n        } else {\n          skipChunkCheck = true;\n        }\n\n        return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n      }; // Unshift should *always* be something directly out of read()\n\n\n      Readable.prototype.unshift = function (chunk) {\n        return readableAddChunk(this, chunk, null, true, false);\n      };\n\n      function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n        var state = stream._readableState;\n\n        if (chunk === null) {\n          state.reading = false;\n          onEofChunk(stream, state);\n        } else {\n          var er;\n          if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n          if (er) {\n            stream.emit('error', er);\n          } else if (state.objectMode || chunk && chunk.length > 0) {\n            if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n              chunk = _uint8ArrayToBuffer(chunk);\n            }\n\n            if (addToFront) {\n              if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n            } else if (state.ended) {\n              stream.emit('error', new Error('stream.push() after EOF'));\n            } else {\n              state.reading = false;\n\n              if (state.decoder && !encoding) {\n                chunk = state.decoder.write(chunk);\n                if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n              } else {\n                addChunk(stream, state, chunk, false);\n              }\n            }\n          } else if (!addToFront) {\n            state.reading = false;\n          }\n        }\n\n        return needMoreData(state);\n      }\n\n      function addChunk(stream, state, chunk, addToFront) {\n        if (state.flowing && state.length === 0 && !state.sync) {\n          stream.emit('data', chunk);\n          stream.read(0);\n        } else {\n          // update the buffer info.\n          state.length += state.objectMode ? 1 : chunk.length;\n          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n          if (state.needReadable) emitReadable(stream);\n        }\n\n        maybeReadMore(stream, state);\n      }\n\n      function chunkInvalid(state, chunk) {\n        var er;\n\n        if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n          er = new TypeError('Invalid non-string/buffer chunk');\n        }\n\n        return er;\n      } // if it's past the high water mark, we can push in some more.\n      // Also, if we have no data yet, we can stand some\n      // more bytes.  This is to work around cases where hwm=0,\n      // such as the repl.  Also, if the push() triggered a\n      // readable event, and the user called read(largeNumber) such that\n      // needReadable was set, then we ought to push more, so that another\n      // 'readable' event will be triggered.\n\n\n      function needMoreData(state) {\n        return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n      }\n\n      Readable.prototype.isPaused = function () {\n        return this._readableState.flowing === false;\n      }; // backwards compatibility.\n\n\n      Readable.prototype.setEncoding = function (enc) {\n        if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n        this._readableState.decoder = new StringDecoder(enc);\n        this._readableState.encoding = enc;\n        return this;\n      }; // Don't raise the hwm > 8MB\n\n\n      var MAX_HWM = 0x800000;\n\n      function computeNewHighWaterMark(n) {\n        if (n >= MAX_HWM) {\n          n = MAX_HWM;\n        } else {\n          // Get the next highest power of 2 to prevent increasing hwm excessively in\n          // tiny amounts\n          n--;\n          n |= n >>> 1;\n          n |= n >>> 2;\n          n |= n >>> 4;\n          n |= n >>> 8;\n          n |= n >>> 16;\n          n++;\n        }\n\n        return n;\n      } // This function is designed to be inlinable, so please take care when making\n      // changes to the function body.\n\n\n      function howMuchToRead(n, state) {\n        if (n <= 0 || state.length === 0 && state.ended) return 0;\n        if (state.objectMode) return 1;\n\n        if (n !== n) {\n          // Only flow one buffer at a time\n          if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n        } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n        if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n        if (n <= state.length) return n; // Don't have enough\n\n        if (!state.ended) {\n          state.needReadable = true;\n          return 0;\n        }\n\n        return state.length;\n      } // you can override either this method, or the async _read(n) below.\n\n\n      Readable.prototype.read = function (n) {\n        debug('read', n);\n        n = parseInt(n, 10);\n        var state = this._readableState;\n        var nOrig = n;\n        if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n        // already have a bunch of data in the buffer, then just trigger\n        // the 'readable' event and move on.\n\n        if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n          debug('read: emitReadable', state.length, state.ended);\n          if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n          return null;\n        }\n\n        n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n        if (n === 0 && state.ended) {\n          if (state.length === 0) endReadable(this);\n          return null;\n        } // All the actual chunk generation logic needs to be\n        // *below* the call to _read.  The reason is that in certain\n        // synthetic stream cases, such as passthrough streams, _read\n        // may be a completely synchronous operation which may change\n        // the state of the read buffer, providing enough data when\n        // before there was *not* enough.\n        //\n        // So, the steps are:\n        // 1. Figure out what the state of things will be after we do\n        // a read from the buffer.\n        //\n        // 2. If that resulting state will trigger a _read, then call _read.\n        // Note that this may be asynchronous, or synchronous.  Yes, it is\n        // deeply ugly to write APIs this way, but that still doesn't mean\n        // that the Readable class should behave improperly, as streams are\n        // designed to be sync/async agnostic.\n        // Take note if the _read call is sync or async (ie, if the read call\n        // has returned yet), so that we know whether or not it's safe to emit\n        // 'readable' etc.\n        //\n        // 3. Actually pull the requested chunks out of the buffer and return.\n        // if we need a readable event, then we need to do some reading.\n\n\n        var doRead = state.needReadable;\n        debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n        if (state.length === 0 || state.length - n < state.highWaterMark) {\n          doRead = true;\n          debug('length less than watermark', doRead);\n        } // however, if we've ended, then there's no point, and if we're already\n        // reading, then it's unnecessary.\n\n\n        if (state.ended || state.reading) {\n          doRead = false;\n          debug('reading or ended', doRead);\n        } else if (doRead) {\n          debug('do read');\n          state.reading = true;\n          state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n          if (state.length === 0) state.needReadable = true; // call internal read method\n\n          this._read(state.highWaterMark);\n\n          state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n          // and we need to re-evaluate how much data we can return to the user.\n\n          if (!state.reading) n = howMuchToRead(nOrig, state);\n        }\n\n        var ret;\n        if (n > 0) ret = fromList(n, state);else ret = null;\n\n        if (ret === null) {\n          state.needReadable = true;\n          n = 0;\n        } else {\n          state.length -= n;\n        }\n\n        if (state.length === 0) {\n          // If we have nothing in the buffer, then we want to know\n          // as soon as we *do* get something into the buffer.\n          if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n          if (nOrig !== n && state.ended) endReadable(this);\n        }\n\n        if (ret !== null) this.emit('data', ret);\n        return ret;\n      };\n\n      function onEofChunk(stream, state) {\n        if (state.ended) return;\n\n        if (state.decoder) {\n          var chunk = state.decoder.end();\n\n          if (chunk && chunk.length) {\n            state.buffer.push(chunk);\n            state.length += state.objectMode ? 1 : chunk.length;\n          }\n        }\n\n        state.ended = true; // emit 'readable' now to make sure it gets picked up.\n\n        emitReadable(stream);\n      } // Don't emit readable right away in sync mode, because this can trigger\n      // another read() call => stack overflow.  This way, it might trigger\n      // a nextTick recursion warning, but that's not so bad.\n\n\n      function emitReadable(stream) {\n        var state = stream._readableState;\n        state.needReadable = false;\n\n        if (!state.emittedReadable) {\n          debug('emitReadable', state.flowing);\n          state.emittedReadable = true;\n          if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n        }\n      }\n\n      function emitReadable_(stream) {\n        debug('emit readable');\n        stream.emit('readable');\n        flow(stream);\n      } // at this point, the user has presumably seen the 'readable' event,\n      // and called read() to consume some data.  that may have triggered\n      // in turn another _read(n) call, in which case reading = true if\n      // it's in progress.\n      // However, if we're not ended, or reading, and the length < hwm,\n      // then go ahead and try to read some more preemptively.\n\n\n      function maybeReadMore(stream, state) {\n        if (!state.readingMore) {\n          state.readingMore = true;\n          pna.nextTick(maybeReadMore_, stream, state);\n        }\n      }\n\n      function maybeReadMore_(stream, state) {\n        var len = state.length;\n\n        while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n          debug('maybeReadMore read 0');\n          stream.read(0);\n          if (len === state.length) // didn't get any data, stop spinning.\n            break;else len = state.length;\n        }\n\n        state.readingMore = false;\n      } // abstract method.  to be overridden in specific implementation classes.\n      // call cb(er, data) where data is <= n in length.\n      // for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n      // arbitrary, and perhaps not very meaningful.\n\n\n      Readable.prototype._read = function (n) {\n        this.emit('error', new Error('_read() is not implemented'));\n      };\n\n      Readable.prototype.pipe = function (dest, pipeOpts) {\n        var src = this;\n        var state = this._readableState;\n\n        switch (state.pipesCount) {\n          case 0:\n            state.pipes = dest;\n            break;\n\n          case 1:\n            state.pipes = [state.pipes, dest];\n            break;\n\n          default:\n            state.pipes.push(dest);\n            break;\n        }\n\n        state.pipesCount += 1;\n        debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n        var endFn = doEnd ? onend : unpipe;\n        if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n        dest.on('unpipe', onunpipe);\n\n        function onunpipe(readable, unpipeInfo) {\n          debug('onunpipe');\n\n          if (readable === src) {\n            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n              unpipeInfo.hasUnpiped = true;\n              cleanup();\n            }\n          }\n        }\n\n        function onend() {\n          debug('onend');\n          dest.end();\n        } // when the dest drains, it reduces the awaitDrain counter\n        // on the source.  This would be more elegant with a .once()\n        // handler in flow(), but adding and removing repeatedly is\n        // too slow.\n\n\n        var ondrain = pipeOnDrain(src);\n        dest.on('drain', ondrain);\n        var cleanedUp = false;\n\n        function cleanup() {\n          debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n          dest.removeListener('close', onclose);\n          dest.removeListener('finish', onfinish);\n          dest.removeListener('drain', ondrain);\n          dest.removeListener('error', onerror);\n          dest.removeListener('unpipe', onunpipe);\n          src.removeListener('end', onend);\n          src.removeListener('end', unpipe);\n          src.removeListener('data', ondata);\n          cleanedUp = true; // if the reader is waiting for a drain event from this\n          // specific writer, then it would cause it to never start\n          // flowing again.\n          // So, if this is awaiting a drain, then we just call it now.\n          // If we don't know, then assume that we are waiting for one.\n\n          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n        } // If the user pushes more data while we're writing to dest then we'll end up\n        // in ondata again. However, we only want to increase awaitDrain once because\n        // dest will only emit one 'drain' event for the multiple writes.\n        // => Introduce a guard on increasing awaitDrain.\n\n\n        var increasedAwaitDrain = false;\n        src.on('data', ondata);\n\n        function ondata(chunk) {\n          debug('ondata');\n          increasedAwaitDrain = false;\n          var ret = dest.write(chunk);\n\n          if (false === ret && !increasedAwaitDrain) {\n            // If the user unpiped during `dest.write()`, it is possible\n            // to get stuck in a permanently paused state if that write\n            // also returned false.\n            // => Check whether `dest` is still a piping destination.\n            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n              debug('false write response, pause', src._readableState.awaitDrain);\n              src._readableState.awaitDrain++;\n              increasedAwaitDrain = true;\n            }\n\n            src.pause();\n          }\n        } // if the dest has an error, then stop piping into it.\n        // however, don't suppress the throwing behavior for this.\n\n\n        function onerror(er) {\n          debug('onerror', er);\n          unpipe();\n          dest.removeListener('error', onerror);\n          if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n        } // Make sure our error handler is attached before userland ones.\n\n\n        prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n        function onclose() {\n          dest.removeListener('finish', onfinish);\n          unpipe();\n        }\n\n        dest.once('close', onclose);\n\n        function onfinish() {\n          debug('onfinish');\n          dest.removeListener('close', onclose);\n          unpipe();\n        }\n\n        dest.once('finish', onfinish);\n\n        function unpipe() {\n          debug('unpipe');\n          src.unpipe(dest);\n        } // tell the dest that it's being piped to\n\n\n        dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n        if (!state.flowing) {\n          debug('pipe resume');\n          src.resume();\n        }\n\n        return dest;\n      };\n\n      function pipeOnDrain(src) {\n        return function () {\n          var state = src._readableState;\n          debug('pipeOnDrain', state.awaitDrain);\n          if (state.awaitDrain) state.awaitDrain--;\n\n          if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n            state.flowing = true;\n            flow(src);\n          }\n        };\n      }\n\n      Readable.prototype.unpipe = function (dest) {\n        var state = this._readableState;\n        var unpipeInfo = {\n          hasUnpiped: false\n        }; // if we're not piping anywhere, then do nothing.\n\n        if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n        if (state.pipesCount === 1) {\n          // passed in one, but it's not the right one.\n          if (dest && dest !== state.pipes) return this;\n          if (!dest) dest = state.pipes; // got a match.\n\n          state.pipes = null;\n          state.pipesCount = 0;\n          state.flowing = false;\n          if (dest) dest.emit('unpipe', this, unpipeInfo);\n          return this;\n        } // slow case. multiple pipe destinations.\n\n\n        if (!dest) {\n          // remove all.\n          var dests = state.pipes;\n          var len = state.pipesCount;\n          state.pipes = null;\n          state.pipesCount = 0;\n          state.flowing = false;\n\n          for (var i = 0; i < len; i++) {\n            dests[i].emit('unpipe', this, unpipeInfo);\n          }\n\n          return this;\n        } // try to find the right one.\n\n\n        var index = indexOf(state.pipes, dest);\n        if (index === -1) return this;\n        state.pipes.splice(index, 1);\n        state.pipesCount -= 1;\n        if (state.pipesCount === 1) state.pipes = state.pipes[0];\n        dest.emit('unpipe', this, unpipeInfo);\n        return this;\n      }; // set up data events if they are asked for\n      // Ensure readable listeners eventually get something\n\n\n      Readable.prototype.on = function (ev, fn) {\n        var res = Stream.prototype.on.call(this, ev, fn);\n\n        if (ev === 'data') {\n          // Start flowing on next tick if stream isn't explicitly paused\n          if (this._readableState.flowing !== false) this.resume();\n        } else if (ev === 'readable') {\n          var state = this._readableState;\n\n          if (!state.endEmitted && !state.readableListening) {\n            state.readableListening = state.needReadable = true;\n            state.emittedReadable = false;\n\n            if (!state.reading) {\n              pna.nextTick(nReadingNextTick, this);\n            } else if (state.length) {\n              emitReadable(this);\n            }\n          }\n        }\n\n        return res;\n      };\n\n      Readable.prototype.addListener = Readable.prototype.on;\n\n      function nReadingNextTick(self) {\n        debug('readable nexttick read 0');\n        self.read(0);\n      } // pause() and resume() are remnants of the legacy readable stream API\n      // If the user uses them, then switch into old mode.\n\n\n      Readable.prototype.resume = function () {\n        var state = this._readableState;\n\n        if (!state.flowing) {\n          debug('resume');\n          state.flowing = true;\n          resume(this, state);\n        }\n\n        return this;\n      };\n\n      function resume(stream, state) {\n        if (!state.resumeScheduled) {\n          state.resumeScheduled = true;\n          pna.nextTick(resume_, stream, state);\n        }\n      }\n\n      function resume_(stream, state) {\n        if (!state.reading) {\n          debug('resume read 0');\n          stream.read(0);\n        }\n\n        state.resumeScheduled = false;\n        state.awaitDrain = 0;\n        stream.emit('resume');\n        flow(stream);\n        if (state.flowing && !state.reading) stream.read(0);\n      }\n\n      Readable.prototype.pause = function () {\n        debug('call pause flowing=%j', this._readableState.flowing);\n\n        if (false !== this._readableState.flowing) {\n          debug('pause');\n          this._readableState.flowing = false;\n          this.emit('pause');\n        }\n\n        return this;\n      };\n\n      function flow(stream) {\n        var state = stream._readableState;\n        debug('flow', state.flowing);\n\n        while (state.flowing && stream.read() !== null) {}\n      } // wrap an old-style stream as the async data source.\n      // This is *not* part of the readable stream interface.\n      // It is an ugly unfortunate mess of history.\n\n\n      Readable.prototype.wrap = function (stream) {\n        var _this = this;\n\n        var state = this._readableState;\n        var paused = false;\n        stream.on('end', function () {\n          debug('wrapped end');\n\n          if (state.decoder && !state.ended) {\n            var chunk = state.decoder.end();\n            if (chunk && chunk.length) _this.push(chunk);\n          }\n\n          _this.push(null);\n        });\n        stream.on('data', function (chunk) {\n          debug('wrapped data');\n          if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n          if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n          var ret = _this.push(chunk);\n\n          if (!ret) {\n            paused = true;\n            stream.pause();\n          }\n        }); // proxy all the other methods.\n        // important when wrapping filters and duplexes.\n\n        for (var i in stream) {\n          if (this[i] === undefined && typeof stream[i] === 'function') {\n            this[i] = function (method) {\n              return function () {\n                return stream[method].apply(stream, arguments);\n              };\n            }(i);\n          }\n        } // proxy certain important events.\n\n\n        for (var n = 0; n < kProxyEvents.length; n++) {\n          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n        } // when we try to consume some more bytes, simply unpause the\n        // underlying stream.\n\n\n        this._read = function (n) {\n          debug('wrapped _read', n);\n\n          if (paused) {\n            paused = false;\n            stream.resume();\n          }\n        };\n\n        return this;\n      };\n\n      Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n        // making it explicit this property is not enumerable\n        // because otherwise some prototype manipulation in\n        // userland will fail\n        enumerable: false,\n        get: function () {\n          return this._readableState.highWaterMark;\n        }\n      }); // exposed for testing purposes only.\n\n      Readable._fromList = fromList; // Pluck off n bytes from an array of buffers.\n      // Length is the combined lengths of all the buffers in the list.\n      // This function is designed to be inlinable, so please take care when making\n      // changes to the function body.\n\n      function fromList(n, state) {\n        // nothing buffered\n        if (state.length === 0) return null;\n        var ret;\n        if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n          // read it all, truncate the list\n          if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n          state.buffer.clear();\n        } else {\n          // read part of list\n          ret = fromListPartial(n, state.buffer, state.decoder);\n        }\n        return ret;\n      } // Extracts only enough buffered data to satisfy the amount requested.\n      // This function is designed to be inlinable, so please take care when making\n      // changes to the function body.\n\n\n      function fromListPartial(n, list, hasStrings) {\n        var ret;\n\n        if (n < list.head.data.length) {\n          // slice is the same for buffers and strings\n          ret = list.head.data.slice(0, n);\n          list.head.data = list.head.data.slice(n);\n        } else if (n === list.head.data.length) {\n          // first chunk is a perfect match\n          ret = list.shift();\n        } else {\n          // result spans more than one buffer\n          ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n        }\n\n        return ret;\n      } // Copies a specified amount of characters from the list of buffered data\n      // chunks.\n      // This function is designed to be inlinable, so please take care when making\n      // changes to the function body.\n\n\n      function copyFromBufferString(n, list) {\n        var p = list.head;\n        var c = 1;\n        var ret = p.data;\n        n -= ret.length;\n\n        while (p = p.next) {\n          var str = p.data;\n          var nb = n > str.length ? str.length : n;\n          if (nb === str.length) ret += str;else ret += str.slice(0, n);\n          n -= nb;\n\n          if (n === 0) {\n            if (nb === str.length) {\n              ++c;\n              if (p.next) list.head = p.next;else list.head = list.tail = null;\n            } else {\n              list.head = p;\n              p.data = str.slice(nb);\n            }\n\n            break;\n          }\n\n          ++c;\n        }\n\n        list.length -= c;\n        return ret;\n      } // Copies a specified amount of bytes from the list of buffered data chunks.\n      // This function is designed to be inlinable, so please take care when making\n      // changes to the function body.\n\n\n      function copyFromBuffer(n, list) {\n        var ret = Buffer.allocUnsafe(n);\n        var p = list.head;\n        var c = 1;\n        p.data.copy(ret);\n        n -= p.data.length;\n\n        while (p = p.next) {\n          var buf = p.data;\n          var nb = n > buf.length ? buf.length : n;\n          buf.copy(ret, ret.length - n, 0, nb);\n          n -= nb;\n\n          if (n === 0) {\n            if (nb === buf.length) {\n              ++c;\n              if (p.next) list.head = p.next;else list.head = list.tail = null;\n            } else {\n              list.head = p;\n              p.data = buf.slice(nb);\n            }\n\n            break;\n          }\n\n          ++c;\n        }\n\n        list.length -= c;\n        return ret;\n      }\n\n      function endReadable(stream) {\n        var state = stream._readableState; // If we get here before consuming all the bytes, then that is a\n        // bug in node.  Should never happen.\n\n        if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n        if (!state.endEmitted) {\n          state.ended = true;\n          pna.nextTick(endReadableNT, state, stream);\n        }\n      }\n\n      function endReadableNT(state, stream) {\n        // Check that we didn't get one last unshift.\n        if (!state.endEmitted && state.length === 0) {\n          state.endEmitted = true;\n          stream.readable = false;\n          stream.emit('end');\n        }\n      }\n\n      function indexOf(xs, x) {\n        for (var i = 0, l = xs.length; i < l; i++) {\n          if (xs[i] === x) return i;\n        }\n\n        return -1;\n      }\n    }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n  }, {\n    \"./_stream_duplex\": 25,\n    \"./internal/streams/BufferList\": 30,\n    \"./internal/streams/destroy\": 31,\n    \"./internal/streams/stream\": 32,\n    \"_process\": 19,\n    \"core-util-is\": 8,\n    \"events\": 10,\n    \"inherits\": 13,\n    \"isarray\": 15,\n    \"process-nextick-args\": 18,\n    \"safe-buffer\": 38,\n    \"string_decoder/\": 47,\n    \"util\": 3\n  }],\n  28: [function (require, module, exports) {\n    // Copyright Joyent, Inc. and other Node contributors.\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a\n    // copy of this software and associated documentation files (the\n    // \"Software\"), to deal in the Software without restriction, including\n    // without limitation the rights to use, copy, modify, merge, publish,\n    // distribute, sublicense, and/or sell copies of the Software, and to permit\n    // persons to whom the Software is furnished to do so, subject to the\n    // following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included\n    // in all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n    // USE OR OTHER DEALINGS IN THE SOFTWARE.\n    // a transform stream is a readable/writable stream where you do\n    // something with the data.  Sometimes it's called a \"filter\",\n    // but that's not a great name for it, since that implies a thing where\n    // some bits pass through, and others are simply ignored.  (That would\n    // be a valid example of a transform, of course.)\n    //\n    // While the output is causally related to the input, it's not a\n    // necessarily symmetric or synchronous transformation.  For example,\n    // a zlib stream might take multiple plain-text writes(), and then\n    // emit a single compressed chunk some time in the future.\n    //\n    // Here's how this works:\n    //\n    // The Transform stream has all the aspects of the readable and writable\n    // stream classes.  When you write(chunk), that calls _write(chunk,cb)\n    // internally, and returns false if there's a lot of pending writes\n    // buffered up.  When you call read(), that calls _read(n) until\n    // there's enough pending readable data buffered up.\n    //\n    // In a transform stream, the written data is placed in a buffer.  When\n    // _read(n) is called, it transforms the queued up data, calling the\n    // buffered _write cb's as it consumes chunks.  If consuming a single\n    // written chunk would result in multiple output chunks, then the first\n    // outputted bit calls the readcb, and subsequent chunks just go into\n    // the read buffer, and will cause it to emit 'readable' if necessary.\n    //\n    // This way, back-pressure is actually determined by the reading side,\n    // since _read has to be called to start processing a new chunk.  However,\n    // a pathological inflate type of transform can cause excessive buffering\n    // here.  For example, imagine a stream where every byte of input is\n    // interpreted as an integer from 0-255, and then results in that many\n    // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n    // 1kb of data being output.  In this case, you could write a very small\n    // amount of input, and end up with a very large amount of output.  In\n    // such a pathological inflating mechanism, there'd be no way to tell\n    // the system to stop doing the transform.  A single 4MB write could\n    // cause the system to run out of memory.\n    //\n    // However, even in such a pathological case, only a single written chunk\n    // would be consumed, and then the rest would wait (un-transformed) until\n    // the results of the previous transformed chunk were consumed.\n    'use strict';\n\n    module.exports = Transform;\n\n    var Duplex = require('./_stream_duplex');\n    /*<replacement>*/\n\n\n    var util = require('core-util-is');\n\n    util.inherits = require('inherits');\n    /*</replacement>*/\n\n    util.inherits(Transform, Duplex);\n\n    function afterTransform(er, data) {\n      var ts = this._transformState;\n      ts.transforming = false;\n      var cb = ts.writecb;\n\n      if (!cb) {\n        return this.emit('error', new Error('write callback called multiple times'));\n      }\n\n      ts.writechunk = null;\n      ts.writecb = null;\n      if (data != null) // single equals check for both `null` and `undefined`\n        this.push(data);\n      cb(er);\n      var rs = this._readableState;\n      rs.reading = false;\n\n      if (rs.needReadable || rs.length < rs.highWaterMark) {\n        this._read(rs.highWaterMark);\n      }\n    }\n\n    function Transform(options) {\n      if (!(this instanceof Transform)) return new Transform(options);\n      Duplex.call(this, options);\n      this._transformState = {\n        afterTransform: afterTransform.bind(this),\n        needTransform: false,\n        transforming: false,\n        writecb: null,\n        writechunk: null,\n        writeencoding: null\n      }; // start out asking for a readable event once data is transformed.\n\n      this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n      // that Readable wants before the first _read call, so unset the\n      // sync guard flag.\n\n      this._readableState.sync = false;\n\n      if (options) {\n        if (typeof options.transform === 'function') this._transform = options.transform;\n        if (typeof options.flush === 'function') this._flush = options.flush;\n      } // When the writable side finishes, then flush out anything remaining.\n\n\n      this.on('prefinish', prefinish);\n    }\n\n    function prefinish() {\n      var _this = this;\n\n      if (typeof this._flush === 'function') {\n        this._flush(function (er, data) {\n          done(_this, er, data);\n        });\n      } else {\n        done(this, null, null);\n      }\n    }\n\n    Transform.prototype.push = function (chunk, encoding) {\n      this._transformState.needTransform = false;\n      return Duplex.prototype.push.call(this, chunk, encoding);\n    }; // This is the part where you do stuff!\n    // override this function in implementation classes.\n    // 'chunk' is an input chunk.\n    //\n    // Call `push(newChunk)` to pass along transformed output\n    // to the readable side.  You may call 'push' zero or more times.\n    //\n    // Call `cb(err)` when you are done with this chunk.  If you pass\n    // an error, then that'll put the hurt on the whole operation.  If you\n    // never call cb(), then you'll never get another chunk.\n\n\n    Transform.prototype._transform = function (chunk, encoding, cb) {\n      throw new Error('_transform() is not implemented');\n    };\n\n    Transform.prototype._write = function (chunk, encoding, cb) {\n      var ts = this._transformState;\n      ts.writecb = cb;\n      ts.writechunk = chunk;\n      ts.writeencoding = encoding;\n\n      if (!ts.transforming) {\n        var rs = this._readableState;\n        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n      }\n    }; // Doesn't matter what the args are here.\n    // _transform does all the work.\n    // That we got here means that the readable side wants more data.\n\n\n    Transform.prototype._read = function (n) {\n      var ts = this._transformState;\n\n      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n        ts.transforming = true;\n\n        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n      } else {\n        // mark that we need a transform, so that any data that comes in\n        // will get processed, now that we've asked for it.\n        ts.needTransform = true;\n      }\n    };\n\n    Transform.prototype._destroy = function (err, cb) {\n      var _this2 = this;\n\n      Duplex.prototype._destroy.call(this, err, function (err2) {\n        cb(err2);\n\n        _this2.emit('close');\n      });\n    };\n\n    function done(stream, er, data) {\n      if (er) return stream.emit('error', er);\n      if (data != null) // single equals check for both `null` and `undefined`\n        stream.push(data); // if there's nothing in the write buffer, then that means\n      // that nothing more will ever be provided\n\n      if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n      if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n      return stream.push(null);\n    }\n  }, {\n    \"./_stream_duplex\": 25,\n    \"core-util-is\": 8,\n    \"inherits\": 13\n  }],\n  29: [function (require, module, exports) {\n    (function (process, global) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      // A bit simpler than readable streams.\n      // Implement an async ._write(chunk, encoding, cb), and it'll handle all\n      // the drain event emission and buffering.\n      'use strict';\n      /*<replacement>*/\n\n      var pna = require('process-nextick-args');\n      /*</replacement>*/\n\n\n      module.exports = Writable;\n      /* <replacement> */\n\n      function WriteReq(chunk, encoding, cb) {\n        this.chunk = chunk;\n        this.encoding = encoding;\n        this.callback = cb;\n        this.next = null;\n      } // It seems a linked list but it is not\n      // there will be only 2 of these for each stream\n\n\n      function CorkedRequest(state) {\n        var _this = this;\n\n        this.next = null;\n        this.entry = null;\n\n        this.finish = function () {\n          onCorkedFinish(_this, state);\n        };\n      }\n      /* </replacement> */\n\n      /*<replacement>*/\n\n\n      var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n      /*</replacement>*/\n\n      /*<replacement>*/\n\n      var Duplex;\n      /*</replacement>*/\n\n      Writable.WritableState = WritableState;\n      /*<replacement>*/\n\n      var util = require('core-util-is');\n\n      util.inherits = require('inherits');\n      /*</replacement>*/\n\n      /*<replacement>*/\n\n      var internalUtil = {\n        deprecate: require('util-deprecate')\n      };\n      /*</replacement>*/\n\n      /*<replacement>*/\n\n      var Stream = require('./internal/streams/stream');\n      /*</replacement>*/\n\n      /*<replacement>*/\n\n\n      var Buffer = require('safe-buffer').Buffer;\n\n      var OurUint8Array = global.Uint8Array || function () {};\n\n      function _uint8ArrayToBuffer(chunk) {\n        return Buffer.from(chunk);\n      }\n\n      function _isUint8Array(obj) {\n        return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n      }\n      /*</replacement>*/\n\n\n      var destroyImpl = require('./internal/streams/destroy');\n\n      util.inherits(Writable, Stream);\n\n      function nop() {}\n\n      function WritableState(options, stream) {\n        Duplex = Duplex || require('./_stream_duplex');\n        options = options || {}; // Duplex streams are both readable and writable, but share\n        // the same options object.\n        // However, some cases require setting options to different\n        // values for the readable and the writable sides of the duplex stream.\n        // These options can be provided separately as readableXXX and writableXXX.\n\n        var isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n        // contains buffers or objects.\n\n        this.objectMode = !!options.objectMode;\n        if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n        // Note: 0 is a valid value, means that we always return false if\n        // the entire buffer is not flushed immediately on write()\n\n        var hwm = options.highWaterMark;\n        var writableHwm = options.writableHighWaterMark;\n        var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n        if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm; // cast to ints.\n\n        this.highWaterMark = Math.floor(this.highWaterMark); // if _final has been called\n\n        this.finalCalled = false; // drain event flag.\n\n        this.needDrain = false; // at the start of calling end()\n\n        this.ending = false; // when end() has been called, and returned\n\n        this.ended = false; // when 'finish' is emitted\n\n        this.finished = false; // has it been destroyed\n\n        this.destroyed = false; // should we decode strings into buffers before passing to _write?\n        // this is here so that some node-core streams can optimize string\n        // handling at a lower level.\n\n        var noDecode = options.decodeStrings === false;\n        this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n        // encoding is 'binary' so we have to make this configurable.\n        // Everything else in the universe uses 'utf8', though.\n\n        this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n        // of how much we're waiting to get pushed to some underlying\n        // socket or file.\n\n        this.length = 0; // a flag to see when we're in the middle of a write.\n\n        this.writing = false; // when true all writes will be buffered until .uncork() call\n\n        this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n        // or on a later tick.  We set this to true at first, because any\n        // actions that shouldn't happen until \"later\" should generally also\n        // not happen before the first write call.\n\n        this.sync = true; // a flag to know if we're processing previously buffered items, which\n        // may call the _write() callback in the same tick, so that we don't\n        // end up in an overlapped onwrite situation.\n\n        this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n        this.onwrite = function (er) {\n          onwrite(stream, er);\n        }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n        this.writecb = null; // the amount that is being written when _write is called.\n\n        this.writelen = 0;\n        this.bufferedRequest = null;\n        this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n        // this must be 0 before 'finish' can be emitted\n\n        this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n        // This is relevant for synchronous Transform streams\n\n        this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n        this.errorEmitted = false; // count buffered requests\n\n        this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n        // one allocated and free to use, and we maintain at most two\n\n        this.corkedRequestsFree = new CorkedRequest(this);\n      }\n\n      WritableState.prototype.getBuffer = function getBuffer() {\n        var current = this.bufferedRequest;\n        var out = [];\n\n        while (current) {\n          out.push(current);\n          current = current.next;\n        }\n\n        return out;\n      };\n\n      (function () {\n        try {\n          Object.defineProperty(WritableState.prototype, 'buffer', {\n            get: internalUtil.deprecate(function () {\n              return this.getBuffer();\n            }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n          });\n        } catch (_) {}\n      })(); // Test _writableState for inheritance to account for Duplex streams,\n      // whose prototype chain only points to Readable.\n\n\n      var realHasInstance;\n\n      if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n        realHasInstance = Function.prototype[Symbol.hasInstance];\n        Object.defineProperty(Writable, Symbol.hasInstance, {\n          value: function (object) {\n            if (realHasInstance.call(this, object)) return true;\n            if (this !== Writable) return false;\n            return object && object._writableState instanceof WritableState;\n          }\n        });\n      } else {\n        realHasInstance = function (object) {\n          return object instanceof this;\n        };\n      }\n\n      function Writable(options) {\n        Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.\n        // `realHasInstance` is necessary because using plain `instanceof`\n        // would return false, as no `_writableState` property is attached.\n        // Trying to use the custom `instanceof` for Writable here will also break the\n        // Node.js LazyTransform implementation, which has a non-trivial getter for\n        // `_writableState` that would lead to infinite recursion.\n\n        if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n          return new Writable(options);\n        }\n\n        this._writableState = new WritableState(options, this); // legacy.\n\n        this.writable = true;\n\n        if (options) {\n          if (typeof options.write === 'function') this._write = options.write;\n          if (typeof options.writev === 'function') this._writev = options.writev;\n          if (typeof options.destroy === 'function') this._destroy = options.destroy;\n          if (typeof options.final === 'function') this._final = options.final;\n        }\n\n        Stream.call(this);\n      } // Otherwise people can pipe Writable streams, which is just wrong.\n\n\n      Writable.prototype.pipe = function () {\n        this.emit('error', new Error('Cannot pipe, not readable'));\n      };\n\n      function writeAfterEnd(stream, cb) {\n        var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb\n\n        stream.emit('error', er);\n        pna.nextTick(cb, er);\n      } // Checks that a user-supplied chunk is valid, especially for the particular\n      // mode the stream is in. Currently this means that `null` is never accepted\n      // and undefined/non-string values are only allowed in object mode.\n\n\n      function validChunk(stream, state, chunk, cb) {\n        var valid = true;\n        var er = false;\n\n        if (chunk === null) {\n          er = new TypeError('May not write null values to stream');\n        } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n          er = new TypeError('Invalid non-string/buffer chunk');\n        }\n\n        if (er) {\n          stream.emit('error', er);\n          pna.nextTick(cb, er);\n          valid = false;\n        }\n\n        return valid;\n      }\n\n      Writable.prototype.write = function (chunk, encoding, cb) {\n        var state = this._writableState;\n        var ret = false;\n\n        var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n        if (isBuf && !Buffer.isBuffer(chunk)) {\n          chunk = _uint8ArrayToBuffer(chunk);\n        }\n\n        if (typeof encoding === 'function') {\n          cb = encoding;\n          encoding = null;\n        }\n\n        if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n        if (typeof cb !== 'function') cb = nop;\n        if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n          state.pendingcb++;\n          ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n        }\n        return ret;\n      };\n\n      Writable.prototype.cork = function () {\n        var state = this._writableState;\n        state.corked++;\n      };\n\n      Writable.prototype.uncork = function () {\n        var state = this._writableState;\n\n        if (state.corked) {\n          state.corked--;\n          if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n        }\n      };\n\n      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n        // node::ParseEncoding() requires lower case.\n        if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n        if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n        this._writableState.defaultEncoding = encoding;\n        return this;\n      };\n\n      function decodeChunk(state, chunk, encoding) {\n        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n          chunk = Buffer.from(chunk, encoding);\n        }\n\n        return chunk;\n      }\n\n      Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n        // making it explicit this property is not enumerable\n        // because otherwise some prototype manipulation in\n        // userland will fail\n        enumerable: false,\n        get: function () {\n          return this._writableState.highWaterMark;\n        }\n      }); // if we're already writing something, then just put this\n      // in the queue, and wait our turn.  Otherwise, call _write\n      // If we return false, then we need a drain event, so set that flag.\n\n      function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n        if (!isBuf) {\n          var newChunk = decodeChunk(state, chunk, encoding);\n\n          if (chunk !== newChunk) {\n            isBuf = true;\n            encoding = 'buffer';\n            chunk = newChunk;\n          }\n        }\n\n        var len = state.objectMode ? 1 : chunk.length;\n        state.length += len;\n        var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n        if (!ret) state.needDrain = true;\n\n        if (state.writing || state.corked) {\n          var last = state.lastBufferedRequest;\n          state.lastBufferedRequest = {\n            chunk: chunk,\n            encoding: encoding,\n            isBuf: isBuf,\n            callback: cb,\n            next: null\n          };\n\n          if (last) {\n            last.next = state.lastBufferedRequest;\n          } else {\n            state.bufferedRequest = state.lastBufferedRequest;\n          }\n\n          state.bufferedRequestCount += 1;\n        } else {\n          doWrite(stream, state, false, len, chunk, encoding, cb);\n        }\n\n        return ret;\n      }\n\n      function doWrite(stream, state, writev, len, chunk, encoding, cb) {\n        state.writelen = len;\n        state.writecb = cb;\n        state.writing = true;\n        state.sync = true;\n        if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n        state.sync = false;\n      }\n\n      function onwriteError(stream, state, sync, er, cb) {\n        --state.pendingcb;\n\n        if (sync) {\n          // defer the callback if we are being called synchronously\n          // to avoid piling up things on the stack\n          pna.nextTick(cb, er); // this can emit finish, and it will always happen\n          // after error\n\n          pna.nextTick(finishMaybe, stream, state);\n          stream._writableState.errorEmitted = true;\n          stream.emit('error', er);\n        } else {\n          // the caller expect this to happen before if\n          // it is async\n          cb(er);\n          stream._writableState.errorEmitted = true;\n          stream.emit('error', er); // this can emit finish, but finish must\n          // always follow error\n\n          finishMaybe(stream, state);\n        }\n      }\n\n      function onwriteStateUpdate(state) {\n        state.writing = false;\n        state.writecb = null;\n        state.length -= state.writelen;\n        state.writelen = 0;\n      }\n\n      function onwrite(stream, er) {\n        var state = stream._writableState;\n        var sync = state.sync;\n        var cb = state.writecb;\n        onwriteStateUpdate(state);\n        if (er) onwriteError(stream, state, sync, er, cb);else {\n          // Check if we're actually ready to finish, but don't emit yet\n          var finished = needFinish(state);\n\n          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n            clearBuffer(stream, state);\n          }\n\n          if (sync) {\n            /*<replacement>*/\n            asyncWrite(afterWrite, stream, state, finished, cb);\n            /*</replacement>*/\n          } else {\n            afterWrite(stream, state, finished, cb);\n          }\n        }\n      }\n\n      function afterWrite(stream, state, finished, cb) {\n        if (!finished) onwriteDrain(stream, state);\n        state.pendingcb--;\n        cb();\n        finishMaybe(stream, state);\n      } // Must force callback to be called on nextTick, so that we don't\n      // emit 'drain' before the write() consumer gets the 'false' return\n      // value, and has a chance to attach a 'drain' listener.\n\n\n      function onwriteDrain(stream, state) {\n        if (state.length === 0 && state.needDrain) {\n          state.needDrain = false;\n          stream.emit('drain');\n        }\n      } // if there's something in the buffer waiting, then process it\n\n\n      function clearBuffer(stream, state) {\n        state.bufferProcessing = true;\n        var entry = state.bufferedRequest;\n\n        if (stream._writev && entry && entry.next) {\n          // Fast case, write everything using _writev()\n          var l = state.bufferedRequestCount;\n          var buffer = new Array(l);\n          var holder = state.corkedRequestsFree;\n          holder.entry = entry;\n          var count = 0;\n          var allBuffers = true;\n\n          while (entry) {\n            buffer[count] = entry;\n            if (!entry.isBuf) allBuffers = false;\n            entry = entry.next;\n            count += 1;\n          }\n\n          buffer.allBuffers = allBuffers;\n          doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n          // as the hot path ends with doWrite\n\n          state.pendingcb++;\n          state.lastBufferedRequest = null;\n\n          if (holder.next) {\n            state.corkedRequestsFree = holder.next;\n            holder.next = null;\n          } else {\n            state.corkedRequestsFree = new CorkedRequest(state);\n          }\n\n          state.bufferedRequestCount = 0;\n        } else {\n          // Slow case, write chunks one-by-one\n          while (entry) {\n            var chunk = entry.chunk;\n            var encoding = entry.encoding;\n            var cb = entry.callback;\n            var len = state.objectMode ? 1 : chunk.length;\n            doWrite(stream, state, false, len, chunk, encoding, cb);\n            entry = entry.next;\n            state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n            // it means that we need to wait until it does.\n            // also, that means that the chunk and cb are currently\n            // being processed, so move the buffer counter past them.\n\n            if (state.writing) {\n              break;\n            }\n          }\n\n          if (entry === null) state.lastBufferedRequest = null;\n        }\n\n        state.bufferedRequest = entry;\n        state.bufferProcessing = false;\n      }\n\n      Writable.prototype._write = function (chunk, encoding, cb) {\n        cb(new Error('_write() is not implemented'));\n      };\n\n      Writable.prototype._writev = null;\n\n      Writable.prototype.end = function (chunk, encoding, cb) {\n        var state = this._writableState;\n\n        if (typeof chunk === 'function') {\n          cb = chunk;\n          chunk = null;\n          encoding = null;\n        } else if (typeof encoding === 'function') {\n          cb = encoding;\n          encoding = null;\n        }\n\n        if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n        if (state.corked) {\n          state.corked = 1;\n          this.uncork();\n        } // ignore unnecessary end() calls.\n\n\n        if (!state.ending && !state.finished) endWritable(this, state, cb);\n      };\n\n      function needFinish(state) {\n        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n      }\n\n      function callFinal(stream, state) {\n        stream._final(function (err) {\n          state.pendingcb--;\n\n          if (err) {\n            stream.emit('error', err);\n          }\n\n          state.prefinished = true;\n          stream.emit('prefinish');\n          finishMaybe(stream, state);\n        });\n      }\n\n      function prefinish(stream, state) {\n        if (!state.prefinished && !state.finalCalled) {\n          if (typeof stream._final === 'function') {\n            state.pendingcb++;\n            state.finalCalled = true;\n            pna.nextTick(callFinal, stream, state);\n          } else {\n            state.prefinished = true;\n            stream.emit('prefinish');\n          }\n        }\n      }\n\n      function finishMaybe(stream, state) {\n        var need = needFinish(state);\n\n        if (need) {\n          prefinish(stream, state);\n\n          if (state.pendingcb === 0) {\n            state.finished = true;\n            stream.emit('finish');\n          }\n        }\n\n        return need;\n      }\n\n      function endWritable(stream, state, cb) {\n        state.ending = true;\n        finishMaybe(stream, state);\n\n        if (cb) {\n          if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n        }\n\n        state.ended = true;\n        stream.writable = false;\n      }\n\n      function onCorkedFinish(corkReq, state, err) {\n        var entry = corkReq.entry;\n        corkReq.entry = null;\n\n        while (entry) {\n          var cb = entry.callback;\n          state.pendingcb--;\n          cb(err);\n          entry = entry.next;\n        }\n\n        if (state.corkedRequestsFree) {\n          state.corkedRequestsFree.next = corkReq;\n        } else {\n          state.corkedRequestsFree = corkReq;\n        }\n      }\n\n      Object.defineProperty(Writable.prototype, 'destroyed', {\n        get: function () {\n          if (this._writableState === undefined) {\n            return false;\n          }\n\n          return this._writableState.destroyed;\n        },\n        set: function (value) {\n          // we ignore the value if the stream\n          // has not been initialized yet\n          if (!this._writableState) {\n            return;\n          } // backward compatibility, the user is explicitly\n          // managing destroyed\n\n\n          this._writableState.destroyed = value;\n        }\n      });\n      Writable.prototype.destroy = destroyImpl.destroy;\n      Writable.prototype._undestroy = destroyImpl.undestroy;\n\n      Writable.prototype._destroy = function (err, cb) {\n        this.end();\n        cb(err);\n      };\n    }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n  }, {\n    \"./_stream_duplex\": 25,\n    \"./internal/streams/destroy\": 31,\n    \"./internal/streams/stream\": 32,\n    \"_process\": 19,\n    \"core-util-is\": 8,\n    \"inherits\": 13,\n    \"process-nextick-args\": 18,\n    \"safe-buffer\": 38,\n    \"util-deprecate\": 51\n  }],\n  30: [function (require, module, exports) {\n    'use strict';\n\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n\n    var Buffer = require('safe-buffer').Buffer;\n\n    var util = require('util');\n\n    function copyBuffer(src, target, offset) {\n      src.copy(target, offset);\n    }\n\n    module.exports = function () {\n      function BufferList() {\n        _classCallCheck(this, BufferList);\n\n        this.head = null;\n        this.tail = null;\n        this.length = 0;\n      }\n\n      BufferList.prototype.push = function push(v) {\n        var entry = {\n          data: v,\n          next: null\n        };\n        if (this.length > 0) this.tail.next = entry;else this.head = entry;\n        this.tail = entry;\n        ++this.length;\n      };\n\n      BufferList.prototype.unshift = function unshift(v) {\n        var entry = {\n          data: v,\n          next: this.head\n        };\n        if (this.length === 0) this.tail = entry;\n        this.head = entry;\n        ++this.length;\n      };\n\n      BufferList.prototype.shift = function shift() {\n        if (this.length === 0) return;\n        var ret = this.head.data;\n        if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n        --this.length;\n        return ret;\n      };\n\n      BufferList.prototype.clear = function clear() {\n        this.head = this.tail = null;\n        this.length = 0;\n      };\n\n      BufferList.prototype.join = function join(s) {\n        if (this.length === 0) return '';\n        var p = this.head;\n        var ret = '' + p.data;\n\n        while (p = p.next) {\n          ret += s + p.data;\n        }\n\n        return ret;\n      };\n\n      BufferList.prototype.concat = function concat(n) {\n        if (this.length === 0) return Buffer.alloc(0);\n        if (this.length === 1) return this.head.data;\n        var ret = Buffer.allocUnsafe(n >>> 0);\n        var p = this.head;\n        var i = 0;\n\n        while (p) {\n          copyBuffer(p.data, ret, i);\n          i += p.data.length;\n          p = p.next;\n        }\n\n        return ret;\n      };\n\n      return BufferList;\n    }();\n\n    if (util && util.inspect && util.inspect.custom) {\n      module.exports.prototype[util.inspect.custom] = function () {\n        var obj = util.inspect({\n          length: this.length\n        });\n        return this.constructor.name + ' ' + obj;\n      };\n    }\n  }, {\n    \"safe-buffer\": 38,\n    \"util\": 3\n  }],\n  31: [function (require, module, exports) {\n    'use strict';\n    /*<replacement>*/\n\n    var pna = require('process-nextick-args');\n    /*</replacement>*/\n    // undocumented cb() API, needed for core, not for public API\n\n\n    function destroy(err, cb) {\n      var _this = this;\n\n      var readableDestroyed = this._readableState && this._readableState.destroyed;\n      var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n      if (readableDestroyed || writableDestroyed) {\n        if (cb) {\n          cb(err);\n        } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n          pna.nextTick(emitErrorNT, this, err);\n        }\n\n        return this;\n      } // we set destroyed to true before firing error callbacks in order\n      // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n      if (this._readableState) {\n        this._readableState.destroyed = true;\n      } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n      if (this._writableState) {\n        this._writableState.destroyed = true;\n      }\n\n      this._destroy(err || null, function (err) {\n        if (!cb && err) {\n          pna.nextTick(emitErrorNT, _this, err);\n\n          if (_this._writableState) {\n            _this._writableState.errorEmitted = true;\n          }\n        } else if (cb) {\n          cb(err);\n        }\n      });\n\n      return this;\n    }\n\n    function undestroy() {\n      if (this._readableState) {\n        this._readableState.destroyed = false;\n        this._readableState.reading = false;\n        this._readableState.ended = false;\n        this._readableState.endEmitted = false;\n      }\n\n      if (this._writableState) {\n        this._writableState.destroyed = false;\n        this._writableState.ended = false;\n        this._writableState.ending = false;\n        this._writableState.finished = false;\n        this._writableState.errorEmitted = false;\n      }\n    }\n\n    function emitErrorNT(self, err) {\n      self.emit('error', err);\n    }\n\n    module.exports = {\n      destroy: destroy,\n      undestroy: undestroy\n    };\n  }, {\n    \"process-nextick-args\": 18\n  }],\n  32: [function (require, module, exports) {\n    module.exports = require('events').EventEmitter;\n  }, {\n    \"events\": 10\n  }],\n  33: [function (require, module, exports) {\n    module.exports = require('./readable').PassThrough;\n  }, {\n    \"./readable\": 34\n  }],\n  34: [function (require, module, exports) {\n    exports = module.exports = require('./lib/_stream_readable.js');\n    exports.Stream = exports;\n    exports.Readable = exports;\n    exports.Writable = require('./lib/_stream_writable.js');\n    exports.Duplex = require('./lib/_stream_duplex.js');\n    exports.Transform = require('./lib/_stream_transform.js');\n    exports.PassThrough = require('./lib/_stream_passthrough.js');\n  }, {\n    \"./lib/_stream_duplex.js\": 25,\n    \"./lib/_stream_passthrough.js\": 26,\n    \"./lib/_stream_readable.js\": 27,\n    \"./lib/_stream_transform.js\": 28,\n    \"./lib/_stream_writable.js\": 29\n  }],\n  35: [function (require, module, exports) {\n    module.exports = require('./readable').Transform;\n  }, {\n    \"./readable\": 34\n  }],\n  36: [function (require, module, exports) {\n    module.exports = require('./lib/_stream_writable.js');\n  }, {\n    \"./lib/_stream_writable.js\": 29\n  }],\n  37: [function (require, module, exports) {\n    'use strict';\n\n    var Module = require('module');\n\n    var path = require('path');\n\n    module.exports = function requireFromString(code, filename, opts) {\n      if (typeof filename === 'object') {\n        opts = filename;\n        filename = undefined;\n      }\n\n      opts = opts || {};\n      filename = filename || '';\n      opts.appendPaths = opts.appendPaths || [];\n      opts.prependPaths = opts.prependPaths || [];\n\n      if (typeof code !== 'string') {\n        throw new Error('code must be a string, not ' + typeof code);\n      }\n\n      var paths = Module._nodeModulePaths(path.dirname(filename));\n\n      var m = new Module(filename, module.parent);\n      m.filename = filename;\n      m.paths = [].concat(opts.prependPaths).concat(paths).concat(opts.appendPaths);\n\n      m._compile(code, filename);\n\n      return m.exports;\n    };\n  }, {\n    \"module\": 4,\n    \"path\": 17\n  }],\n  38: [function (require, module, exports) {\n    /* eslint-disable node/no-deprecated-api */\n    var buffer = require('buffer');\n\n    var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers\n\n    function copyProps(src, dst) {\n      for (var key in src) {\n        dst[key] = src[key];\n      }\n    }\n\n    if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n      module.exports = buffer;\n    } else {\n      // Copy properties from require('buffer')\n      copyProps(buffer, exports);\n      exports.Buffer = SafeBuffer;\n    }\n\n    function SafeBuffer(arg, encodingOrOffset, length) {\n      return Buffer(arg, encodingOrOffset, length);\n    } // Copy static methods from Buffer\n\n\n    copyProps(Buffer, SafeBuffer);\n\n    SafeBuffer.from = function (arg, encodingOrOffset, length) {\n      if (typeof arg === 'number') {\n        throw new TypeError('Argument must not be a number');\n      }\n\n      return Buffer(arg, encodingOrOffset, length);\n    };\n\n    SafeBuffer.alloc = function (size, fill, encoding) {\n      if (typeof size !== 'number') {\n        throw new TypeError('Argument must be a number');\n      }\n\n      var buf = Buffer(size);\n\n      if (fill !== undefined) {\n        if (typeof encoding === 'string') {\n          buf.fill(fill, encoding);\n        } else {\n          buf.fill(fill);\n        }\n      } else {\n        buf.fill(0);\n      }\n\n      return buf;\n    };\n\n    SafeBuffer.allocUnsafe = function (size) {\n      if (typeof size !== 'number') {\n        throw new TypeError('Argument must be a number');\n      }\n\n      return Buffer(size);\n    };\n\n    SafeBuffer.allocUnsafeSlow = function (size) {\n      if (typeof size !== 'number') {\n        throw new TypeError('Argument must be a number');\n      }\n\n      return buffer.SlowBuffer(size);\n    };\n  }, {\n    \"buffer\": 6\n  }],\n  39: [function (require, module, exports) {\n    var linkBytecode = function (bytecode, libraries) {\n      // NOTE: for backwards compatibility support old compiler which didn't use file names\n      var librariesComplete = {};\n\n      for (var libraryName in libraries) {\n        if (typeof libraryName === 'object') {\n          // API compatible with the standard JSON i/o\n          for (var lib in libraries[libraryName]) {\n            librariesComplete[lib] = libraries[libraryName][lib];\n            librariesComplete[libraryName + ':' + lib] = libraries[libraryName][lib];\n          }\n        } else {\n          // backwards compatible API for early solc-js verisons\n          var parsed = libraryName.match(/^([^:]*):?(.*)$/);\n\n          if (parsed) {\n            librariesComplete[parsed[2]] = libraries[libraryName];\n          }\n\n          librariesComplete[libraryName] = libraries[libraryName];\n        }\n      }\n\n      for (libraryName in librariesComplete) {\n        // truncate to 37 characters\n        var internalName = libraryName.slice(0, 36); // prefix and suffix with __\n\n        var libLabel = '__' + internalName + Array(37 - internalName.length).join('_') + '__';\n        var hexAddress = librariesComplete[libraryName];\n\n        if (hexAddress.slice(0, 2) !== '0x' || hexAddress.length > 42) {\n          throw new Error('Invalid address specified for ' + libraryName);\n        } // remove 0x prefix\n\n\n        hexAddress = hexAddress.slice(2);\n        hexAddress = Array(40 - hexAddress.length + 1).join('0') + hexAddress;\n\n        while (bytecode.indexOf(libLabel) >= 0) {\n          bytecode = bytecode.replace(libLabel, hexAddress);\n        }\n      }\n\n      return bytecode;\n    };\n\n    var findLinkReferences = function (bytecode) {\n      // find 40 bytes in the pattern of __...<36 digits>...__\n      // e.g. __Lib.sol:L_____________________________\n      var linkReferences = {};\n      var offset = 0;\n\n      while (true) {\n        var found = bytecode.match(/__(.{36})__/);\n\n        if (!found) {\n          break;\n        }\n\n        var start = found.index; // trim trailing underscores\n        // NOTE: this has no way of knowing if the trailing underscore was part of the name\n\n        var libraryName = found[1].replace(/_+$/gm, '');\n\n        if (!linkReferences[libraryName]) {\n          linkReferences[libraryName] = [];\n        }\n\n        linkReferences[libraryName].push({\n          // offsets are in bytes in binary representation (and not hex)\n          start: (offset + start) / 2,\n          length: 20\n        });\n        offset += start + 20;\n        bytecode = bytecode.slice(start + 20);\n      }\n\n      return linkReferences;\n    };\n\n    module.exports = {\n      linkBytecode: linkBytecode,\n      findLinkReferences: findLinkReferences\n    };\n  }, {}],\n  40: [function (require, module, exports) {\n    var linker = require('./linker.js'); /// Translate old style version numbers to semver.\n    /// Old style: 0.3.6-3fc68da5/Release-Emscripten/clang\n    ///            0.3.5-371690f0/Release-Emscripten/clang/Interpreter\n    ///            0.2.0-e7098958/.-Emscripten/clang/int linked to libethereum-1.1.1-bbb80ab0/.-Emscripten/clang/int\n    ///            0.1.3-0/.-/clang/int linked to libethereum-0.9.92-0/.-/clang/int\n    ///            0.1.2-5c3bfd4b*/.-/clang/int\n    ///            0.1.1-6ff4cd6b/RelWithDebInfo-Emscripten/clang/int\n    /// New style: 0.4.5+commit.b318366e.Emscripten.clang\n\n\n    function versionToSemver(version) {\n      // FIXME: parse more detail, but this is a good start\n      var parsed = version.match(/^([0-9]+\\.[0-9]+\\.[0-9]+)-([0-9a-f]{8})[/*].*$/);\n\n      if (parsed) {\n        return parsed[1] + '+commit.' + parsed[2];\n      }\n\n      if (version.indexOf('0.1.3-0') !== -1) {\n        return '0.1.3';\n      } // assume it is already semver compatible\n\n\n      return version;\n    }\n\n    function translateErrors(ret, errors) {\n      for (var error in errors) {\n        var type = 'error';\n        var extractType = /^(.*):(\\d+):(\\d+):(.*):/;\n        extractType = extractType.exec(errors[error]);\n\n        if (extractType) {\n          type = extractType[4].trim();\n        } else if (errors[error].indexOf(': Warning:')) {\n          type = 'Warning';\n        } else if (errors[error].indexOf(': Error:')) {\n          type = 'Error';\n        }\n\n        ret.push({\n          type: type,\n          component: 'general',\n          severity: type === 'Warning' ? 'warning' : 'error',\n          message: errors[error],\n          formattedMessage: errors[error]\n        });\n      }\n    }\n\n    function translateGasEstimates(gasEstimates) {\n      if (gasEstimates === null) {\n        return 'infinite';\n      }\n\n      if (typeof gasEstimates === 'number') {\n        return gasEstimates.toString();\n      }\n\n      var gasEstimatesTranslated = {};\n\n      for (var func in gasEstimates) {\n        gasEstimatesTranslated[func] = translateGasEstimates(gasEstimates[func]);\n      }\n\n      return gasEstimatesTranslated;\n    }\n\n    function translateJsonCompilerOutput(output, libraries) {\n      var ret = {};\n      ret['errors'] = [];\n      var errors;\n\n      if (output['error']) {\n        errors = [output['error']];\n      } else {\n        errors = output['errors'];\n      }\n\n      translateErrors(ret['errors'], errors);\n      ret['contracts'] = {};\n\n      for (var contract in output['contracts']) {\n        // Split name first, can be `contract`, `:contract` or `filename:contract`\n        var tmp = contract.match(/^(([^:]*):)?([^:]+)$/);\n\n        if (tmp.length !== 4) {\n          // Force abort\n          return null;\n        }\n\n        var fileName = tmp[2];\n\n        if (fileName === undefined) {\n          // this is the case of `contract`\n          fileName = '';\n        }\n\n        var contractName = tmp[3];\n        var contractInput = output['contracts'][contract];\n        var gasEstimates = contractInput['gasEstimates'];\n        var translatedGasEstimates = {};\n\n        if (gasEstimates['creation']) {\n          translatedGasEstimates['creation'] = {\n            'codeDepositCost': translateGasEstimates(gasEstimates['creation'][1]),\n            'executionCost': translateGasEstimates(gasEstimates['creation'][0])\n          };\n        }\n\n        if (gasEstimates['internal']) {\n          translatedGasEstimates['internal'] = translateGasEstimates(gasEstimates['internal']);\n        }\n\n        if (gasEstimates['external']) {\n          translatedGasEstimates['external'] = translateGasEstimates(gasEstimates['external']);\n        }\n\n        var contractOutput = {\n          'abi': JSON.parse(contractInput['interface']),\n          'metadata': contractInput['metadata'],\n          'evm': {\n            'legacyAssembly': contractInput['assembly'],\n            'bytecode': {\n              'object': linker.linkBytecode(contractInput['bytecode'], libraries),\n              'opcodes': contractInput['opcodes'],\n              'sourceMap': contractInput['srcmap'],\n              'linkReferences': linker.findLinkReferences(contractInput['bytecode'])\n            },\n            'deployedBytecode': {\n              'object': linker.linkBytecode(contractInput['runtimeBytecode'], libraries),\n              'sourceMap': contractInput['srcmapRuntime'],\n              'linkReferences': linker.findLinkReferences(contractInput['runtimeBytecode'])\n            },\n            'methodIdentifiers': contractInput['functionHashes'],\n            'gasEstimates': translatedGasEstimates\n          }\n        };\n\n        if (!ret['contracts'][fileName]) {\n          ret['contracts'][fileName] = {};\n        }\n\n        ret['contracts'][fileName][contractName] = contractOutput;\n      }\n\n      var sourceMap = {};\n\n      for (var sourceId in output['sourceList']) {\n        sourceMap[output['sourceList'][sourceId]] = sourceId;\n      }\n\n      ret['sources'] = {};\n\n      for (var source in output['sources']) {\n        ret['sources'][source] = {\n          id: sourceMap[source],\n          legacyAST: output['sources'][source].AST\n        };\n      }\n\n      return ret;\n    }\n\n    function escapeString(text) {\n      return text.replace('\\n', '\\\\n', 'g').replace('\\r', '\\\\r', 'g').replace('\\t', '\\\\t', 'g');\n    }\n\n    function formatAssemblyText(asm, prefix, source) {\n      if (typeof asm === typeof '' || asm === null || asm === undefined) {\n        return prefix + (asm || '') + '\\n';\n      }\n\n      var text = prefix + '.code\\n';\n      asm['.code'].forEach(function (item, i) {\n        var v = item.value === undefined ? '' : item.value;\n        var src = '';\n\n        if (source !== undefined && item.begin !== undefined && item.end !== undefined) {\n          src = escapeString(source.slice(item.begin, item.end));\n        }\n\n        if (src.length > 30) {\n          src = src.slice(0, 30) + '...';\n        }\n\n        if (item.name !== 'tag') {\n          text += '  ';\n        }\n\n        text += prefix + item.name + ' ' + v + '\\t\\t\\t' + src + '\\n';\n      });\n      text += prefix + '.data\\n';\n      var asmData = asm['.data'] || [];\n\n      for (var i in asmData) {\n        var item = asmData[i];\n        text += '  ' + prefix + '' + i + ':\\n';\n        text += formatAssemblyText(item, prefix + '    ', source);\n      }\n\n      return text;\n    }\n\n    function prettyPrintLegacyAssemblyJSON(assembly, source) {\n      return formatAssemblyText(assembly, '', source);\n    }\n\n    module.exports = {\n      versionToSemver: versionToSemver,\n      translateJsonCompilerOutput: translateJsonCompilerOutput,\n      prettyPrintLegacyAssemblyJSON: prettyPrintLegacyAssemblyJSON\n    };\n  }, {\n    \"./linker.js\": 39\n  }],\n  41: [function (require, module, exports) {\n    var assert = require('assert');\n\n    var translate = require('./translate.js');\n\n    var linker = require('./linker.js');\n\n    var requireFromString = require('require-from-string');\n\n    var https = require('https');\n\n    var MemoryStream = require('memorystream');\n\n    function setupMethods(soljson) {\n      var compileJSON = soljson.cwrap('compileJSON', 'string', ['string', 'number']);\n      var compileJSONMulti = null;\n\n      if ('_compileJSONMulti' in soljson) {\n        compileJSONMulti = soljson.cwrap('compileJSONMulti', 'string', ['string', 'number']);\n      }\n\n      var compileJSONCallback = null;\n      var compileStandard = null;\n\n      if ('_compileJSONCallback' in soljson || '_compileStandard' in soljson) {\n        var copyString = function (str, ptr) {\n          var length = soljson.lengthBytesUTF8(str);\n\n          var buffer = soljson._malloc(length + 1);\n\n          soljson.stringToUTF8(str, buffer, length + 1);\n          soljson.setValue(ptr, buffer, '*');\n        };\n\n        var wrapCallback = function (callback) {\n          assert(typeof callback === 'function', 'Invalid callback specified.');\n          return function (path, contents, error) {\n            var result = callback(soljson.Pointer_stringify(path));\n\n            if (typeof result.contents === 'string') {\n              copyString(result.contents, contents);\n            }\n\n            if (typeof result.error === 'string') {\n              copyString(result.error, error);\n            }\n          };\n        }; // This calls compile() with args || cb\n\n\n        var runWithReadCallback = function (readCallback, compile, args) {\n          if (readCallback === undefined) {\n            readCallback = function (path) {\n              return {\n                error: 'File import callback not supported'\n              };\n            };\n          }\n\n          var cb = soljson.Runtime.addFunction(wrapCallback(readCallback));\n          var output;\n\n          try {\n            args.push(cb);\n            output = compile.apply(undefined, args);\n          } catch (e) {\n            soljson.Runtime.removeFunction(cb);\n            throw e;\n          }\n\n          soljson.Runtime.removeFunction(cb);\n          return output;\n        };\n\n        var compileInternal = soljson.cwrap('compileJSONCallback', 'string', ['string', 'number', 'number']);\n\n        compileJSONCallback = function (input, optimize, readCallback) {\n          return runWithReadCallback(readCallback, compileInternal, [input, optimize]);\n        };\n\n        if ('_compileStandard' in soljson) {\n          var compileStandardInternal = soljson.cwrap('compileStandard', 'string', ['string', 'number']);\n\n          compileStandard = function (input, readCallback) {\n            return runWithReadCallback(readCallback, compileStandardInternal, [input]);\n          };\n        }\n      }\n\n      var compile = function (input, optimise, readCallback) {\n        var result = '';\n\n        if (readCallback !== undefined && compileJSONCallback !== null) {\n          result = compileJSONCallback(JSON.stringify(input), optimise, readCallback);\n        } else if (typeof input !== 'string' && compileJSONMulti !== null) {\n          result = compileJSONMulti(JSON.stringify(input), optimise);\n        } else {\n          result = compileJSON(input, optimise);\n        }\n\n        return JSON.parse(result);\n      }; // Expects a Standard JSON I/O but supports old compilers\n\n\n      var compileStandardWrapper = function (input, readCallback) {\n        if (compileStandard !== null) {\n          return compileStandard(input, readCallback);\n        }\n\n        function formatFatalError(message) {\n          return JSON.stringify({\n            errors: [{\n              'type': 'SOLCError',\n              'component': 'solcjs',\n              'severity': 'error',\n              'message': message,\n              'formattedMessage': 'Error: ' + message\n            }]\n          });\n        }\n\n        if (readCallback !== undefined && typeof readCallback !== 'function') {\n          return formatFatalError('Invalid import callback supplied');\n        }\n\n        input = JSON.parse(input);\n\n        if (input['language'] !== 'Solidity') {\n          return formatFatalError('Only Solidity sources are supported');\n        }\n\n        if (input['sources'] == null) {\n          return formatFatalError('No input specified');\n        } // Bail out early\n\n\n        if (input['sources'].length > 1 && compileJSONMulti === null) {\n          return formatFatalError('Multiple sources provided, but compiler only supports single input');\n        }\n\n        function isOptimizerEnabled(input) {\n          return input['settings'] && input['settings']['optimizer'] && input['settings']['optimizer']['enabled'];\n        }\n\n        function translateSources(input) {\n          var sources = {};\n\n          for (var source in input['sources']) {\n            if (input['sources'][source]['content'] !== null) {\n              sources[source] = input['sources'][source]['content'];\n            } else {\n              // force failure\n              return null;\n            }\n          }\n\n          return sources;\n        }\n\n        function librariesSupplied(input) {\n          if (input['settings'] !== null) {\n            return input['settings']['libraries'];\n          }\n        }\n\n        function translateOutput(output) {\n          output = translate.translateJsonCompilerOutput(JSON.parse(output));\n\n          if (output == null) {\n            return formatFatalError('Failed to process output');\n          }\n\n          return JSON.stringify(output);\n        }\n\n        var sources = translateSources(input);\n\n        if (sources === null || Object.keys(sources).length === 0) {\n          return formatFatalError('Failed to process sources');\n        } // Try linking if libraries were supplied\n\n\n        var libraries = librariesSupplied(input); // Try to wrap around old versions\n\n        if (compileJSONCallback !== null) {\n          return translateOutput(compileJSONCallback(JSON.stringify({\n            'sources': sources\n          }), isOptimizerEnabled(input), readCallback), libraries);\n        }\n\n        if (compileJSONMulti !== null) {\n          return translateOutput(compileJSONMulti(JSON.stringify({\n            'sources': sources\n          }), isOptimizerEnabled(input)), libraries);\n        } // Try our luck with an ancient compiler\n\n\n        return translateOutput(compileJSON(sources[Object.keys(sources)[0]], isOptimizerEnabled(input)), libraries);\n      };\n\n      var version = soljson.cwrap('version', 'string', []);\n\n      var versionToSemver = function () {\n        return translate.versionToSemver(version());\n      };\n\n      var license = function () {// return undefined\n      };\n\n      if ('_license' in soljson) {\n        license = soljson.cwrap('license', 'string', []);\n      }\n\n      return {\n        version: version,\n        semver: versionToSemver,\n        license: license,\n        compile: compile,\n        compileStandard: compileStandard,\n        compileStandardWrapper: compileStandardWrapper,\n        linkBytecode: linker.linkBytecode,\n        supportsMulti: compileJSONMulti !== null,\n        supportsImportCallback: compileJSONCallback !== null,\n        supportsStandard: compileStandard !== null,\n        // Loads the compiler of the given version from the github repository\n        // instead of from the local filesystem.\n        loadRemoteVersion: function (versionString, cb) {\n          var mem = new MemoryStream(null, {\n            readable: false\n          });\n          var url = 'https://ethereum.github.io/solc-bin/bin/soljson-' + versionString + '.js';\n          https.get(url, function (response) {\n            if (response.statusCode !== 200) {\n              cb(new Error('Error retrieving binary: ' + response.statusMessage));\n            } else {\n              response.pipe(mem);\n              response.on('end', function () {\n                cb(null, setupMethods(requireFromString(mem.toString(), 'soljson-' + versionString + '.js')));\n              });\n            }\n          }).on('error', function (error) {\n            cb(error);\n          });\n        },\n        // Use this if you want to add wrapper functions around the pure module.\n        setupMethods: setupMethods\n      };\n    }\n\n    module.exports = setupMethods;\n  }, {\n    \"./linker.js\": 39,\n    \"./translate.js\": 40,\n    \"assert\": 1,\n    \"https\": 11,\n    \"memorystream\": 16,\n    \"require-from-string\": 37\n  }],\n  42: [function (require, module, exports) {\n    // Copyright Joyent, Inc. and other Node contributors.\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a\n    // copy of this software and associated documentation files (the\n    // \"Software\"), to deal in the Software without restriction, including\n    // without limitation the rights to use, copy, modify, merge, publish,\n    // distribute, sublicense, and/or sell copies of the Software, and to permit\n    // persons to whom the Software is furnished to do so, subject to the\n    // following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included\n    // in all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n    // USE OR OTHER DEALINGS IN THE SOFTWARE.\n    module.exports = Stream;\n\n    var EE = require('events').EventEmitter;\n\n    var inherits = require('inherits');\n\n    inherits(Stream, EE);\n    Stream.Readable = require('readable-stream/readable.js');\n    Stream.Writable = require('readable-stream/writable.js');\n    Stream.Duplex = require('readable-stream/duplex.js');\n    Stream.Transform = require('readable-stream/transform.js');\n    Stream.PassThrough = require('readable-stream/passthrough.js'); // Backwards-compat with node 0.4.x\n\n    Stream.Stream = Stream; // old-style streams.  Note that the pipe method (the only relevant\n    // part of this class) is overridden in the Readable class.\n\n    function Stream() {\n      EE.call(this);\n    }\n\n    Stream.prototype.pipe = function (dest, options) {\n      var source = this;\n\n      function ondata(chunk) {\n        if (dest.writable) {\n          if (false === dest.write(chunk) && source.pause) {\n            source.pause();\n          }\n        }\n      }\n\n      source.on('data', ondata);\n\n      function ondrain() {\n        if (source.readable && source.resume) {\n          source.resume();\n        }\n      }\n\n      dest.on('drain', ondrain); // If the 'end' option is not supplied, dest.end() will be called when\n      // source gets the 'end' or 'close' events.  Only dest.end() once.\n\n      if (!dest._isStdio && (!options || options.end !== false)) {\n        source.on('end', onend);\n        source.on('close', onclose);\n      }\n\n      var didOnEnd = false;\n\n      function onend() {\n        if (didOnEnd) return;\n        didOnEnd = true;\n        dest.end();\n      }\n\n      function onclose() {\n        if (didOnEnd) return;\n        didOnEnd = true;\n        if (typeof dest.destroy === 'function') dest.destroy();\n      } // don't leave dangling pipes when there are errors.\n\n\n      function onerror(er) {\n        cleanup();\n\n        if (EE.listenerCount(this, 'error') === 0) {\n          throw er; // Unhandled stream error in pipe.\n        }\n      }\n\n      source.on('error', onerror);\n      dest.on('error', onerror); // remove all the event listeners that were added.\n\n      function cleanup() {\n        source.removeListener('data', ondata);\n        dest.removeListener('drain', ondrain);\n        source.removeListener('end', onend);\n        source.removeListener('close', onclose);\n        source.removeListener('error', onerror);\n        dest.removeListener('error', onerror);\n        source.removeListener('end', cleanup);\n        source.removeListener('close', cleanup);\n        dest.removeListener('close', cleanup);\n      }\n\n      source.on('end', cleanup);\n      source.on('close', cleanup);\n      dest.on('close', cleanup);\n      dest.emit('pipe', source); // Allow for unix-like usage: A.pipe(B).pipe(C)\n\n      return dest;\n    };\n  }, {\n    \"events\": 10,\n    \"inherits\": 13,\n    \"readable-stream/duplex.js\": 24,\n    \"readable-stream/passthrough.js\": 33,\n    \"readable-stream/readable.js\": 34,\n    \"readable-stream/transform.js\": 35,\n    \"readable-stream/writable.js\": 36\n  }],\n  43: [function (require, module, exports) {\n    (function (global) {\n      var ClientRequest = require('./lib/request');\n\n      var response = require('./lib/response');\n\n      var extend = require('xtend');\n\n      var statusCodes = require('builtin-status-codes');\n\n      var url = require('url');\n\n      var http = exports;\n\n      http.request = function (opts, cb) {\n        if (typeof opts === 'string') opts = url.parse(opts);else opts = extend(opts); // Normally, the page is loaded from http or https, so not specifying a protocol\n        // will result in a (valid) protocol-relative url. However, this won't work if\n        // the protocol is something else, like 'file:'\n\n        var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : '';\n        var protocol = opts.protocol || defaultProtocol;\n        var host = opts.hostname || opts.host;\n        var port = opts.port;\n        var path = opts.path || '/'; // Necessary for IPv6 addresses\n\n        if (host && host.indexOf(':') !== -1) host = '[' + host + ']'; // This may be a relative url. The browser should always be able to interpret it correctly.\n\n        opts.url = (host ? protocol + '//' + host : '') + (port ? ':' + port : '') + path;\n        opts.method = (opts.method || 'GET').toUpperCase();\n        opts.headers = opts.headers || {}; // Also valid opts.auth, opts.mode\n\n        var req = new ClientRequest(opts);\n        if (cb) req.on('response', cb);\n        return req;\n      };\n\n      http.get = function get(opts, cb) {\n        var req = http.request(opts, cb);\n        req.end();\n        return req;\n      };\n\n      http.ClientRequest = ClientRequest;\n      http.IncomingMessage = response.IncomingMessage;\n\n      http.Agent = function () {};\n\n      http.Agent.defaultMaxSockets = 4;\n      http.globalAgent = new http.Agent();\n      http.STATUS_CODES = statusCodes;\n      http.METHODS = ['CHECKOUT', 'CONNECT', 'COPY', 'DELETE', 'GET', 'HEAD', 'LOCK', 'M-SEARCH', 'MERGE', 'MKACTIVITY', 'MKCOL', 'MOVE', 'NOTIFY', 'OPTIONS', 'PATCH', 'POST', 'PROPFIND', 'PROPPATCH', 'PURGE', 'PUT', 'REPORT', 'SEARCH', 'SUBSCRIBE', 'TRACE', 'UNLOCK', 'UNSUBSCRIBE'];\n    }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n  }, {\n    \"./lib/request\": 45,\n    \"./lib/response\": 46,\n    \"builtin-status-codes\": 7,\n    \"url\": 49,\n    \"xtend\": 55\n  }],\n  44: [function (require, module, exports) {\n    (function (global) {\n      exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream);\n      exports.writableStream = isFunction(global.WritableStream);\n      exports.abortController = isFunction(global.AbortController);\n      exports.blobConstructor = false;\n\n      try {\n        new Blob([new ArrayBuffer(1)]);\n        exports.blobConstructor = true;\n      } catch (e) {} // The xhr request to example.com may violate some restrictive CSP configurations,\n      // so if we're running in a browser that supports `fetch`, avoid calling getXHR()\n      // and assume support for certain features below.\n\n\n      var xhr;\n\n      function getXHR() {\n        // Cache the xhr value\n        if (xhr !== undefined) return xhr;\n\n        if (global.XMLHttpRequest) {\n          xhr = new global.XMLHttpRequest(); // If XDomainRequest is available (ie only, where xhr might not work\n          // cross domain), use the page location. Otherwise use example.com\n          // Note: this doesn't actually make an http request.\n\n          try {\n            xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com');\n          } catch (e) {\n            xhr = null;\n          }\n        } else {\n          // Service workers don't have XHR\n          xhr = null;\n        }\n\n        return xhr;\n      }\n\n      function checkTypeSupport(type) {\n        var xhr = getXHR();\n        if (!xhr) return false;\n\n        try {\n          xhr.responseType = type;\n          return xhr.responseType === type;\n        } catch (e) {}\n\n        return false;\n      } // For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.\n      // Safari 7.1 appears to have fixed this bug.\n\n\n      var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined';\n      var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice); // If fetch is supported, then arraybuffer will be supported too. Skip calling\n      // checkTypeSupport(), since that calls getXHR().\n\n      exports.arraybuffer = exports.fetch || haveArrayBuffer && checkTypeSupport('arraybuffer'); // These next two tests unavoidably show warnings in Chrome. Since fetch will always\n      // be used if it's available, just return false for these to avoid the warnings.\n\n      exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream');\n      exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer && checkTypeSupport('moz-chunked-arraybuffer'); // If fetch is supported, then overrideMimeType will be supported too. Skip calling\n      // getXHR().\n\n      exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false);\n      exports.vbArray = isFunction(global.VBArray);\n\n      function isFunction(value) {\n        return typeof value === 'function';\n      }\n\n      xhr = null; // Help gc\n    }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n  }, {}],\n  45: [function (require, module, exports) {\n    (function (process, global, Buffer) {\n      var capability = require('./capability');\n\n      var inherits = require('inherits');\n\n      var response = require('./response');\n\n      var stream = require('readable-stream');\n\n      var toArrayBuffer = require('to-arraybuffer');\n\n      var IncomingMessage = response.IncomingMessage;\n      var rStates = response.readyStates;\n\n      function decideMode(preferBinary, useFetch) {\n        if (capability.fetch && useFetch) {\n          return 'fetch';\n        } else if (capability.mozchunkedarraybuffer) {\n          return 'moz-chunked-arraybuffer';\n        } else if (capability.msstream) {\n          return 'ms-stream';\n        } else if (capability.arraybuffer && preferBinary) {\n          return 'arraybuffer';\n        } else if (capability.vbArray && preferBinary) {\n          return 'text:vbarray';\n        } else {\n          return 'text';\n        }\n      }\n\n      var ClientRequest = module.exports = function (opts) {\n        var self = this;\n        stream.Writable.call(self);\n        self._opts = opts;\n        self._body = [];\n        self._headers = {};\n        if (opts.auth) self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'));\n        Object.keys(opts.headers).forEach(function (name) {\n          self.setHeader(name, opts.headers[name]);\n        });\n        var preferBinary;\n        var useFetch = true;\n\n        if (opts.mode === 'disable-fetch' || 'requestTimeout' in opts && !capability.abortController) {\n          // If the use of XHR should be preferred. Not typically needed.\n          useFetch = false;\n          preferBinary = true;\n        } else if (opts.mode === 'prefer-streaming') {\n          // If streaming is a high priority but binary compatibility and\n          // the accuracy of the 'content-type' header aren't\n          preferBinary = false;\n        } else if (opts.mode === 'allow-wrong-content-type') {\n          // If streaming is more important than preserving the 'content-type' header\n          preferBinary = !capability.overrideMimeType;\n        } else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {\n          // Use binary if text streaming may corrupt data or the content-type header, or for speed\n          preferBinary = true;\n        } else {\n          throw new Error('Invalid value for opts.mode');\n        }\n\n        self._mode = decideMode(preferBinary, useFetch);\n        self.on('finish', function () {\n          self._onFinish();\n        });\n      };\n\n      inherits(ClientRequest, stream.Writable);\n\n      ClientRequest.prototype.setHeader = function (name, value) {\n        var self = this;\n        var lowerName = name.toLowerCase(); // This check is not necessary, but it prevents warnings from browsers about setting unsafe\n        // headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but\n        // http-browserify did it, so I will too.\n\n        if (unsafeHeaders.indexOf(lowerName) !== -1) return;\n        self._headers[lowerName] = {\n          name: name,\n          value: value\n        };\n      };\n\n      ClientRequest.prototype.getHeader = function (name) {\n        var header = this._headers[name.toLowerCase()];\n\n        if (header) return header.value;\n        return null;\n      };\n\n      ClientRequest.prototype.removeHeader = function (name) {\n        var self = this;\n        delete self._headers[name.toLowerCase()];\n      };\n\n      ClientRequest.prototype._onFinish = function () {\n        var self = this;\n        if (self._destroyed) return;\n        var opts = self._opts;\n        var headersObj = self._headers;\n        var body = null;\n\n        if (opts.method !== 'GET' && opts.method !== 'HEAD') {\n          if (capability.arraybuffer) {\n            body = toArrayBuffer(Buffer.concat(self._body));\n          } else if (capability.blobConstructor) {\n            body = new global.Blob(self._body.map(function (buffer) {\n              return toArrayBuffer(buffer);\n            }), {\n              type: (headersObj['content-type'] || {}).value || ''\n            });\n          } else {\n            // get utf8 string\n            body = Buffer.concat(self._body).toString();\n          }\n        } // create flattened list of headers\n\n\n        var headersList = [];\n        Object.keys(headersObj).forEach(function (keyName) {\n          var name = headersObj[keyName].name;\n          var value = headersObj[keyName].value;\n\n          if (Array.isArray(value)) {\n            value.forEach(function (v) {\n              headersList.push([name, v]);\n            });\n          } else {\n            headersList.push([name, value]);\n          }\n        });\n\n        if (self._mode === 'fetch') {\n          var signal = null;\n\n          if (capability.abortController) {\n            var controller = new AbortController();\n            signal = controller.signal;\n            self._fetchAbortController = controller;\n\n            if ('requestTimeout' in opts && opts.requestTimeout !== 0) {\n              global.setTimeout(function () {\n                self.emit('requestTimeout');\n                if (self._fetchAbortController) self._fetchAbortController.abort();\n              }, opts.requestTimeout);\n            }\n          }\n\n          global.fetch(self._opts.url, {\n            method: self._opts.method,\n            headers: headersList,\n            body: body || undefined,\n            mode: 'cors',\n            credentials: opts.withCredentials ? 'include' : 'same-origin',\n            signal: signal\n          }).then(function (response) {\n            self._fetchResponse = response;\n\n            self._connect();\n          }, function (reason) {\n            self.emit('error', reason);\n          });\n        } else {\n          var xhr = self._xhr = new global.XMLHttpRequest();\n\n          try {\n            xhr.open(self._opts.method, self._opts.url, true);\n          } catch (err) {\n            process.nextTick(function () {\n              self.emit('error', err);\n            });\n            return;\n          } // Can't set responseType on really old browsers\n\n\n          if ('responseType' in xhr) xhr.responseType = self._mode.split(':')[0];\n          if ('withCredentials' in xhr) xhr.withCredentials = !!opts.withCredentials;\n          if (self._mode === 'text' && 'overrideMimeType' in xhr) xhr.overrideMimeType('text/plain; charset=x-user-defined');\n\n          if ('requestTimeout' in opts) {\n            xhr.timeout = opts.requestTimeout;\n\n            xhr.ontimeout = function () {\n              self.emit('requestTimeout');\n            };\n          }\n\n          headersList.forEach(function (header) {\n            xhr.setRequestHeader(header[0], header[1]);\n          });\n          self._response = null;\n\n          xhr.onreadystatechange = function () {\n            switch (xhr.readyState) {\n              case rStates.LOADING:\n              case rStates.DONE:\n                self._onXHRProgress();\n\n                break;\n            }\n          }; // Necessary for streaming in Firefox, since xhr.response is ONLY defined\n          // in onprogress, not in onreadystatechange with xhr.readyState = 3\n\n\n          if (self._mode === 'moz-chunked-arraybuffer') {\n            xhr.onprogress = function () {\n              self._onXHRProgress();\n            };\n          }\n\n          xhr.onerror = function () {\n            if (self._destroyed) return;\n            self.emit('error', new Error('XHR error'));\n          };\n\n          try {\n            xhr.send(body);\n          } catch (err) {\n            process.nextTick(function () {\n              self.emit('error', err);\n            });\n            return;\n          }\n        }\n      };\n      /**\n       * Checks if xhr.status is readable and non-zero, indicating no error.\n       * Even though the spec says it should be available in readyState 3,\n       * accessing it throws an exception in IE8\n       */\n\n\n      function statusValid(xhr) {\n        try {\n          var status = xhr.status;\n          return status !== null && status !== 0;\n        } catch (e) {\n          return false;\n        }\n      }\n\n      ClientRequest.prototype._onXHRProgress = function () {\n        var self = this;\n        if (!statusValid(self._xhr) || self._destroyed) return;\n        if (!self._response) self._connect();\n\n        self._response._onXHRProgress();\n      };\n\n      ClientRequest.prototype._connect = function () {\n        var self = this;\n        if (self._destroyed) return;\n        self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode);\n\n        self._response.on('error', function (err) {\n          self.emit('error', err);\n        });\n\n        self.emit('response', self._response);\n      };\n\n      ClientRequest.prototype._write = function (chunk, encoding, cb) {\n        var self = this;\n\n        self._body.push(chunk);\n\n        cb();\n      };\n\n      ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {\n        var self = this;\n        self._destroyed = true;\n        if (self._response) self._response._destroyed = true;\n        if (self._xhr) self._xhr.abort();else if (self._fetchAbortController) self._fetchAbortController.abort();\n      };\n\n      ClientRequest.prototype.end = function (data, encoding, cb) {\n        var self = this;\n\n        if (typeof data === 'function') {\n          cb = data;\n          data = undefined;\n        }\n\n        stream.Writable.prototype.end.call(self, data, encoding, cb);\n      };\n\n      ClientRequest.prototype.flushHeaders = function () {};\n\n      ClientRequest.prototype.setTimeout = function () {};\n\n      ClientRequest.prototype.setNoDelay = function () {};\n\n      ClientRequest.prototype.setSocketKeepAlive = function () {}; // Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method\n\n\n      var unsafeHeaders = ['accept-charset', 'accept-encoding', 'access-control-request-headers', 'access-control-request-method', 'connection', 'content-length', 'cookie', 'cookie2', 'date', 'dnt', 'expect', 'host', 'keep-alive', 'origin', 'referer', 'te', 'trailer', 'transfer-encoding', 'upgrade', 'user-agent', 'via'];\n    }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer);\n  }, {\n    \"./capability\": 44,\n    \"./response\": 46,\n    \"_process\": 19,\n    \"buffer\": 6,\n    \"inherits\": 13,\n    \"readable-stream\": 34,\n    \"to-arraybuffer\": 48\n  }],\n  46: [function (require, module, exports) {\n    (function (process, global, Buffer) {\n      var capability = require('./capability');\n\n      var inherits = require('inherits');\n\n      var stream = require('readable-stream');\n\n      var rStates = exports.readyStates = {\n        UNSENT: 0,\n        OPENED: 1,\n        HEADERS_RECEIVED: 2,\n        LOADING: 3,\n        DONE: 4\n      };\n\n      var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode) {\n        var self = this;\n        stream.Readable.call(self);\n        self._mode = mode;\n        self.headers = {};\n        self.rawHeaders = [];\n        self.trailers = {};\n        self.rawTrailers = []; // Fake the 'close' event, but only once 'end' fires\n\n        self.on('end', function () {\n          // The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n          process.nextTick(function () {\n            self.emit('close');\n          });\n        });\n\n        if (mode === 'fetch') {\n          self._fetchResponse = response;\n          self.url = response.url;\n          self.statusCode = response.status;\n          self.statusMessage = response.statusText;\n          response.headers.forEach(function (header, key) {\n            self.headers[key.toLowerCase()] = header;\n            self.rawHeaders.push(key, header);\n          });\n\n          if (capability.writableStream) {\n            var writable = new WritableStream({\n              write: function (chunk) {\n                return new Promise(function (resolve, reject) {\n                  if (self._destroyed) {\n                    return;\n                  } else if (self.push(new Buffer(chunk))) {\n                    resolve();\n                  } else {\n                    self._resumeFetch = resolve;\n                  }\n                });\n              },\n              close: function () {\n                if (!self._destroyed) self.push(null);\n              },\n              abort: function (err) {\n                if (!self._destroyed) self.emit('error', err);\n              }\n            });\n\n            try {\n              response.body.pipeTo(writable);\n              return;\n            } catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this\n\n          } // fallback for when writableStream or pipeTo aren't available\n\n\n          var reader = response.body.getReader();\n\n          function read() {\n            reader.read().then(function (result) {\n              if (self._destroyed) return;\n\n              if (result.done) {\n                self.push(null);\n                return;\n              }\n\n              self.push(new Buffer(result.value));\n              read();\n            }).catch(function (err) {\n              if (!self._destroyed) self.emit('error', err);\n            });\n          }\n\n          read();\n        } else {\n          self._xhr = xhr;\n          self._pos = 0;\n          self.url = xhr.responseURL;\n          self.statusCode = xhr.status;\n          self.statusMessage = xhr.statusText;\n          var headers = xhr.getAllResponseHeaders().split(/\\r?\\n/);\n          headers.forEach(function (header) {\n            var matches = header.match(/^([^:]+):\\s*(.*)/);\n\n            if (matches) {\n              var key = matches[1].toLowerCase();\n\n              if (key === 'set-cookie') {\n                if (self.headers[key] === undefined) {\n                  self.headers[key] = [];\n                }\n\n                self.headers[key].push(matches[2]);\n              } else if (self.headers[key] !== undefined) {\n                self.headers[key] += ', ' + matches[2];\n              } else {\n                self.headers[key] = matches[2];\n              }\n\n              self.rawHeaders.push(matches[1], matches[2]);\n            }\n          });\n          self._charset = 'x-user-defined';\n\n          if (!capability.overrideMimeType) {\n            var mimeType = self.rawHeaders['mime-type'];\n\n            if (mimeType) {\n              var charsetMatch = mimeType.match(/;\\s*charset=([^;])(;|$)/);\n\n              if (charsetMatch) {\n                self._charset = charsetMatch[1].toLowerCase();\n              }\n            }\n\n            if (!self._charset) self._charset = 'utf-8'; // best guess\n          }\n        }\n      };\n\n      inherits(IncomingMessage, stream.Readable);\n\n      IncomingMessage.prototype._read = function () {\n        var self = this;\n        var resolve = self._resumeFetch;\n\n        if (resolve) {\n          self._resumeFetch = null;\n          resolve();\n        }\n      };\n\n      IncomingMessage.prototype._onXHRProgress = function () {\n        var self = this;\n        var xhr = self._xhr;\n        var response = null;\n\n        switch (self._mode) {\n          case 'text:vbarray':\n            // For IE9\n            if (xhr.readyState !== rStates.DONE) break;\n\n            try {\n              // This fails in IE8\n              response = new global.VBArray(xhr.responseBody).toArray();\n            } catch (e) {}\n\n            if (response !== null) {\n              self.push(new Buffer(response));\n              break;\n            }\n\n          // Falls through in IE8\t\n\n          case 'text':\n            try {\n              // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4\n              response = xhr.responseText;\n            } catch (e) {\n              self._mode = 'text:vbarray';\n              break;\n            }\n\n            if (response.length > self._pos) {\n              var newData = response.substr(self._pos);\n\n              if (self._charset === 'x-user-defined') {\n                var buffer = new Buffer(newData.length);\n\n                for (var i = 0; i < newData.length; i++) buffer[i] = newData.charCodeAt(i) & 0xff;\n\n                self.push(buffer);\n              } else {\n                self.push(newData, self._charset);\n              }\n\n              self._pos = response.length;\n            }\n\n            break;\n\n          case 'arraybuffer':\n            if (xhr.readyState !== rStates.DONE || !xhr.response) break;\n            response = xhr.response;\n            self.push(new Buffer(new Uint8Array(response)));\n            break;\n\n          case 'moz-chunked-arraybuffer':\n            // take whole\n            response = xhr.response;\n            if (xhr.readyState !== rStates.LOADING || !response) break;\n            self.push(new Buffer(new Uint8Array(response)));\n            break;\n\n          case 'ms-stream':\n            response = xhr.response;\n            if (xhr.readyState !== rStates.LOADING) break;\n            var reader = new global.MSStreamReader();\n\n            reader.onprogress = function () {\n              if (reader.result.byteLength > self._pos) {\n                self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))));\n                self._pos = reader.result.byteLength;\n              }\n            };\n\n            reader.onload = function () {\n              self.push(null);\n            }; // reader.onerror = ??? // TODO: this\n\n\n            reader.readAsArrayBuffer(response);\n            break;\n        } // The ms-stream case handles end separately in reader.onload()\n\n\n        if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {\n          self.push(null);\n        }\n      };\n    }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer);\n  }, {\n    \"./capability\": 44,\n    \"_process\": 19,\n    \"buffer\": 6,\n    \"inherits\": 13,\n    \"readable-stream\": 34\n  }],\n  47: [function (require, module, exports) {\n    // Copyright Joyent, Inc. and other Node contributors.\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a\n    // copy of this software and associated documentation files (the\n    // \"Software\"), to deal in the Software without restriction, including\n    // without limitation the rights to use, copy, modify, merge, publish,\n    // distribute, sublicense, and/or sell copies of the Software, and to permit\n    // persons to whom the Software is furnished to do so, subject to the\n    // following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included\n    // in all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n    // USE OR OTHER DEALINGS IN THE SOFTWARE.\n    'use strict';\n    /*<replacement>*/\n\n    var Buffer = require('safe-buffer').Buffer;\n    /*</replacement>*/\n\n\n    var isEncoding = Buffer.isEncoding || function (encoding) {\n      encoding = '' + encoding;\n\n      switch (encoding && encoding.toLowerCase()) {\n        case 'hex':\n        case 'utf8':\n        case 'utf-8':\n        case 'ascii':\n        case 'binary':\n        case 'base64':\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n        case 'raw':\n          return true;\n\n        default:\n          return false;\n      }\n    };\n\n    function _normalizeEncoding(enc) {\n      if (!enc) return 'utf8';\n      var retried;\n\n      while (true) {\n        switch (enc) {\n          case 'utf8':\n          case 'utf-8':\n            return 'utf8';\n\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            return 'utf16le';\n\n          case 'latin1':\n          case 'binary':\n            return 'latin1';\n\n          case 'base64':\n          case 'ascii':\n          case 'hex':\n            return enc;\n\n          default:\n            if (retried) return; // undefined\n\n            enc = ('' + enc).toLowerCase();\n            retried = true;\n        }\n      }\n    }\n\n    ; // Do not cache `Buffer.isEncoding` when checking encoding names as some\n    // modules monkey-patch it to support additional encodings\n\n    function normalizeEncoding(enc) {\n      var nenc = _normalizeEncoding(enc);\n\n      if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n      return nenc || enc;\n    } // StringDecoder provides an interface for efficiently splitting a series of\n    // buffers into a series of JS strings without breaking apart multi-byte\n    // characters.\n\n\n    exports.StringDecoder = StringDecoder;\n\n    function StringDecoder(encoding) {\n      this.encoding = normalizeEncoding(encoding);\n      var nb;\n\n      switch (this.encoding) {\n        case 'utf16le':\n          this.text = utf16Text;\n          this.end = utf16End;\n          nb = 4;\n          break;\n\n        case 'utf8':\n          this.fillLast = utf8FillLast;\n          nb = 4;\n          break;\n\n        case 'base64':\n          this.text = base64Text;\n          this.end = base64End;\n          nb = 3;\n          break;\n\n        default:\n          this.write = simpleWrite;\n          this.end = simpleEnd;\n          return;\n      }\n\n      this.lastNeed = 0;\n      this.lastTotal = 0;\n      this.lastChar = Buffer.allocUnsafe(nb);\n    }\n\n    StringDecoder.prototype.write = function (buf) {\n      if (buf.length === 0) return '';\n      var r;\n      var i;\n\n      if (this.lastNeed) {\n        r = this.fillLast(buf);\n        if (r === undefined) return '';\n        i = this.lastNeed;\n        this.lastNeed = 0;\n      } else {\n        i = 0;\n      }\n\n      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n      return r || '';\n    };\n\n    StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer\n\n    StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\n\n    StringDecoder.prototype.fillLast = function (buf) {\n      if (this.lastNeed <= buf.length) {\n        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n        return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n      }\n\n      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n      this.lastNeed -= buf.length;\n    }; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n    // continuation byte. If an invalid byte is detected, -2 is returned.\n\n\n    function utf8CheckByte(byte) {\n      if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n      return byte >> 6 === 0x02 ? -1 : -2;\n    } // Checks at most 3 bytes at the end of a Buffer in order to detect an\n    // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n    // needed to complete the UTF-8 character (if applicable) are returned.\n\n\n    function utf8CheckIncomplete(self, buf, i) {\n      var j = buf.length - 1;\n      if (j < i) return 0;\n      var nb = utf8CheckByte(buf[j]);\n\n      if (nb >= 0) {\n        if (nb > 0) self.lastNeed = nb - 1;\n        return nb;\n      }\n\n      if (--j < i || nb === -2) return 0;\n      nb = utf8CheckByte(buf[j]);\n\n      if (nb >= 0) {\n        if (nb > 0) self.lastNeed = nb - 2;\n        return nb;\n      }\n\n      if (--j < i || nb === -2) return 0;\n      nb = utf8CheckByte(buf[j]);\n\n      if (nb >= 0) {\n        if (nb > 0) {\n          if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n        }\n\n        return nb;\n      }\n\n      return 0;\n    } // Validates as many continuation bytes for a multi-byte UTF-8 character as\n    // needed or are available. If we see a non-continuation byte where we expect\n    // one, we \"replace\" the validated continuation bytes we've seen so far with\n    // a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n    // behavior. The continuation byte check is included three times in the case\n    // where all of the continuation bytes for a character exist in the same buffer.\n    // It is also done this way as a slight performance increase instead of using a\n    // loop.\n\n\n    function utf8CheckExtraBytes(self, buf, p) {\n      if ((buf[0] & 0xC0) !== 0x80) {\n        self.lastNeed = 0;\n        return '\\ufffd';\n      }\n\n      if (self.lastNeed > 1 && buf.length > 1) {\n        if ((buf[1] & 0xC0) !== 0x80) {\n          self.lastNeed = 1;\n          return '\\ufffd';\n        }\n\n        if (self.lastNeed > 2 && buf.length > 2) {\n          if ((buf[2] & 0xC0) !== 0x80) {\n            self.lastNeed = 2;\n            return '\\ufffd';\n          }\n        }\n      }\n    } // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\n\n\n    function utf8FillLast(buf) {\n      var p = this.lastTotal - this.lastNeed;\n      var r = utf8CheckExtraBytes(this, buf, p);\n      if (r !== undefined) return r;\n\n      if (this.lastNeed <= buf.length) {\n        buf.copy(this.lastChar, p, 0, this.lastNeed);\n        return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n      }\n\n      buf.copy(this.lastChar, p, 0, buf.length);\n      this.lastNeed -= buf.length;\n    } // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n    // partial character, the character's bytes are buffered until the required\n    // number of bytes are available.\n\n\n    function utf8Text(buf, i) {\n      var total = utf8CheckIncomplete(this, buf, i);\n      if (!this.lastNeed) return buf.toString('utf8', i);\n      this.lastTotal = total;\n      var end = buf.length - (total - this.lastNeed);\n      buf.copy(this.lastChar, 0, end);\n      return buf.toString('utf8', i, end);\n    } // For UTF-8, a replacement character is added when ending on a partial\n    // character.\n\n\n    function utf8End(buf) {\n      var r = buf && buf.length ? this.write(buf) : '';\n      if (this.lastNeed) return r + '\\ufffd';\n      return r;\n    } // UTF-16LE typically needs two bytes per character, but even if we have an even\n    // number of bytes available, we need to check if we end on a leading/high\n    // surrogate. In that case, we need to wait for the next two bytes in order to\n    // decode the last character properly.\n\n\n    function utf16Text(buf, i) {\n      if ((buf.length - i) % 2 === 0) {\n        var r = buf.toString('utf16le', i);\n\n        if (r) {\n          var c = r.charCodeAt(r.length - 1);\n\n          if (c >= 0xD800 && c <= 0xDBFF) {\n            this.lastNeed = 2;\n            this.lastTotal = 4;\n            this.lastChar[0] = buf[buf.length - 2];\n            this.lastChar[1] = buf[buf.length - 1];\n            return r.slice(0, -1);\n          }\n        }\n\n        return r;\n      }\n\n      this.lastNeed = 1;\n      this.lastTotal = 2;\n      this.lastChar[0] = buf[buf.length - 1];\n      return buf.toString('utf16le', i, buf.length - 1);\n    } // For UTF-16LE we do not explicitly append special replacement characters if we\n    // end on a partial character, we simply let v8 handle that.\n\n\n    function utf16End(buf) {\n      var r = buf && buf.length ? this.write(buf) : '';\n\n      if (this.lastNeed) {\n        var end = this.lastTotal - this.lastNeed;\n        return r + this.lastChar.toString('utf16le', 0, end);\n      }\n\n      return r;\n    }\n\n    function base64Text(buf, i) {\n      var n = (buf.length - i) % 3;\n      if (n === 0) return buf.toString('base64', i);\n      this.lastNeed = 3 - n;\n      this.lastTotal = 3;\n\n      if (n === 1) {\n        this.lastChar[0] = buf[buf.length - 1];\n      } else {\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n      }\n\n      return buf.toString('base64', i, buf.length - n);\n    }\n\n    function base64End(buf) {\n      var r = buf && buf.length ? this.write(buf) : '';\n      if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n      return r;\n    } // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\n\n\n    function simpleWrite(buf) {\n      return buf.toString(this.encoding);\n    }\n\n    function simpleEnd(buf) {\n      return buf && buf.length ? this.write(buf) : '';\n    }\n  }, {\n    \"safe-buffer\": 38\n  }],\n  48: [function (require, module, exports) {\n    var Buffer = require('buffer').Buffer;\n\n    module.exports = function (buf) {\n      // If the buffer is backed by a Uint8Array, a faster version will work\n      if (buf instanceof Uint8Array) {\n        // If the buffer isn't a subarray, return the underlying ArrayBuffer\n        if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {\n          return buf.buffer;\n        } else if (typeof buf.buffer.slice === 'function') {\n          // Otherwise we need to get a proper copy\n          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n        }\n      }\n\n      if (Buffer.isBuffer(buf)) {\n        // This is the slow version that will work with any Buffer\n        // implementation (even in old browsers)\n        var arrayCopy = new Uint8Array(buf.length);\n        var len = buf.length;\n\n        for (var i = 0; i < len; i++) {\n          arrayCopy[i] = buf[i];\n        }\n\n        return arrayCopy.buffer;\n      } else {\n        throw new Error('Argument must be a Buffer');\n      }\n    };\n  }, {\n    \"buffer\": 6\n  }],\n  49: [function (require, module, exports) {\n    // Copyright Joyent, Inc. and other Node contributors.\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a\n    // copy of this software and associated documentation files (the\n    // \"Software\"), to deal in the Software without restriction, including\n    // without limitation the rights to use, copy, modify, merge, publish,\n    // distribute, sublicense, and/or sell copies of the Software, and to permit\n    // persons to whom the Software is furnished to do so, subject to the\n    // following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included\n    // in all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n    // USE OR OTHER DEALINGS IN THE SOFTWARE.\n    'use strict';\n\n    var punycode = require('punycode');\n\n    var util = require('./util');\n\n    exports.parse = urlParse;\n    exports.resolve = urlResolve;\n    exports.resolveObject = urlResolveObject;\n    exports.format = urlFormat;\n    exports.Url = Url;\n\n    function Url() {\n      this.protocol = null;\n      this.slashes = null;\n      this.auth = null;\n      this.host = null;\n      this.port = null;\n      this.hostname = null;\n      this.hash = null;\n      this.search = null;\n      this.query = null;\n      this.pathname = null;\n      this.path = null;\n      this.href = null;\n    } // Reference: RFC 3986, RFC 1808, RFC 2396\n    // define these here so at least they only have to be\n    // compiled once on the first module load.\n\n\n    var protocolPattern = /^([a-z0-9.+-]+:)/i,\n        portPattern = /:[0-9]*$/,\n        // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n        // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n        // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n        // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n        // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n        hostEndingChars = ['/', '?', '#'],\n        hostnameMaxLen = 255,\n        hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n        hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n        // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n        // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n        // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n        querystring = require('querystring');\n\n    function urlParse(url, parseQueryString, slashesDenoteHost) {\n      if (url && util.isObject(url) && url instanceof Url) return url;\n      var u = new Url();\n      u.parse(url, parseQueryString, slashesDenoteHost);\n      return u;\n    }\n\n    Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n      if (!util.isString(url)) {\n        throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n      } // Copy chrome, IE, opera backslash-handling behavior.\n      // Back slashes before the query string get converted to forward slashes\n      // See: https://code.google.com/p/chromium/issues/detail?id=25916\n\n\n      var queryIndex = url.indexOf('?'),\n          splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',\n          uSplit = url.split(splitter),\n          slashRegex = /\\\\/g;\n      uSplit[0] = uSplit[0].replace(slashRegex, '/');\n      url = uSplit.join(splitter);\n      var rest = url; // trim before proceeding.\n      // This is to support parse stuff like \"  http://foo.com  \\n\"\n\n      rest = rest.trim();\n\n      if (!slashesDenoteHost && url.split('#').length === 1) {\n        // Try fast path regexp\n        var simplePath = simplePathPattern.exec(rest);\n\n        if (simplePath) {\n          this.path = rest;\n          this.href = rest;\n          this.pathname = simplePath[1];\n\n          if (simplePath[2]) {\n            this.search = simplePath[2];\n\n            if (parseQueryString) {\n              this.query = querystring.parse(this.search.substr(1));\n            } else {\n              this.query = this.search.substr(1);\n            }\n          } else if (parseQueryString) {\n            this.search = '';\n            this.query = {};\n          }\n\n          return this;\n        }\n      }\n\n      var proto = protocolPattern.exec(rest);\n\n      if (proto) {\n        proto = proto[0];\n        var lowerProto = proto.toLowerCase();\n        this.protocol = lowerProto;\n        rest = rest.substr(proto.length);\n      } // figure out if it's got a host\n      // user@server is *always* interpreted as a hostname, and url\n      // resolution will treat //foo/bar as host=foo,path=bar because that's\n      // how the browser resolves relative URLs.\n\n\n      if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n        var slashes = rest.substr(0, 2) === '//';\n\n        if (slashes && !(proto && hostlessProtocol[proto])) {\n          rest = rest.substr(2);\n          this.slashes = true;\n        }\n      }\n\n      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n        // there's a hostname.\n        // the first instance of /, ?, ;, or # ends the host.\n        //\n        // If there is an @ in the hostname, then non-host chars *are* allowed\n        // to the left of the last @ sign, unless some host-ending character\n        // comes *before* the @-sign.\n        // URLs are obnoxious.\n        //\n        // ex:\n        // http://a@b@c/ => user:a@b host:c\n        // http://a@b?@c => user:a host:c path:/?@c\n        // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n        // Review our test case against browsers more comprehensively.\n        // find the first instance of any hostEndingChars\n        var hostEnd = -1;\n\n        for (var i = 0; i < hostEndingChars.length; i++) {\n          var hec = rest.indexOf(hostEndingChars[i]);\n          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n        } // at this point, either we have an explicit point where the\n        // auth portion cannot go past, or the last @ char is the decider.\n\n\n        var auth, atSign;\n\n        if (hostEnd === -1) {\n          // atSign can be anywhere.\n          atSign = rest.lastIndexOf('@');\n        } else {\n          // atSign must be in auth portion.\n          // http://a@b/c@d => host:b auth:a path:/c@d\n          atSign = rest.lastIndexOf('@', hostEnd);\n        } // Now we have a portion which is definitely the auth.\n        // Pull that off.\n\n\n        if (atSign !== -1) {\n          auth = rest.slice(0, atSign);\n          rest = rest.slice(atSign + 1);\n          this.auth = decodeURIComponent(auth);\n        } // the host is the remaining to the left of the first non-host char\n\n\n        hostEnd = -1;\n\n        for (var i = 0; i < nonHostChars.length; i++) {\n          var hec = rest.indexOf(nonHostChars[i]);\n          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n        } // if we still have not hit it, then the entire thing is a host.\n\n\n        if (hostEnd === -1) hostEnd = rest.length;\n        this.host = rest.slice(0, hostEnd);\n        rest = rest.slice(hostEnd); // pull out port.\n\n        this.parseHost(); // we've indicated that there is a hostname,\n        // so even if it's empty, it has to be present.\n\n        this.hostname = this.hostname || ''; // if hostname begins with [ and ends with ]\n        // assume that it's an IPv6 address.\n\n        var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'; // validate a little.\n\n        if (!ipv6Hostname) {\n          var hostparts = this.hostname.split(/\\./);\n\n          for (var i = 0, l = hostparts.length; i < l; i++) {\n            var part = hostparts[i];\n            if (!part) continue;\n\n            if (!part.match(hostnamePartPattern)) {\n              var newpart = '';\n\n              for (var j = 0, k = part.length; j < k; j++) {\n                if (part.charCodeAt(j) > 127) {\n                  // we replace non-ASCII char with a temporary placeholder\n                  // we need this to make sure size of hostname is not\n                  // broken by replacing non-ASCII by nothing\n                  newpart += 'x';\n                } else {\n                  newpart += part[j];\n                }\n              } // we test again with ASCII char only\n\n\n              if (!newpart.match(hostnamePartPattern)) {\n                var validParts = hostparts.slice(0, i);\n                var notHost = hostparts.slice(i + 1);\n                var bit = part.match(hostnamePartStart);\n\n                if (bit) {\n                  validParts.push(bit[1]);\n                  notHost.unshift(bit[2]);\n                }\n\n                if (notHost.length) {\n                  rest = '/' + notHost.join('.') + rest;\n                }\n\n                this.hostname = validParts.join('.');\n                break;\n              }\n            }\n          }\n        }\n\n        if (this.hostname.length > hostnameMaxLen) {\n          this.hostname = '';\n        } else {\n          // hostnames are always lower case.\n          this.hostname = this.hostname.toLowerCase();\n        }\n\n        if (!ipv6Hostname) {\n          // IDNA Support: Returns a punycoded representation of \"domain\".\n          // It only converts parts of the domain name that\n          // have non-ASCII characters, i.e. it doesn't matter if\n          // you call it with a domain that already is ASCII-only.\n          this.hostname = punycode.toASCII(this.hostname);\n        }\n\n        var p = this.port ? ':' + this.port : '';\n        var h = this.hostname || '';\n        this.host = h + p;\n        this.href += this.host; // strip [ and ] from the hostname\n        // the host field still retains them, though\n\n        if (ipv6Hostname) {\n          this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n\n          if (rest[0] !== '/') {\n            rest = '/' + rest;\n          }\n        }\n      } // now rest is set to the post-host stuff.\n      // chop off any delim chars.\n\n\n      if (!unsafeProtocol[lowerProto]) {\n        // First, make 100% sure that any \"autoEscape\" chars get\n        // escaped, even if encodeURIComponent doesn't think they\n        // need to be.\n        for (var i = 0, l = autoEscape.length; i < l; i++) {\n          var ae = autoEscape[i];\n          if (rest.indexOf(ae) === -1) continue;\n          var esc = encodeURIComponent(ae);\n\n          if (esc === ae) {\n            esc = escape(ae);\n          }\n\n          rest = rest.split(ae).join(esc);\n        }\n      } // chop off from the tail first.\n\n\n      var hash = rest.indexOf('#');\n\n      if (hash !== -1) {\n        // got a fragment string.\n        this.hash = rest.substr(hash);\n        rest = rest.slice(0, hash);\n      }\n\n      var qm = rest.indexOf('?');\n\n      if (qm !== -1) {\n        this.search = rest.substr(qm);\n        this.query = rest.substr(qm + 1);\n\n        if (parseQueryString) {\n          this.query = querystring.parse(this.query);\n        }\n\n        rest = rest.slice(0, qm);\n      } else if (parseQueryString) {\n        // no query string, but parseQueryString still requested\n        this.search = '';\n        this.query = {};\n      }\n\n      if (rest) this.pathname = rest;\n\n      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n        this.pathname = '/';\n      } //to support http.request\n\n\n      if (this.pathname || this.search) {\n        var p = this.pathname || '';\n        var s = this.search || '';\n        this.path = p + s;\n      } // finally, reconstruct the href based on what has been validated.\n\n\n      this.href = this.format();\n      return this;\n    }; // format a parsed object into a url string\n\n\n    function urlFormat(obj) {\n      // ensure it's an object, and not a string url.\n      // If it's an obj, this is a no-op.\n      // this way, you can call url_format() on strings\n      // to clean up potentially wonky urls.\n      if (util.isString(obj)) obj = urlParse(obj);\n      if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n      return obj.format();\n    }\n\n    Url.prototype.format = function () {\n      var auth = this.auth || '';\n\n      if (auth) {\n        auth = encodeURIComponent(auth);\n        auth = auth.replace(/%3A/i, ':');\n        auth += '@';\n      }\n\n      var protocol = this.protocol || '',\n          pathname = this.pathname || '',\n          hash = this.hash || '',\n          host = false,\n          query = '';\n\n      if (this.host) {\n        host = auth + this.host;\n      } else if (this.hostname) {\n        host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');\n\n        if (this.port) {\n          host += ':' + this.port;\n        }\n      }\n\n      if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {\n        query = querystring.stringify(this.query);\n      }\n\n      var search = this.search || query && '?' + query || '';\n      if (protocol && protocol.substr(-1) !== ':') protocol += ':'; // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n      // unless they had them to begin with.\n\n      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\n        host = '//' + (host || '');\n        if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n      } else if (!host) {\n        host = '';\n      }\n\n      if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n      if (search && search.charAt(0) !== '?') search = '?' + search;\n      pathname = pathname.replace(/[?#]/g, function (match) {\n        return encodeURIComponent(match);\n      });\n      search = search.replace('#', '%23');\n      return protocol + host + pathname + search + hash;\n    };\n\n    function urlResolve(source, relative) {\n      return urlParse(source, false, true).resolve(relative);\n    }\n\n    Url.prototype.resolve = function (relative) {\n      return this.resolveObject(urlParse(relative, false, true)).format();\n    };\n\n    function urlResolveObject(source, relative) {\n      if (!source) return relative;\n      return urlParse(source, false, true).resolveObject(relative);\n    }\n\n    Url.prototype.resolveObject = function (relative) {\n      if (util.isString(relative)) {\n        var rel = new Url();\n        rel.parse(relative, false, true);\n        relative = rel;\n      }\n\n      var result = new Url();\n      var tkeys = Object.keys(this);\n\n      for (var tk = 0; tk < tkeys.length; tk++) {\n        var tkey = tkeys[tk];\n        result[tkey] = this[tkey];\n      } // hash is always overridden, no matter what.\n      // even href=\"\" will remove it.\n\n\n      result.hash = relative.hash; // if the relative url is empty, then there's nothing left to do here.\n\n      if (relative.href === '') {\n        result.href = result.format();\n        return result;\n      } // hrefs like //foo/bar always cut to the protocol.\n\n\n      if (relative.slashes && !relative.protocol) {\n        // take everything except the protocol from relative\n        var rkeys = Object.keys(relative);\n\n        for (var rk = 0; rk < rkeys.length; rk++) {\n          var rkey = rkeys[rk];\n          if (rkey !== 'protocol') result[rkey] = relative[rkey];\n        } //urlParse appends trailing / to urls like http://www.example.com\n\n\n        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\n          result.path = result.pathname = '/';\n        }\n\n        result.href = result.format();\n        return result;\n      }\n\n      if (relative.protocol && relative.protocol !== result.protocol) {\n        // if it's a known url protocol, then changing\n        // the protocol does weird things\n        // first, if it's not file:, then we MUST have a host,\n        // and if there was a path\n        // to begin with, then we MUST have a path.\n        // if it is file:, then the host is dropped,\n        // because that's known to be hostless.\n        // anything else is assumed to be absolute.\n        if (!slashedProtocol[relative.protocol]) {\n          var keys = Object.keys(relative);\n\n          for (var v = 0; v < keys.length; v++) {\n            var k = keys[v];\n            result[k] = relative[k];\n          }\n\n          result.href = result.format();\n          return result;\n        }\n\n        result.protocol = relative.protocol;\n\n        if (!relative.host && !hostlessProtocol[relative.protocol]) {\n          var relPath = (relative.pathname || '').split('/');\n\n          while (relPath.length && !(relative.host = relPath.shift()));\n\n          if (!relative.host) relative.host = '';\n          if (!relative.hostname) relative.hostname = '';\n          if (relPath[0] !== '') relPath.unshift('');\n          if (relPath.length < 2) relPath.unshift('');\n          result.pathname = relPath.join('/');\n        } else {\n          result.pathname = relative.pathname;\n        }\n\n        result.search = relative.search;\n        result.query = relative.query;\n        result.host = relative.host || '';\n        result.auth = relative.auth;\n        result.hostname = relative.hostname || relative.host;\n        result.port = relative.port; // to support http.request\n\n        if (result.pathname || result.search) {\n          var p = result.pathname || '';\n          var s = result.search || '';\n          result.path = p + s;\n        }\n\n        result.slashes = result.slashes || relative.slashes;\n        result.href = result.format();\n        return result;\n      }\n\n      var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',\n          isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',\n          mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,\n          removeAllDots = mustEndAbs,\n          srcPath = result.pathname && result.pathname.split('/') || [],\n          relPath = relative.pathname && relative.pathname.split('/') || [],\n          psychotic = result.protocol && !slashedProtocol[result.protocol]; // if the url is a non-slashed url, then relative\n      // links like ../.. should be able\n      // to crawl up to the hostname, as well.  This is strange.\n      // result.protocol has already been set by now.\n      // Later on, put the first path part into the host field.\n\n      if (psychotic) {\n        result.hostname = '';\n        result.port = null;\n\n        if (result.host) {\n          if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);\n        }\n\n        result.host = '';\n\n        if (relative.protocol) {\n          relative.hostname = null;\n          relative.port = null;\n\n          if (relative.host) {\n            if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);\n          }\n\n          relative.host = null;\n        }\n\n        mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n      }\n\n      if (isRelAbs) {\n        // it's absolute.\n        result.host = relative.host || relative.host === '' ? relative.host : result.host;\n        result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;\n        result.search = relative.search;\n        result.query = relative.query;\n        srcPath = relPath; // fall through to the dot-handling below.\n      } else if (relPath.length) {\n        // it's relative\n        // throw away the existing file, and take the new path instead.\n        if (!srcPath) srcPath = [];\n        srcPath.pop();\n        srcPath = srcPath.concat(relPath);\n        result.search = relative.search;\n        result.query = relative.query;\n      } else if (!util.isNullOrUndefined(relative.search)) {\n        // just pull out the search.\n        // like href='?foo'.\n        // Put this after the other two cases because it simplifies the booleans\n        if (psychotic) {\n          result.hostname = result.host = srcPath.shift(); //occationaly the auth can get stuck only in host\n          //this especially happens in cases like\n          //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n\n          var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n\n          if (authInHost) {\n            result.auth = authInHost.shift();\n            result.host = result.hostname = authInHost.shift();\n          }\n        }\n\n        result.search = relative.search;\n        result.query = relative.query; //to support http.request\n\n        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n          result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n        }\n\n        result.href = result.format();\n        return result;\n      }\n\n      if (!srcPath.length) {\n        // no path at all.  easy.\n        // we've already handled the other stuff above.\n        result.pathname = null; //to support http.request\n\n        if (result.search) {\n          result.path = '/' + result.search;\n        } else {\n          result.path = null;\n        }\n\n        result.href = result.format();\n        return result;\n      } // if a url ENDs in . or .., then it must get a trailing slash.\n      // however, if it ends in anything else non-slashy,\n      // then it must NOT get a trailing slash.\n\n\n      var last = srcPath.slice(-1)[0];\n      var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === ''; // strip single dots, resolve double dots to parent dir\n      // if the path tries to go above the root, `up` ends up > 0\n\n      var up = 0;\n\n      for (var i = srcPath.length; i >= 0; i--) {\n        last = srcPath[i];\n\n        if (last === '.') {\n          srcPath.splice(i, 1);\n        } else if (last === '..') {\n          srcPath.splice(i, 1);\n          up++;\n        } else if (up) {\n          srcPath.splice(i, 1);\n          up--;\n        }\n      } // if the path is allowed to go above the root, restore leading ..s\n\n\n      if (!mustEndAbs && !removeAllDots) {\n        for (; up--; up) {\n          srcPath.unshift('..');\n        }\n      }\n\n      if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n        srcPath.unshift('');\n      }\n\n      if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {\n        srcPath.push('');\n      }\n\n      var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/'; // put the host back\n\n      if (psychotic) {\n        result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : ''; //occationaly the auth can get stuck only in host\n        //this especially happens in cases like\n        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n\n        var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n\n        if (authInHost) {\n          result.auth = authInHost.shift();\n          result.host = result.hostname = authInHost.shift();\n        }\n      }\n\n      mustEndAbs = mustEndAbs || result.host && srcPath.length;\n\n      if (mustEndAbs && !isAbsolute) {\n        srcPath.unshift('');\n      }\n\n      if (!srcPath.length) {\n        result.pathname = null;\n        result.path = null;\n      } else {\n        result.pathname = srcPath.join('/');\n      } //to support request.http\n\n\n      if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n        result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n      }\n\n      result.auth = relative.auth || result.auth;\n      result.slashes = result.slashes || relative.slashes;\n      result.href = result.format();\n      return result;\n    };\n\n    Url.prototype.parseHost = function () {\n      var host = this.host;\n      var port = portPattern.exec(host);\n\n      if (port) {\n        port = port[0];\n\n        if (port !== ':') {\n          this.port = port.substr(1);\n        }\n\n        host = host.substr(0, host.length - port.length);\n      }\n\n      if (host) this.hostname = host;\n    };\n  }, {\n    \"./util\": 50,\n    \"punycode\": 20,\n    \"querystring\": 23\n  }],\n  50: [function (require, module, exports) {\n    'use strict';\n\n    module.exports = {\n      isString: function (arg) {\n        return typeof arg === 'string';\n      },\n      isObject: function (arg) {\n        return typeof arg === 'object' && arg !== null;\n      },\n      isNull: function (arg) {\n        return arg === null;\n      },\n      isNullOrUndefined: function (arg) {\n        return arg == null;\n      }\n    };\n  }, {}],\n  51: [function (require, module, exports) {\n    (function (global) {\n      /**\n       * Module exports.\n       */\n      module.exports = deprecate;\n      /**\n       * Mark that a method should not be used.\n       * Returns a modified function which warns once by default.\n       *\n       * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n       *\n       * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n       * will throw an Error when invoked.\n       *\n       * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n       * will invoke `console.trace()` instead of `console.error()`.\n       *\n       * @param {Function} fn - the function to deprecate\n       * @param {String} msg - the string to print to the console when `fn` is invoked\n       * @returns {Function} a new \"deprecated\" version of `fn`\n       * @api public\n       */\n\n      function deprecate(fn, msg) {\n        if (config('noDeprecation')) {\n          return fn;\n        }\n\n        var warned = false;\n\n        function deprecated() {\n          if (!warned) {\n            if (config('throwDeprecation')) {\n              throw new Error(msg);\n            } else if (config('traceDeprecation')) {\n              console.trace(msg);\n            } else {\n              console.warn(msg);\n            }\n\n            warned = true;\n          }\n\n          return fn.apply(this, arguments);\n        }\n\n        return deprecated;\n      }\n      /**\n       * Checks `localStorage` for boolean values for the given `name`.\n       *\n       * @param {String} name\n       * @returns {Boolean}\n       * @api private\n       */\n\n\n      function config(name) {\n        // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n        try {\n          if (!global.localStorage) return false;\n        } catch (_) {\n          return false;\n        }\n\n        var val = global.localStorage[name];\n        if (null == val) return false;\n        return String(val).toLowerCase() === 'true';\n      }\n    }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n  }, {}],\n  52: [function (require, module, exports) {\n    arguments[4][13][0].apply(exports, arguments);\n  }, {\n    \"dup\": 13\n  }],\n  53: [function (require, module, exports) {\n    module.exports = function isBuffer(arg) {\n      return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';\n    };\n  }, {}],\n  54: [function (require, module, exports) {\n    (function (process, global) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      var formatRegExp = /%[sdj%]/g;\n\n      exports.format = function (f) {\n        if (!isString(f)) {\n          var objects = [];\n\n          for (var i = 0; i < arguments.length; i++) {\n            objects.push(inspect(arguments[i]));\n          }\n\n          return objects.join(' ');\n        }\n\n        var i = 1;\n        var args = arguments;\n        var len = args.length;\n        var str = String(f).replace(formatRegExp, function (x) {\n          if (x === '%%') return '%';\n          if (i >= len) return x;\n\n          switch (x) {\n            case '%s':\n              return String(args[i++]);\n\n            case '%d':\n              return Number(args[i++]);\n\n            case '%j':\n              try {\n                return JSON.stringify(args[i++]);\n              } catch (_) {\n                return '[Circular]';\n              }\n\n            default:\n              return x;\n          }\n        });\n\n        for (var x = args[i]; i < len; x = args[++i]) {\n          if (isNull(x) || !isObject(x)) {\n            str += ' ' + x;\n          } else {\n            str += ' ' + inspect(x);\n          }\n        }\n\n        return str;\n      }; // Mark that a method should not be used.\n      // Returns a modified function which warns once by default.\n      // If --no-deprecation is set, then it is a no-op.\n\n\n      exports.deprecate = function (fn, msg) {\n        // Allow for deprecating things in the process of starting up.\n        if (isUndefined(global.process)) {\n          return function () {\n            return exports.deprecate(fn, msg).apply(this, arguments);\n          };\n        }\n\n        if (process.noDeprecation === true) {\n          return fn;\n        }\n\n        var warned = false;\n\n        function deprecated() {\n          if (!warned) {\n            if (process.throwDeprecation) {\n              throw new Error(msg);\n            } else if (process.traceDeprecation) {\n              console.trace(msg);\n            } else {\n              console.error(msg);\n            }\n\n            warned = true;\n          }\n\n          return fn.apply(this, arguments);\n        }\n\n        return deprecated;\n      };\n\n      var debugs = {};\n      var debugEnviron;\n\n      exports.debuglog = function (set) {\n        if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';\n        set = set.toUpperCase();\n\n        if (!debugs[set]) {\n          if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n            var pid = process.pid;\n\n            debugs[set] = function () {\n              var msg = exports.format.apply(exports, arguments);\n              console.error('%s %d: %s', set, pid, msg);\n            };\n          } else {\n            debugs[set] = function () {};\n          }\n        }\n\n        return debugs[set];\n      };\n      /**\n       * Echos the value of a value. Trys to print the value out\n       * in the best way possible given the different types.\n       *\n       * @param {Object} obj The object to print out.\n       * @param {Object} opts Optional options object that alters the output.\n       */\n\n      /* legacy: obj, showHidden, depth, colors*/\n\n\n      function inspect(obj, opts) {\n        // default options\n        var ctx = {\n          seen: [],\n          stylize: stylizeNoColor\n        }; // legacy...\n\n        if (arguments.length >= 3) ctx.depth = arguments[2];\n        if (arguments.length >= 4) ctx.colors = arguments[3];\n\n        if (isBoolean(opts)) {\n          // legacy...\n          ctx.showHidden = opts;\n        } else if (opts) {\n          // got an \"options\" object\n          exports._extend(ctx, opts);\n        } // set default options\n\n\n        if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n        if (isUndefined(ctx.depth)) ctx.depth = 2;\n        if (isUndefined(ctx.colors)) ctx.colors = false;\n        if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n        if (ctx.colors) ctx.stylize = stylizeWithColor;\n        return formatValue(ctx, obj, ctx.depth);\n      }\n\n      exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n\n      inspect.colors = {\n        'bold': [1, 22],\n        'italic': [3, 23],\n        'underline': [4, 24],\n        'inverse': [7, 27],\n        'white': [37, 39],\n        'grey': [90, 39],\n        'black': [30, 39],\n        'blue': [34, 39],\n        'cyan': [36, 39],\n        'green': [32, 39],\n        'magenta': [35, 39],\n        'red': [31, 39],\n        'yellow': [33, 39]\n      }; // Don't use 'blue' not visible on cmd.exe\n\n      inspect.styles = {\n        'special': 'cyan',\n        'number': 'yellow',\n        'boolean': 'yellow',\n        'undefined': 'grey',\n        'null': 'bold',\n        'string': 'green',\n        'date': 'magenta',\n        // \"name\": intentionally not styling\n        'regexp': 'red'\n      };\n\n      function stylizeWithColor(str, styleType) {\n        var style = inspect.styles[styleType];\n\n        if (style) {\n          return '\\u001b[' + inspect.colors[style][0] + 'm' + str + '\\u001b[' + inspect.colors[style][1] + 'm';\n        } else {\n          return str;\n        }\n      }\n\n      function stylizeNoColor(str, styleType) {\n        return str;\n      }\n\n      function arrayToHash(array) {\n        var hash = {};\n        array.forEach(function (val, idx) {\n          hash[val] = true;\n        });\n        return hash;\n      }\n\n      function formatValue(ctx, value, recurseTimes) {\n        // Provide a hook for user-specified inspect functions.\n        // Check that value is an object with an inspect function on it\n        if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special\n        value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n          var ret = value.inspect(recurseTimes, ctx);\n\n          if (!isString(ret)) {\n            ret = formatValue(ctx, ret, recurseTimes);\n          }\n\n          return ret;\n        } // Primitive types cannot have properties\n\n\n        var primitive = formatPrimitive(ctx, value);\n\n        if (primitive) {\n          return primitive;\n        } // Look up the keys of the object.\n\n\n        var keys = Object.keys(value);\n        var visibleKeys = arrayToHash(keys);\n\n        if (ctx.showHidden) {\n          keys = Object.getOwnPropertyNames(value);\n        } // IE doesn't make error fields non-enumerable\n        // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n\n\n        if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n          return formatError(value);\n        } // Some type of object without properties can be shortcutted.\n\n\n        if (keys.length === 0) {\n          if (isFunction(value)) {\n            var name = value.name ? ': ' + value.name : '';\n            return ctx.stylize('[Function' + name + ']', 'special');\n          }\n\n          if (isRegExp(value)) {\n            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n          }\n\n          if (isDate(value)) {\n            return ctx.stylize(Date.prototype.toString.call(value), 'date');\n          }\n\n          if (isError(value)) {\n            return formatError(value);\n          }\n        }\n\n        var base = '',\n            array = false,\n            braces = ['{', '}']; // Make Array say that they are Array\n\n        if (isArray(value)) {\n          array = true;\n          braces = ['[', ']'];\n        } // Make functions say that they are functions\n\n\n        if (isFunction(value)) {\n          var n = value.name ? ': ' + value.name : '';\n          base = ' [Function' + n + ']';\n        } // Make RegExps say that they are RegExps\n\n\n        if (isRegExp(value)) {\n          base = ' ' + RegExp.prototype.toString.call(value);\n        } // Make dates with properties first say the date\n\n\n        if (isDate(value)) {\n          base = ' ' + Date.prototype.toUTCString.call(value);\n        } // Make error with message first say the error\n\n\n        if (isError(value)) {\n          base = ' ' + formatError(value);\n        }\n\n        if (keys.length === 0 && (!array || value.length == 0)) {\n          return braces[0] + base + braces[1];\n        }\n\n        if (recurseTimes < 0) {\n          if (isRegExp(value)) {\n            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n          } else {\n            return ctx.stylize('[Object]', 'special');\n          }\n        }\n\n        ctx.seen.push(value);\n        var output;\n\n        if (array) {\n          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n        } else {\n          output = keys.map(function (key) {\n            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n          });\n        }\n\n        ctx.seen.pop();\n        return reduceToSingleString(output, base, braces);\n      }\n\n      function formatPrimitive(ctx, value) {\n        if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');\n\n        if (isString(value)) {\n          var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '').replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + '\\'';\n          return ctx.stylize(simple, 'string');\n        }\n\n        if (isNumber(value)) return ctx.stylize('' + value, 'number');\n        if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is \"object\", so special case here.\n\n        if (isNull(value)) return ctx.stylize('null', 'null');\n      }\n\n      function formatError(value) {\n        return '[' + Error.prototype.toString.call(value) + ']';\n      }\n\n      function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n        var output = [];\n\n        for (var i = 0, l = value.length; i < l; ++i) {\n          if (hasOwnProperty(value, String(i))) {\n            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));\n          } else {\n            output.push('');\n          }\n        }\n\n        keys.forEach(function (key) {\n          if (!key.match(/^\\d+$/)) {\n            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));\n          }\n        });\n        return output;\n      }\n\n      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n        var name, str, desc;\n        desc = Object.getOwnPropertyDescriptor(value, key) || {\n          value: value[key]\n        };\n\n        if (desc.get) {\n          if (desc.set) {\n            str = ctx.stylize('[Getter/Setter]', 'special');\n          } else {\n            str = ctx.stylize('[Getter]', 'special');\n          }\n        } else {\n          if (desc.set) {\n            str = ctx.stylize('[Setter]', 'special');\n          }\n        }\n\n        if (!hasOwnProperty(visibleKeys, key)) {\n          name = '[' + key + ']';\n        }\n\n        if (!str) {\n          if (ctx.seen.indexOf(desc.value) < 0) {\n            if (isNull(recurseTimes)) {\n              str = formatValue(ctx, desc.value, null);\n            } else {\n              str = formatValue(ctx, desc.value, recurseTimes - 1);\n            }\n\n            if (str.indexOf('\\n') > -1) {\n              if (array) {\n                str = str.split('\\n').map(function (line) {\n                  return '  ' + line;\n                }).join('\\n').substr(2);\n              } else {\n                str = '\\n' + str.split('\\n').map(function (line) {\n                  return '   ' + line;\n                }).join('\\n');\n              }\n            }\n          } else {\n            str = ctx.stylize('[Circular]', 'special');\n          }\n        }\n\n        if (isUndefined(name)) {\n          if (array && key.match(/^\\d+$/)) {\n            return str;\n          }\n\n          name = JSON.stringify('' + key);\n\n          if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n            name = name.substr(1, name.length - 2);\n            name = ctx.stylize(name, 'name');\n          } else {\n            name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n            name = ctx.stylize(name, 'string');\n          }\n        }\n\n        return name + ': ' + str;\n      }\n\n      function reduceToSingleString(output, base, braces) {\n        var numLinesEst = 0;\n        var length = output.reduce(function (prev, cur) {\n          numLinesEst++;\n          if (cur.indexOf('\\n') >= 0) numLinesEst++;\n          return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n        }, 0);\n\n        if (length > 60) {\n          return braces[0] + (base === '' ? '' : base + '\\n ') + ' ' + output.join(',\\n  ') + ' ' + braces[1];\n        }\n\n        return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n      } // NOTE: These type checking functions intentionally don't use `instanceof`\n      // because it is fragile and can be easily faked with `Object.create()`.\n\n\n      function isArray(ar) {\n        return Array.isArray(ar);\n      }\n\n      exports.isArray = isArray;\n\n      function isBoolean(arg) {\n        return typeof arg === 'boolean';\n      }\n\n      exports.isBoolean = isBoolean;\n\n      function isNull(arg) {\n        return arg === null;\n      }\n\n      exports.isNull = isNull;\n\n      function isNullOrUndefined(arg) {\n        return arg == null;\n      }\n\n      exports.isNullOrUndefined = isNullOrUndefined;\n\n      function isNumber(arg) {\n        return typeof arg === 'number';\n      }\n\n      exports.isNumber = isNumber;\n\n      function isString(arg) {\n        return typeof arg === 'string';\n      }\n\n      exports.isString = isString;\n\n      function isSymbol(arg) {\n        return typeof arg === 'symbol';\n      }\n\n      exports.isSymbol = isSymbol;\n\n      function isUndefined(arg) {\n        return arg === void 0;\n      }\n\n      exports.isUndefined = isUndefined;\n\n      function isRegExp(re) {\n        return isObject(re) && objectToString(re) === '[object RegExp]';\n      }\n\n      exports.isRegExp = isRegExp;\n\n      function isObject(arg) {\n        return typeof arg === 'object' && arg !== null;\n      }\n\n      exports.isObject = isObject;\n\n      function isDate(d) {\n        return isObject(d) && objectToString(d) === '[object Date]';\n      }\n\n      exports.isDate = isDate;\n\n      function isError(e) {\n        return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);\n      }\n\n      exports.isError = isError;\n\n      function isFunction(arg) {\n        return typeof arg === 'function';\n      }\n\n      exports.isFunction = isFunction;\n\n      function isPrimitive(arg) {\n        return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol\n        typeof arg === 'undefined';\n      }\n\n      exports.isPrimitive = isPrimitive;\n      exports.isBuffer = require('./support/isBuffer');\n\n      function objectToString(o) {\n        return Object.prototype.toString.call(o);\n      }\n\n      function pad(n) {\n        return n < 10 ? '0' + n.toString(10) : n.toString(10);\n      }\n\n      var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34\n\n      function timestamp() {\n        var d = new Date();\n        var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');\n        return [d.getDate(), months[d.getMonth()], time].join(' ');\n      } // log is just a thin wrapper to console.log that prepends a timestamp\n\n\n      exports.log = function () {\n        console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n      };\n      /**\n       * Inherit the prototype methods from one constructor into another.\n       *\n       * The Function.prototype.inherits from lang.js rewritten as a standalone\n       * function (not on Function.prototype). NOTE: If this file is to be loaded\n       * during bootstrapping this function needs to be rewritten using some native\n       * functions as prototype setup using normal JavaScript does not work as\n       * expected during bootstrapping (see mirror.js in r114903).\n       *\n       * @param {function} ctor Constructor function which needs to inherit the\n       *     prototype.\n       * @param {function} superCtor Constructor function to inherit prototype from.\n       */\n\n\n      exports.inherits = require('inherits');\n\n      exports._extend = function (origin, add) {\n        // Don't do anything if add isn't an object\n        if (!add || !isObject(add)) return origin;\n        var keys = Object.keys(add);\n        var i = keys.length;\n\n        while (i--) {\n          origin[keys[i]] = add[keys[i]];\n        }\n\n        return origin;\n      };\n\n      function hasOwnProperty(obj, prop) {\n        return Object.prototype.hasOwnProperty.call(obj, prop);\n      }\n    }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n  }, {\n    \"./support/isBuffer\": 53,\n    \"_process\": 19,\n    \"inherits\": 52\n  }],\n  55: [function (require, module, exports) {\n    module.exports = extend;\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n    function extend() {\n      var target = {};\n\n      for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    }\n  }, {}],\n  56: [function (require, module, exports) {\n    require('es6-shim');\n\n    var solc = require('solc/wrapper');\n\n    function loadScript(name, url, callback) {\n      var script = document.getElementById(\"script-\" + name);\n\n      if (script != null) {\n        script.parentElement.removeChild(script);\n      }\n\n      script = document.createElement(\"script\");\n      script.type = \"text/javascript\";\n      script.setAttribute(\"id\", \"script-\" + name);\n\n      if (script.readyState) {\n        //IE\n        script.onreadystatechange = function () {\n          if (script.readyState == \"loaded\" || script.readyState == \"complete\") {\n            script.onreadystatechange = null;\n            callback();\n          }\n        };\n      } else {\n        //Others\n        script.onload = function () {\n          callback();\n        };\n      }\n\n      script.src = url;\n      document.getElementsByTagName(\"head\")[0].appendChild(script);\n    }\n\n    function loadVersion(version, callback) {\n      delete window.Module; // NOTE: workaround some browsers\n\n      window.Module = undefined;\n      var url = \"https://ethereum.github.io/solc-bin/bin/\" + version;\n      loadScript(\"solc\", url, function () {\n        var compiler = solc(window.Module);\n        callback(compiler);\n      });\n    } // Also loads global variables called \"soljsonSources\" and \"soljsonReleases\"\n\n\n    function getVersions(callback) {\n      var url = \"https://ethereum.github.io/solc-bin/bin/list.js\";\n      loadScript(\"solc-list\", url, function () {\n        callback(soljsonSources, soljsonReleases);\n      });\n    }\n\n    module.exports = {\n      'getVersions': getVersions,\n      'loadVersion': loadVersion\n    };\n  }, {\n    \"es6-shim\": 9,\n    \"solc/wrapper\": 41\n  }],\n  57: [function (require, module, exports) {\n    require('es6-shim');\n\n    var solc = require('./browser-solc');\n\n    var domIsReady = function (domIsReady) {\n      var isBrowserIeOrNot = function () {\n        return !document.attachEvent || typeof document.attachEvent === \"undefined\" ? 'not-ie' : 'ie';\n      };\n\n      domIsReady = function (callback) {\n        if (callback && typeof callback === 'function') {\n          if (isBrowserIeOrNot() !== 'ie') {\n            document.addEventListener(\"DOMContentLoaded\", function () {\n              return callback();\n            });\n          } else {\n            document.attachEvent(\"onreadystatechange\", function () {\n              if (document.readyState === \"complete\") {\n                return callback();\n              }\n            });\n          }\n        } else {\n          console.error('The callback is not a function!');\n        }\n      };\n\n      return domIsReady;\n    }(domIsReady || {});\n\n    (function (document, window, domIsReady, undefined) {\n      domIsReady(function () {\n        window.BrowserSolc = solc;\n      });\n    })(document, window, domIsReady);\n  }, {\n    \"./browser-solc\": 56,\n    \"es6-shim\": 9\n  }]\n}, {}, [57]);","map":null,"metadata":{},"sourceType":"script"}