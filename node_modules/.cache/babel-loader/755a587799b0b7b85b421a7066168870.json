{"ast":null,"code":"'use strict';\n\nvar STREAM = require('stream'),\n    UTIL = require('util'),\n    StringDecoder = require('string_decoder').StringDecoder;\n\nfunction MemoryReadableStream(data, options) {\n  if (!(this instanceof MemoryReadableStream)) return new MemoryReadableStream(data, options);\n  MemoryReadableStream.super_.call(this, options);\n  this.init(data, options);\n}\n\nUTIL.inherits(MemoryReadableStream, STREAM.Readable);\n\nfunction MemoryWritableStream(data, options) {\n  if (!(this instanceof MemoryWritableStream)) return new MemoryWritableStream(data, options);\n  MemoryWritableStream.super_.call(this, options);\n  this.init(data, options);\n}\n\nUTIL.inherits(MemoryWritableStream, STREAM.Writable);\n\nfunction MemoryDuplexStream(data, options) {\n  if (!(this instanceof MemoryDuplexStream)) return new MemoryDuplexStream(data, options);\n  MemoryDuplexStream.super_.call(this, options);\n  this.init(data, options);\n}\n\nUTIL.inherits(MemoryDuplexStream, STREAM.Duplex);\n\nMemoryReadableStream.prototype.init = MemoryWritableStream.prototype.init = MemoryDuplexStream.prototype.init = function init(data, options) {\n  var self = this;\n  this.queue = [];\n\n  if (data) {\n    if (!Array.isArray(data)) {\n      data = [data];\n    }\n\n    data.forEach(function (chunk) {\n      if (!(chunk instanceof Buffer)) {\n        chunk = new Buffer(chunk);\n      }\n\n      self.queue.push(chunk);\n    });\n  }\n\n  options = options || {};\n  this.maxbufsize = options.hasOwnProperty('maxbufsize') ? options.maxbufsize : null;\n  this.bufoverflow = options.hasOwnProperty('bufoverflow') ? options.bufoverflow : null;\n  this.frequence = options.hasOwnProperty('frequence') ? options.frequence : null;\n};\n\nfunction MemoryStream(data, options) {\n  if (!(this instanceof MemoryStream)) return new MemoryStream(data, options);\n  options = options || {};\n  var readable = options.hasOwnProperty('readable') ? options.readable : true,\n      writable = options.hasOwnProperty('writable') ? options.writable : true;\n\n  if (readable && writable) {\n    return new MemoryDuplexStream(data, options);\n  } else if (readable) {\n    return new MemoryReadableStream(data, options);\n  } else if (writable) {\n    return new MemoryWritableStream(data, options);\n  } else {\n    throw new Error(\"Unknown stream type  Readable, Writable or Duplex \");\n  }\n}\n\nMemoryStream.createReadStream = function (data, options) {\n  options = options || {};\n  options.readable = true;\n  options.writable = false;\n  return new MemoryStream(data, options);\n};\n\nMemoryStream.createWriteStream = function (data, options) {\n  options = options || {};\n  options.readable = false;\n  options.writable = true;\n  return new MemoryStream(data, options);\n};\n\nMemoryReadableStream.prototype._read = MemoryDuplexStream.prototype._read = function _read(n) {\n  var self = this,\n      frequence = self.frequence || 0,\n      wait_data = this instanceof STREAM.Duplex && !this._writableState.finished ? true : false;\n\n  if (!this.queue.length && !wait_data) {\n    this.push(null); // finish stream\n  } else if (this.queue.length) {\n    setTimeout(function () {\n      if (self.queue.length) {\n        var chunk = self.queue.shift();\n\n        if (chunk && !self._readableState.ended) {\n          if (!self.push(chunk)) {\n            self.queue.unshift(chunk);\n          }\n        }\n      }\n    }, frequence);\n  }\n};\n\nMemoryWritableStream.prototype._write = MemoryDuplexStream.prototype._write = function _write(chunk, encoding, cb) {\n  var decoder = null;\n\n  try {\n    decoder = this.decodeStrings && encoding ? new StringDecoder(encoding) : null;\n  } catch (err) {\n    return cb(err);\n  }\n\n  var decoded_chunk = decoder ? decoder.write(chunk) : chunk,\n      queue_size = this._getQueueSize(),\n      chunk_size = decoded_chunk.length;\n\n  if (this.maxbufsize && queue_size + chunk_size > this.maxbufsize) {\n    if (this.bufoverflow) {\n      return cb(\"Buffer overflowed (\" + this.bufoverflow + \"/\" + queue_size + \")\");\n    } else {\n      return cb();\n    }\n  }\n\n  if (this instanceof STREAM.Duplex) {\n    while (this.queue.length) {\n      this.push(this.queue.shift());\n    }\n\n    this.push(decoded_chunk);\n  } else {\n    this.queue.push(decoded_chunk);\n  }\n\n  cb();\n};\n\nMemoryDuplexStream.prototype.end = function (chunk, encoding, cb) {\n  var self = this;\n  return MemoryDuplexStream.super_.prototype.end.call(this, chunk, encoding, function () {\n    self.push(null); //finish readble stream too\n\n    if (cb) cb();\n  });\n};\n\nMemoryReadableStream.prototype._getQueueSize = MemoryWritableStream.prototype._getQueueSize = MemoryDuplexStream.prototype._getQueueSize = function () {\n  var queuesize = 0,\n      i;\n\n  for (i = 0; i < this.queue.length; i++) {\n    queuesize += Array.isArray(this.queue[i]) ? this.queue[i][0].length : this.queue[i].length;\n  }\n\n  return queuesize;\n};\n\nMemoryWritableStream.prototype.toString = MemoryDuplexStream.prototype.toString = MemoryReadableStream.prototype.toString = MemoryWritableStream.prototype.getAll = MemoryDuplexStream.prototype.getAll = MemoryReadableStream.prototype.getAll = function () {\n  var self = this,\n      ret = '';\n  this.queue.forEach(function (data) {\n    ret += data;\n  });\n  return ret;\n};\n\nMemoryWritableStream.prototype.toBuffer = MemoryDuplexStream.prototype.toBuffer = MemoryReadableStream.prototype.toBuffer = function () {\n  var buffer = new Buffer(this._getQueueSize()),\n      currentOffset = 0;\n  this.queue.forEach(function (data) {\n    var data_buffer = data instanceof Buffer ? data : new Buffer(data);\n    data_buffer.copy(buffer, currentOffset);\n    currentOffset += data.length;\n  });\n  return buffer;\n};\n\nmodule.exports = MemoryStream;","map":null,"metadata":{},"sourceType":"script"}