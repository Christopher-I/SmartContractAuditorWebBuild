{"ast":null,"code":"export default (dataArray => {\n  //let dataArray = contractCode.split(\"\\n\");\n  let actionLines = [];\n  let warn = {\n    key: \"Fiat\",\n    warn: \"500\"\n  };\n  let warnings = [];\n  let searchFunction = 'function'; // we are looking for a line, contains, key word 'user1' in the file\n\n  let searchExternalCall = '.call()';\n  let dangerousCalls1 = '.call.value()';\n  let lastIndex = -1; // let say, we have not found the keyword\n\n  let EIPE20Check = 0;\n\n  for (let index = 0; index < dataArray.length; index++) {\n    //Store action Lines\n    // Audit payable transaction restrictions\n    if (dataArray[index].includes(searchFunction) && dataArray[index].includes('(') || dataArray[index].includes('contract') && dataArray[index].includes('{') || dataArray[index].includes('constructor') && dataArray[index].includes('(')) {\n      //find function calls\n      actionLines.push(index);\n    }\n\n    ; // Audit payable transaction restrictions\n\n    if (dataArray[index].includes(searchFunction) && dataArray[index].includes('(')) {\n      //find function calls\n      if (dataArray[index].includes('payable')) {\n        //check if contract is payable\n        if (!dataArray[index].includes('internal') && !dataArray[index].includes('restricted')) {\n          //check if contract is payable \n          warn = {\n            key: index + 1,\n            value: \"Use caution when making external calls on payable function, ensure you mark trusted contracts/address. \"\n          };\n          warnings.push(warn);\n        }\n      }\n    } //Audting state changes after external calls\n\n\n    if (dataArray[index].includes(searchExternalCall)) {\n      //find external calls\n      warn = {\n        key: index + 1,\n        value: \"Avoid state changes after external calls.\"\n      };\n      warnings.push(warn);\n    } //Be aware of the tradeoffs between send(), transfer(), and call.value()()\n\n\n    if (dataArray[index].includes(dangerousCalls1)) {\n      //find external calls\n      warn = {\n        key: index + 1,\n        value: \"Be aware that using '.call.value()', it is susceptible to re-entry attacks, if possible use send() or transfer(). Also do not forget to set your new account balance before the transfer \"\n      };\n      warnings.push(warn);\n    } //Handle errors in external calls\n\n\n    if (dataArray[index].includes('.callcode(') || dataArray[index].includes('.call(') || dataArray[index].includes('call(') || dataArray[index].includes('.delegatecall(') || dataArray[index].includes('.send(')) {\n      //find external calls\n      if (!dataArray[index].includes('if')) {\n        warn = {\n          key: index + 1,\n          value: \"Handle errors in external calls warning: make sure to handle the possibility that the call will fail, by checking the return value.\"\n        };\n        warnings.push(warn);\n      }\n    } // Favor pull over push for external calls\n\n\n    if (dataArray[index].includes(searchFunction) && dataArray[index].includes('(')) {\n      //find function calls\n      if (dataArray[index].includes('payable')) {\n        //check if contract is payable\n        if (dataArray[index].includes('internal') || !dataArray[index].includes('external')) {\n          //check if contract is payable \n          warn = {\n            key: index + 1,\n            value: \"Favor pull over push for external calls.External/Internal Calls can fail accidentally or deliberately. To minimize the damage caused by such failures, it is often better to set up manaul transfers rather than automate them. This is especially relevant for payments, where it is better to let users withdraw funds rather than push funds to them automatically. (This also reduces the chance of problems with the gas limit.)\"\n          };\n          warnings.push(warn);\n        }\n      }\n    }\n\n    ; //Don't delegatecall to untrusted code\n\n    if (dataArray[index].includes('.delegatecall') && dataArray[index].includes('(')) {\n      //find external calls \n      warn = {\n        key: index + 1,\n        value: \"Ensure that the address being used in this delegate call is a trusted address and cannot be changed or supplied by a user, as the result can alter the state of your contract \"\n      };\n      warnings.push(warn);\n    } //Audit function visibility \n\n\n    if (dataArray[index].includes(searchFunction) && dataArray[index].includes('(') && !dataArray[index].includes('internal') && !dataArray[index].includes('external') && !dataArray[index].includes('private') && !dataArray[index].includes('public')) {\n      warn = {\n        key: index + 1,\n        value: \"Explicitly label the visibility of functions and state variables. Functions can be specified as being external, public, internal or private. \"\n      };\n      warnings.push(warn);\n    } //Lock Pragma on specific solidity version\n\n\n    if (dataArray[index].includes('pragma solidity') && (dataArray[index].includes('>') || dataArray[index].includes('<'))) {\n      //find external calls\n      warnings.push({\n        key: index + 1,\n        value: \"Lock pragmas to specific compiler version. Locking the pragma helps ensure that contracts do not accidentally get deployed using, for example, the latest compiler which may have higher risks of undiscovered bugs.\"\n      });\n    } //Avoid using tx.origin\n\n\n    if (dataArray[index].includes('tx.origin')) {\n      //find external calls\n      warn = {\n        key: index + 1,\n        value: \"Avoid using tx.origin as it is unsafe, we recommend you should use msg.sender for authorization.\"\n      };\n      warnings.push(warn);\n    }\n\n    if (dataArray[index].includes('block.timestamp')) {\n      //find external calls\n      warn = {\n        key: index + 1,\n        value: \"Be aware that the timestamp of the block maybe inaccurate as it can be manipulated by a miner and other factors.\"\n      };\n      warnings.push(warn);\n    }\n\n    if (dataArray[index].includes('block.number')) {\n      //find external calls  \n      warn = {\n        key: index + 1,\n        value: \"It is possible to estimate a time delta using the block.number property and average block time, however this is not future proof as block times may change.\"\n      };\n      warnings.push(warn);\n    } //Use interface type instead of the address for type safety\n\n\n    if (dataArray[index].includes(searchFunction) && dataArray[index].includes('(') && dataArray[index].includes('address')) {\n      //find function calls\n      warn = {\n        key: index + 1,\n        value: \"When a function takes a contract address as an argument, it is better to pass an interface or contract type rather than raw address. If the function is called elsewhere within the source code, the compiler it will provide additional type safety guarantees \"\n      };\n      warnings.push(warn);\n    }\n\n    if (dataArray[index].includes('extcodesize')) {\n      //find external calls\n      warn = {\n        key: index + 1,\n        value: \"Avoid using extcodesize to check for Externally Owned Accounts.\"\n      };\n      warnings.push(warn);\n    }\n\n    if (dataArray[index].includes('EIP-20') || dataArray[index].includes('approve(')) {\n      EIPE20Check++;\n\n      if (EIPE20Check >= 2) {\n        warn = {\n          key: index + 1,\n          value: \"The EIP-20 token's approve() function creates the potential for an approved spender to spend more than the intended amount. A front running attack can be used, enabling an approved spender to call transferFrom() both before and after the call to approve() is processed.\"\n        };\n        warnings.push(warn);\n      }\n    } //Prevent transferring tokens to the 0x0 address\n\n\n    if (dataArray[index].includes(searchFunction) && dataArray[index].includes('(') && (dataArray[index].includes('transferFrom') || dataArray[index].includes('transfer'))) {\n      //find function calls\n      warn = {\n        key: index + 1,\n        value: \"Prevent transferring tokens to the 0x0 address and prevent transferring tokens to the same contract address. -\" + \"After your function declaration, you could the modifier:\" + \"modifier validDestination( address to ) {\" + \"require(to != address(0x0));\" + \"require(to != address(this) );\" + \"};\" + \" line \"\n      };\n      warnings.push(warn);\n    } //Safemath preventions\n\n\n    if (dataArray[index].includes('uint256') && dataArray[index].includes('=') && (dataArray[index].includes('*') || dataArray[index].includes('-') || dataArray[index].includes('+') || dataArray[index].includes('/'))) {\n      //find external calls\n      warn = {\n        key: index + 1,\n        value: \"Be aware that doing math functions on uint256 can cause overflows and underflows. We recommend you implement OpenZeppelin SafeMath\"\n      };\n      warnings.push(warn);\n    } //Prevent transferring tokens to the 0x0 address\n\n\n    if (dataArray[index].includes(searchFunction) && dataArray[index].includes('(') && (dataArray[index].includes('transferFrom') || dataArray[index].includes('transfer') || dataArray[index].includes('withdraw')) && !dataArray[index].includes('onlyPayloadSize')) {\n      //find function calls\n      warn = {\n        key: index + 1,\n        value: \"Prevent Short address attack by by introducing onlyPayloadSize modifier\"\n      };\n      warnings.push(warn);\n    }\n  }\n\n  let transferCount = 0;\n  let setRequireStatementForIndividualBalanceNotZeroValve = false;\n  let setRequireStatementForAccountBalanceValve = false;\n  let setAccountBalanceValve = false;\n\n  for (let k = 0; k < actionLines.length; k++) {\n    for (let i = actionLines[k]; i < actionLines[k + 1]; i++) {\n      //Audit for multiple transfers within 1 function\n      if (dataArray[i].includes('.transfer(') || dataArray[i].includes('.send(') || dataArray[i].includes('.call.value(')) {\n        transferCount++;\n\n        if (transferCount >= 2) {\n          warn = {\n            key: i + 1,\n            value: \"Avoid multiple transfers within a single function. line\"\n          };\n          warnings.push(warn);\n        }\n      } //check if there is require statement for individuals balance\n\n\n      if (dataArray[i].includes('require(') && dataArray[i].includes('=') && dataArray[i].includes('!')) {\n        setRequireStatementForIndividualBalanceNotZeroValve = true;\n      } //check if there is require statement that sets smart contract account balance to 0\n\n\n      if (dataArray[i].includes('require(') && dataArray[i].includes('this.balance')) {\n        setRequireStatementForAccountBalanceValve = true;\n      } //check if users account balance has been set to zero\n\n\n      if (dataArray[i].includes('=') && dataArray[i].includes('0')) {\n        setAccountBalanceValve = true;\n      } //Audting for using .send()\n\n\n      if (dataArray[i].includes('.send(')) {\n        if (!setRequireStatementForIndividualBalanceNotZeroValve) {\n          warn = {\n            key: i + 1,\n            value: \"Be aware of rerentrancy attack. Before withdraw or transfers, use a require statement to ensure user has available fund. Example require(UserBalance != 0)\"\n          };\n          warnings.push(warn);\n        }\n\n        if (!setRequireStatementForAccountBalanceValve) {\n          warn = {\n            key: i + 1,\n            value: \"Be aware of rerentrancy attack. Before withdraw or transfers, use a require statement to ensure smart contract has available fund. require(this.balance >= payment)\"\n          };\n          warnings.push(warn);\n        }\n\n        if (!setAccountBalanceValve) {\n          warn = {\n            key: i + 1,\n            value: \"Be aware of rerentrancy attack. Set post-withdrawal balance before sending.\"\n          };\n          warnings.push(warn);\n        }\n      }\n    }\n\n    transferCount = 0; //reset transfer count\n\n    setRequireStatementForIndividualBalanceNotZeroValve = false;\n    setRequireStatementForAccountBalanceValve = false;\n    setAccountBalanceValve = false;\n  }\n\n  ; //console.log(\"warning are \" + warnings[1][0]);\n\n  return warnings;\n});","map":{"version":3,"sources":["/Users/chris/Documents/BlockchainProjects/SmartContractAuditor/SmartContractAuditor/src/auditor/Auditor.js"],"names":["dataArray","actionLines","warn","key","warnings","searchFunction","searchExternalCall","dangerousCalls1","lastIndex","EIPE20Check","index","length","includes","push","value","transferCount","setRequireStatementForIndividualBalanceNotZeroValve","setRequireStatementForAccountBalanceValve","setAccountBalanceValve","k","i"],"mappings":"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","sourcesContent":["\n\nexport default(dataArray)=>{\n\n        //let dataArray = contractCode.split(\"\\n\");\n        let actionLines = [];\n        let warn={key:\"Fiat\", warn:\"500\"};\n        let warnings=[];\n        let searchFunction= 'function'; // we are looking for a line, contains, key word 'user1' in the file\n        let searchExternalCall = '.call()';\n        let dangerousCalls1 = '.call.value()';\n        let lastIndex = -1; // let say, we have not found the keyword\n        let EIPE20Check = 0;\n\n\n for (let index=0; index<dataArray.length; index++) {\n\n //Store action Lines\n                // Audit payable transaction restrictions\n        if ((dataArray[index].includes(searchFunction) && dataArray[index].includes('(')) || \n        (dataArray[index].includes('contract') && dataArray[index].includes('{')) ||\n        (dataArray[index].includes('constructor') && dataArray[index].includes('(')) ){ //find function calls\n            actionLines.push(index);\n\n        };\n\n        // Audit payable transaction restrictions\n        if ((dataArray[index].includes(searchFunction)) && dataArray[index].includes('(')) { //find function calls\n            if (dataArray[index].includes('payable')){ //check if contract is payable\n                if (!dataArray[index].includes('internal') && !dataArray[index].includes('restricted')){ //check if contract is payable \n                warn = {key:(index+1), value:\"Use caution when making external calls on payable function, ensure you mark trusted contracts/address. \"}; \n\n                warnings.push(warn);\n            }\n        }\n        }\n    \n    //Audting state changes after external calls\n        if (dataArray[index].includes(searchExternalCall)) { //find external calls\n            warn = {key:(index+1), value:\"Avoid state changes after external calls.\"};       \n                warnings.push(warn);\n                \n        }\n    \n        //Be aware of the tradeoffs between send(), transfer(), and call.value()()\n        if (dataArray[index].includes(dangerousCalls1)) { //find external calls\n            warn = {key:(index+1), value:\"Be aware that using '.call.value()', it is susceptible to re-entry attacks, if possible use send() or transfer(). Also do not forget to set your new account balance before the transfer \"};      \n                warnings.push(warn);\n                \n        }\n\n        //Handle errors in external calls\n                if (dataArray[index].includes('.callcode(') || dataArray[index].includes('.call(')||dataArray[index].includes('call(') || dataArray[index].includes('.delegatecall(') || dataArray[index].includes('.send(')) {\n                    //find external calls\n                    if (!dataArray[index].includes('if')){\n                    warn = {key:(index+1), value:\"Handle errors in external calls warning: make sure to handle the possibility that the call will fail, by checking the return value.\"};     \n                    warnings.push(warn);\n            }              \n        }\n\n// Favor pull over push for external calls\n        if (dataArray[index].includes(searchFunction) && dataArray[index].includes('(')) { //find function calls\n            if (dataArray[index].includes('payable')){ //check if contract is payable\n                if ((dataArray[index].includes('internal')) || (!dataArray[index].includes('external'))) { //check if contract is payable \n\n                warn = {key:(index+1), value:\"Favor pull over push for external calls.External/Internal Calls can fail accidentally or deliberately. To minimize the damage caused by such failures, it is often better to set up manaul transfers rather than automate them. This is especially relevant for payments, where it is better to let users withdraw funds rather than push funds to them automatically. (This also reduces the chance of problems with the gas limit.)\"}; \n                warnings.push(warn);\n            }\n        }\n        };\n\n\n        //Don't delegatecall to untrusted code\n        if (((dataArray[index].includes('.delegatecall')) && (dataArray[index].includes('(')))) { //find external calls \n            warn={key:(index+1), value:\"Ensure that the address being used in this delegate call is a trusted address and cannot be changed or supplied by a user, as the result can alter the state of your contract \"};  \n                warnings.push(warn);\n                \n        }\n\n        //Audit function visibility \n        if ((dataArray[index].includes(searchFunction)) && dataArray[index].includes('(') && (!dataArray[index].includes('internal')) &&\n        ((!dataArray[index].includes('external'))) && ((!dataArray[index].includes('private'))) && ((!dataArray[index].includes('public'))) ) {\n            warn = {key:(index+1), value:\"Explicitly label the visibility of functions and state variables. Functions can be specified as being external, public, internal or private. \"};  \n            warnings.push(warn); \n\n        }\n\n            //Lock Pragma on specific solidity version\n        if ((dataArray[index].includes('pragma solidity')) && ((dataArray[index].includes('>')) || (dataArray[index].includes('<'))) ) { //find external calls\n                warnings.push({key:(index+1), value: \"Lock pragmas to specific compiler version. Locking the pragma helps ensure that contracts do not accidentally get deployed using, for example, the latest compiler which may have higher risks of undiscovered bugs.\"});\n                \n        }\n\n            //Avoid using tx.origin\n        if (dataArray[index].includes('tx.origin')) { //find external calls\n            warn = {key:(index+1), value:\"Avoid using tx.origin as it is unsafe, we recommend you should use msg.sender for authorization.\" };  \n                warnings.push(warn);\n                \n        }\n\n         if (dataArray[index].includes('block.timestamp')) { //find external calls\n            warn = {key:(index+1), value:\"Be aware that the timestamp of the block maybe inaccurate as it can be manipulated by a miner and other factors.\"};      \n                warnings.push(warn);\n                \n        }\n\n        if (dataArray[index].includes('block.number')) { //find external calls  \n            warn = {key:(index+1), value:\"It is possible to estimate a time delta using the block.number property and average block time, however this is not future proof as block times may change.\"};   \n\n                warnings.push(warn);\n                \n        }\n\n        //Use interface type instead of the address for type safety\n        if ((dataArray[index].includes(searchFunction)) && dataArray[index].includes('(') && dataArray[index].includes('address') ) { //find function calls\n                warn = {key:(index+1), value:\"When a function takes a contract address as an argument, it is better to pass an interface or contract type rather than raw address. If the function is called elsewhere within the source code, the compiler it will provide additional type safety guarantees \"};    \n                warnings.push(warn);\n\n        }\n\n        if (dataArray[index].includes('extcodesize')) { //find external calls\n            warn = {key:(index+1), value:\"Avoid using extcodesize to check for Externally Owned Accounts.\"};       \n                warnings.push(warn);\n                \n        }\n\n        if ((dataArray[index].includes('EIP-20')) || (dataArray[index].includes('approve(')) ){\n             EIPE20Check ++;\n\n            if (EIPE20Check >= 2){\n                warn = {key:(index+1), value:\"The EIP-20 token's approve() function creates the potential for an approved spender to spend more than the intended amount. A front running attack can be used, enabling an approved spender to call transferFrom() both before and after the call to approve() is processed.\"} ;       \n                warnings.push(warn);\n            }\n        }\n\n\n        //Prevent transferring tokens to the 0x0 address\n        if ((dataArray[index].includes(searchFunction)) && dataArray[index].includes('(') && (dataArray[index].includes('transferFrom') || dataArray[index].includes('transfer')) ) { //find function calls\n\n                warn = {key:(index+1), value:\"Prevent transferring tokens to the 0x0 address and prevent transferring tokens to the same contract address. -\" + \n                \"After your function declaration, you could the modifier:\" +\n                \"modifier validDestination( address to ) {\" +\n                \"require(to != address(0x0));\" +\n                \"require(to != address(this) );\" +\n                \"};\" +\n                \" line \"} ;       \n                warnings.push(warn);\n        }\n\n\n        //Safemath preventions\n        if ((dataArray[index].includes('uint256')) && (dataArray[index].includes('=')) && ((dataArray[index].includes('*')) || \n        (dataArray[index].includes('-')) || (dataArray[index].includes('+')) || (dataArray[index].includes('/')) ) ) { //find external calls\n            warn = {key:(index+1), value:\"Be aware that doing math functions on uint256 can cause overflows and underflows. We recommend you implement OpenZeppelin SafeMath\"};        \n                warnings.push(warn);\n                \n        }\n\n\n\n        //Prevent transferring tokens to the 0x0 address\n        if ((dataArray[index].includes(searchFunction)) && (dataArray[index].includes('(')) && ((dataArray[index].includes('transferFrom')) || \n        (dataArray[index].includes('transfer')) || (dataArray[index].includes('withdraw'))) && (!dataArray[index].includes('onlyPayloadSize')))  { //find function calls\n                warn = {key:(index+1), value:\"Prevent Short address attack by by introducing onlyPayloadSize modifier\"};       \n                warnings.push(warn);\n        }\n\n\n}\n\n\n\n    let transferCount =0;\n    let setRequireStatementForIndividualBalanceNotZeroValve = false;\n    let setRequireStatementForAccountBalanceValve = false;\n    let setAccountBalanceValve = false;\n\n    for (let k = 0; k<actionLines.length; k++){\n\n    for (let i=actionLines[k]; i<actionLines[k+1]; i++) {\n\n        //Audit for multiple transfers within 1 function\n        if ((dataArray[i].includes('.transfer('))|| (dataArray[i].includes('.send(')) || (dataArray[i].includes('.call.value('))) {\n            transferCount++;\n            if(transferCount >=2){\n                warn = {key:(i+1), value:\"Avoid multiple transfers within a single function. line\"} ;\n                warnings.push(warn);\n\n            }\n        }\n\n        //check if there is require statement for individuals balance\n        if (((dataArray[i].includes('require('))) && ((dataArray[i].includes('='))) && ((dataArray[i].includes('!'))) ) {\n                setRequireStatementForIndividualBalanceNotZeroValve = true;\n        }\n\n\n        //check if there is require statement that sets smart contract account balance to 0\n        if (((dataArray[i].includes('require('))) && ((dataArray[i].includes('this.balance'))) ) {\n                setRequireStatementForAccountBalanceValve = true;\n        }\n\n\n        //check if users account balance has been set to zero\n        if (((dataArray[i].includes('='))) && ((dataArray[i].includes('0'))) ) {\n                setAccountBalanceValve = true;\n        }\n\n\n        //Audting for using .send()\n        if ((dataArray[i].includes('.send('))) {\n\n        if(!setRequireStatementForIndividualBalanceNotZeroValve){\n                warn = {key:(i+1), value:\"Be aware of rerentrancy attack. Before withdraw or transfers, use a require statement to ensure user has available fund. Example require(UserBalance != 0)\"} ;\n                warnings.push(warn); \n            }\n\n        if(!setRequireStatementForAccountBalanceValve){\n                warn = {key:(i+1), value:\"Be aware of rerentrancy attack. Before withdraw or transfers, use a require statement to ensure smart contract has available fund. require(this.balance >= payment)\"} ;\n                warnings.push(warn); \n            }\n\n        if(!setAccountBalanceValve){\n                warn = {key:(i+1), value:\"Be aware of rerentrancy attack. Set post-withdrawal balance before sending.\"} ;\n                warnings.push(warn); \n            }\n\n        }\n\n    }\n    transferCount = 0;//reset transfer count\n    setRequireStatementForIndividualBalanceNotZeroValve = false;\n    setRequireStatementForAccountBalanceValve = false;\n    setAccountBalanceValve = false;\n};\n    //console.log(\"warning are \" + warnings[1][0]);\n\n    return warnings;\n\n}\n\n\n   \n"]},"metadata":{},"sourceType":"module"}