{"ast":null,"code":"var linker = require('./linker.js'); /// Translate old style version numbers to semver.\n/// Old style: 0.3.6-3fc68da5/Release-Emscripten/clang\n///            0.3.5-371690f0/Release-Emscripten/clang/Interpreter\n///            0.2.0-e7098958/.-Emscripten/clang/int linked to libethereum-1.1.1-bbb80ab0/.-Emscripten/clang/int\n///            0.1.3-0/.-/clang/int linked to libethereum-0.9.92-0/.-/clang/int\n///            0.1.2-5c3bfd4b*/.-/clang/int\n///            0.1.1-6ff4cd6b/RelWithDebInfo-Emscripten/clang/int\n/// New style: 0.4.5+commit.b318366e.Emscripten.clang\n\n\nfunction versionToSemver(version) {\n  // FIXME: parse more detail, but this is a good start\n  var parsed = version.match(/^([0-9]+\\.[0-9]+\\.[0-9]+)-([0-9a-f]{8})[/*].*$/);\n\n  if (parsed) {\n    return parsed[1] + '+commit.' + parsed[2];\n  }\n\n  if (version.indexOf('0.1.3-0') !== -1) {\n    return '0.1.3';\n  } // assume it is already semver compatible\n\n\n  return version;\n}\n\nfunction translateErrors(ret, errors) {\n  for (var error in errors) {\n    var type = 'error';\n    var extractType = /^(.*):(\\d+):(\\d+):(.*):/;\n    extractType = extractType.exec(errors[error]);\n\n    if (extractType) {\n      type = extractType[4].trim();\n    } else if (errors[error].indexOf(': Warning:')) {\n      type = 'Warning';\n    } else if (errors[error].indexOf(': Error:')) {\n      type = 'Error';\n    }\n\n    ret.push({\n      type: type,\n      component: 'general',\n      severity: type === 'Warning' ? 'warning' : 'error',\n      message: errors[error],\n      formattedMessage: errors[error]\n    });\n  }\n}\n\nfunction translateGasEstimates(gasEstimates) {\n  if (gasEstimates === null) {\n    return 'infinite';\n  }\n\n  if (typeof gasEstimates === 'number') {\n    return gasEstimates.toString();\n  }\n\n  var gasEstimatesTranslated = {};\n\n  for (var func in gasEstimates) {\n    gasEstimatesTranslated[func] = translateGasEstimates(gasEstimates[func]);\n  }\n\n  return gasEstimatesTranslated;\n}\n\nfunction translateJsonCompilerOutput(output, libraries) {\n  var ret = {};\n  ret['errors'] = [];\n  var errors;\n\n  if (output['error']) {\n    errors = [output['error']];\n  } else {\n    errors = output['errors'];\n  }\n\n  translateErrors(ret['errors'], errors);\n  ret['contracts'] = {};\n\n  for (var contract in output['contracts']) {\n    // Split name first, can be `contract`, `:contract` or `filename:contract`\n    var tmp = contract.match(/^(([^:]*):)?([^:]+)$/);\n\n    if (tmp.length !== 4) {\n      // Force abort\n      return null;\n    }\n\n    var fileName = tmp[2];\n\n    if (fileName === undefined) {\n      // this is the case of `contract`\n      fileName = '';\n    }\n\n    var contractName = tmp[3];\n    var contractInput = output['contracts'][contract];\n    var gasEstimates = contractInput['gasEstimates'];\n    var translatedGasEstimates = {};\n\n    if (gasEstimates['creation']) {\n      translatedGasEstimates['creation'] = {\n        'codeDepositCost': translateGasEstimates(gasEstimates['creation'][1]),\n        'executionCost': translateGasEstimates(gasEstimates['creation'][0])\n      };\n    }\n\n    if (gasEstimates['internal']) {\n      translatedGasEstimates['internal'] = translateGasEstimates(gasEstimates['internal']);\n    }\n\n    if (gasEstimates['external']) {\n      translatedGasEstimates['external'] = translateGasEstimates(gasEstimates['external']);\n    }\n\n    var contractOutput = {\n      'abi': JSON.parse(contractInput['interface']),\n      'metadata': contractInput['metadata'],\n      'evm': {\n        'legacyAssembly': contractInput['assembly'],\n        'bytecode': {\n          'object': linker.linkBytecode(contractInput['bytecode'], libraries),\n          'opcodes': contractInput['opcodes'],\n          'sourceMap': contractInput['srcmap'],\n          'linkReferences': linker.findLinkReferences(contractInput['bytecode'])\n        },\n        'deployedBytecode': {\n          'object': linker.linkBytecode(contractInput['runtimeBytecode'], libraries),\n          'sourceMap': contractInput['srcmapRuntime'],\n          'linkReferences': linker.findLinkReferences(contractInput['runtimeBytecode'])\n        },\n        'methodIdentifiers': contractInput['functionHashes'],\n        'gasEstimates': translatedGasEstimates\n      }\n    };\n\n    if (!ret['contracts'][fileName]) {\n      ret['contracts'][fileName] = {};\n    }\n\n    ret['contracts'][fileName][contractName] = contractOutput;\n  }\n\n  var sourceMap = {};\n\n  for (var sourceId in output['sourceList']) {\n    sourceMap[output['sourceList'][sourceId]] = sourceId;\n  }\n\n  ret['sources'] = {};\n\n  for (var source in output['sources']) {\n    ret['sources'][source] = {\n      id: sourceMap[source],\n      legacyAST: output['sources'][source].AST\n    };\n  }\n\n  return ret;\n}\n\nfunction escapeString(text) {\n  return text.replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/\\t/g, '\\\\t');\n}\n\nfunction formatAssemblyText(asm, prefix, source) {\n  if (typeof asm === typeof '' || asm === null || asm === undefined) {\n    return prefix + (asm || '') + '\\n';\n  }\n\n  var text = prefix + '.code\\n';\n  asm['.code'].forEach(function (item, i) {\n    var v = item.value === undefined ? '' : item.value;\n    var src = '';\n\n    if (source !== undefined && item.begin !== undefined && item.end !== undefined) {\n      src = escapeString(source.slice(item.begin, item.end));\n    }\n\n    if (src.length > 30) {\n      src = src.slice(0, 30) + '...';\n    }\n\n    if (item.name !== 'tag') {\n      text += '  ';\n    }\n\n    text += prefix + item.name + ' ' + v + '\\t\\t\\t' + src + '\\n';\n  });\n  text += prefix + '.data\\n';\n  var asmData = asm['.data'] || [];\n\n  for (var i in asmData) {\n    var item = asmData[i];\n    text += '  ' + prefix + '' + i + ':\\n';\n    text += formatAssemblyText(item, prefix + '    ', source);\n  }\n\n  return text;\n}\n\nfunction prettyPrintLegacyAssemblyJSON(assembly, source) {\n  return formatAssemblyText(assembly, '', source);\n}\n\nmodule.exports = {\n  versionToSemver: versionToSemver,\n  translateJsonCompilerOutput: translateJsonCompilerOutput,\n  prettyPrintLegacyAssemblyJSON: prettyPrintLegacyAssemblyJSON\n};","map":null,"metadata":{},"sourceType":"script"}