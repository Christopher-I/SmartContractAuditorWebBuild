{"ast":null,"code":"var assert = require('assert');\n\nvar translate = require('./translate.js');\n\nvar requireFromString = require('require-from-string');\n\nvar https = require('https');\n\nvar MemoryStream = require('memorystream');\n\nfunction setupMethods(soljson) {\n  var copyString = function (str, ptr) {\n    var length = soljson.lengthBytesUTF8(str);\n\n    var buffer = soljson._malloc(length + 1);\n\n    soljson.stringToUTF8(str, buffer, length + 1);\n    soljson.setValue(ptr, buffer, '*');\n  };\n\n  var wrapCallback = function (callback) {\n    assert(typeof callback === 'function', 'Invalid callback specified.');\n    return function (path, contents, error) {\n      var result = callback(soljson.Pointer_stringify(path));\n\n      if (typeof result.contents === 'string') {\n        copyString(result.contents, contents);\n      }\n\n      if (typeof result.error === 'string') {\n        copyString(result.error, error);\n      }\n    };\n  }; // This calls compile() with args || cb\n\n\n  var runWithReadCallback = function (readCallback, compile, args) {\n    if (readCallback === undefined) {\n      readCallback = function (path) {\n        return {\n          error: 'File import callback not supported'\n        };\n      };\n    } // This is to support multiple versions of Emscripten.\n\n\n    var addFunction = soljson.addFunction || soljson.Runtime.addFunction;\n    var removeFunction = soljson.removeFunction || soljson.Runtime.removeFunction;\n    var cb = addFunction(wrapCallback(readCallback));\n    var output;\n\n    try {\n      args.push(cb);\n      output = compile.apply(undefined, args);\n    } catch (e) {\n      removeFunction(cb);\n      throw e;\n    }\n\n    removeFunction(cb);\n    return output;\n  };\n\n  var compileJSON = null;\n\n  if ('_compileJSON' in soljson) {\n    compileJSON = soljson.cwrap('compileJSON', 'string', ['string', 'number']);\n  }\n\n  var compileJSONMulti = null;\n\n  if ('_compileJSONMulti' in soljson) {\n    compileJSONMulti = soljson.cwrap('compileJSONMulti', 'string', ['string', 'number']);\n  }\n\n  var compileJSONCallback = null;\n\n  if ('_compileJSONCallback' in soljson) {\n    var compileInternal = soljson.cwrap('compileJSONCallback', 'string', ['string', 'number', 'number']);\n\n    compileJSONCallback = function (input, optimize, readCallback) {\n      return runWithReadCallback(readCallback, compileInternal, [input, optimize]);\n    };\n  }\n\n  var compileStandard = null;\n\n  if ('_compileStandard' in soljson) {\n    var compileStandardInternal = soljson.cwrap('compileStandard', 'string', ['string', 'number']);\n\n    compileStandard = function (input, readCallback) {\n      return runWithReadCallback(readCallback, compileStandardInternal, [input]);\n    };\n  }\n\n  if ('_solidity_compile' in soljson) {\n    var solidityCompile = soljson.cwrap('solidity_compile', 'string', ['string', 'number']);\n\n    compileStandard = function (input, readCallback) {\n      return runWithReadCallback(readCallback, solidityCompile, [input]);\n    };\n  } // Expects a Standard JSON I/O but supports old compilers\n\n\n  var compileStandardWrapper = function (input, readCallback) {\n    if (compileStandard !== null) {\n      return compileStandard(input, readCallback);\n    }\n\n    function formatFatalError(message) {\n      return JSON.stringify({\n        errors: [{\n          'type': 'SOLCError',\n          'component': 'solcjs',\n          'severity': 'error',\n          'message': message,\n          'formattedMessage': 'Error: ' + message\n        }]\n      });\n    }\n\n    if (readCallback !== undefined && typeof readCallback !== 'function') {\n      return formatFatalError('Invalid import callback supplied');\n    }\n\n    try {\n      input = JSON.parse(input);\n    } catch (e) {\n      return formatFatalError('Invalid JSON supplied: ' + e.message);\n    }\n\n    if (input['language'] !== 'Solidity') {\n      return formatFatalError('Only Solidity sources are supported');\n    } // NOTE: this is deliberately `== null`\n\n\n    if (input['sources'] == null || input['sources'].length === 0) {\n      return formatFatalError('No input specified');\n    } // Bail out early\n\n\n    if (input['sources'].length > 1 && compileJSONMulti === null) {\n      return formatFatalError('Multiple sources provided, but compiler only supports single input');\n    }\n\n    function isOptimizerEnabled(input) {\n      return input['settings'] && input['settings']['optimizer'] && input['settings']['optimizer']['enabled'];\n    }\n\n    function translateSources(input) {\n      var sources = {};\n\n      for (var source in input['sources']) {\n        if (input['sources'][source]['content'] !== null) {\n          sources[source] = input['sources'][source]['content'];\n        } else {\n          // force failure\n          return null;\n        }\n      }\n\n      return sources;\n    }\n\n    function librariesSupplied(input) {\n      if (input['settings'] !== null) {\n        return input['settings']['libraries'];\n      }\n    }\n\n    function translateOutput(output, libraries) {\n      try {\n        output = JSON.parse(output);\n      } catch (e) {\n        return formatFatalError('Compiler returned invalid JSON: ' + e.message);\n      }\n\n      output = translate.translateJsonCompilerOutput(output, libraries);\n\n      if (output == null) {\n        return formatFatalError('Failed to process output');\n      }\n\n      return JSON.stringify(output);\n    }\n\n    var sources = translateSources(input);\n\n    if (sources === null || Object.keys(sources).length === 0) {\n      return formatFatalError('Failed to process sources');\n    } // Try linking if libraries were supplied\n\n\n    var libraries = librariesSupplied(input); // Try to wrap around old versions\n\n    if (compileJSONCallback !== null) {\n      return translateOutput(compileJSONCallback(JSON.stringify({\n        'sources': sources\n      }), isOptimizerEnabled(input), readCallback), libraries);\n    }\n\n    if (compileJSONMulti !== null) {\n      return translateOutput(compileJSONMulti(JSON.stringify({\n        'sources': sources\n      }), isOptimizerEnabled(input)), libraries);\n    } // Try our luck with an ancient compiler\n\n\n    if (compileJSON !== null) {\n      return translateOutput(compileJSON(sources[Object.keys(sources)[0]], isOptimizerEnabled(input)), libraries);\n    }\n\n    return formatFatalError('Compiler does not support any known interface.');\n  };\n\n  var version;\n\n  if ('_solidity_version' in soljson) {\n    version = soljson.cwrap('solidity_version', 'string', []);\n  } else {\n    version = soljson.cwrap('version', 'string', []);\n  }\n\n  var versionToSemver = function () {\n    return translate.versionToSemver(version());\n  };\n\n  var license;\n\n  if ('_solidity_license' in soljson) {\n    license = soljson.cwrap('solidity_license', 'string', []);\n  } else if ('_license' in soljson) {\n    license = soljson.cwrap('license', 'string', []);\n  } else {\n    // pre 0.4.14\n    license = function () {// return undefined\n    };\n  }\n\n  return {\n    version: version,\n    semver: versionToSemver,\n    license: license,\n    lowlevel: {\n      compileSingle: compileJSON,\n      compileMulti: compileJSONMulti,\n      compileCallback: compileJSONCallback,\n      compileStandard: compileStandard\n    },\n    features: {\n      legacySingleInput: compileJSON !== null,\n      multipleInputs: compileJSONMulti !== null || compileStandard !== null,\n      importCallback: compileJSONCallback !== null || compileStandard !== null,\n      nativeStandardJSON: compileStandard !== null\n    },\n    compile: compileStandardWrapper,\n    // Temporary wrappers to minimise breaking with other projects.\n    // NOTE: to be removed in 0.5.2\n    compileStandard: compileStandardWrapper,\n    compileStandardWrapper: compileStandardWrapper,\n    // Loads the compiler of the given version from the github repository\n    // instead of from the local filesystem.\n    loadRemoteVersion: function (versionString, cb) {\n      var mem = new MemoryStream(null, {\n        readable: false\n      });\n      var url = 'https://ethereum.github.io/solc-bin/bin/soljson-' + versionString + '.js';\n      https.get(url, function (response) {\n        if (response.statusCode !== 200) {\n          cb(new Error('Error retrieving binary: ' + response.statusMessage));\n        } else {\n          response.pipe(mem);\n          response.on('end', function () {\n            cb(null, setupMethods(requireFromString(mem.toString(), 'soljson-' + versionString + '.js')));\n          });\n        }\n      }).on('error', function (error) {\n        cb(error);\n      });\n    },\n    // Use this if you want to add wrapper functions around the pure module.\n    setupMethods: setupMethods\n  };\n}\n\nmodule.exports = setupMethods;","map":null,"metadata":{},"sourceType":"script"}